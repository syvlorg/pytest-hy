#+nosetuplobfile: yes

* General Properties and Settings
:PROPERTIES:
:header-args:text+: :results raw replace drawer :exports results
:ID:       c821137f-41fe-46e8-aeb6-bb288400d272
:CUSTOM_ID:       c821137f-41fe-46e8-aeb6-bb288400d272
:END:

If setting this up again, use ~C-c C-c~ on the results of the ~emacs-lisp~ code block; taken from [[https://emacs.stackexchange.com/users/91/mankoff][mankoff's]] answer [[https://emacs.stackexchange.com/a/60223/31428][here]]:

#+name: eedc8905-e04c-40d9-97c1-88b840473eaf
#+begin_src text
#+property: header-args -n -r -l "[{(<%s>)}]" :tangle-mode (identity #o444) :noweb yes :mkdirp yes :cache yes
# #+property: header-args:emacs-lisp+ :comments both
#+end_src

#+RESULTS: eedc8905-e04c-40d9-97c1-88b840473eaf
:results:
#+property: header-args -n -r -l "[{(<%s>)}]" :tangle-mode (identity #o444) :noweb yes :mkdirp yes :cache yes
# #+property: header-args:emacs-lisp+ :comments both
:end:

Adapted from [[https://stackoverflow.com/users/776405/whil][Whil's]] answer [[https://stackoverflow.com/a/65232183/10827766][here]]:

#+name: de0dd529-e632-4a70-b31b-8830795d51b7
#+begin_src text
#+startup: show3levels
#+end_src

#+RESULTS: de0dd529-e632-4a70-b31b-8830795d51b7
:results:
#+startup: show3levels
:end:

* HTML Export Options
:PROPERTIES:
:header-args:text+: :results raw replace drawer :exports results
:ID:       0ee9b692-e89d-46f4-9f34-bffa599bf068
:CUSTOM_ID:       0ee9b692-e89d-46f4-9f34-bffa599bf068
:END:

More options can be found [[https://orgmode.org/manual/Export-Settings.html][on the orgmode website]]:

#+name: 20220212070000334862280
#+begin_src text
#+options: num:nil html-style:nil pri:t
#+end_src

#+RESULTS: 20220212070000334862280
:results:
#+options: num:nil html-style:nil pri:t
:end:

** Mathjax

More ~mathjax~ options can be found [[https://orgmode.org/manual/Math-formatting-in-HTML-export.html][on the orgmode website]] and [[http://doc.endlessparentheses.com/Var/org-html-mathjax-options.html][doc.endlessparentheses.com]]:

#+name: 20220212070406770093600
#+begin_src text
#+html_mathjax: align: left indent: 5%
#+end_src

#+RESULTS: 20220212070406770093600
:results:
#+html_mathjax: align: left indent: 5%
:end:

** HTML Headers
:PROPERTIES:
:header-args:html+: :noweb-ref html-head
:END:

More ~html~ options can be found on the orgmode website:
- https://orgmode.org/manual/HTML-specific-export-settings.html
- https://orgmode.org/manual/Publishing-options.html#:~:text=HTML%20specific%20properties
- https://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html#org2656e9f
- https://orgmode.org/guide/HTML-Export.html
- https://orgmode.org/manual/Quoting-HTML-tags.html

Adapted from [[https://raw.githubusercontent.com/alhassy/alhassy.github.io/master/AlBasmala.org#:~:text=HTML%2DPreamble%0A%20%20%3AEND%3A-,%23%2BBEGIN_SRC%20emacs%2Dlisp%20%3Aexports%20results%20%3Aresults%20raw%20replace%20drawer,-(s%2Djoin%20%22%5Cn][here]]:

#+begin_src hy :results raw replace drawer :exports results
(.join "\n" (gfor line (.split #[html-head[
<<html-head>>]html-head] "\n") (+ "#+html_head: " line)))
#+end_src

#+RESULTS:
:results:
#+html_head: <link rel="stylesheet" type="text/css" href="https://combinatronics.com/sylvorg/settings/main/src/styles/primary/syvl.css" />
#+html_head: <link rel="icon" href="https://combinatronics.com/sylvorg/settings/main/src/icons/favicons/shiny-sandshrew-alola.ico" sizes="any" />
#+html_head: <link rel="icon" href="https://combinatronics.com/sylvorg/settings/main/src/icons/favicons/shiny-sandshrew-alola.svg" />
#+html_head: <link rel="manifest" href="https://combinatronics.com/sylvorg/settings/main/manifest.json" />
#+html_head: <link rel="stylesheet" type="text/css" href="https://combinatronics.com/sylvorg/settings/main/src/styles/highlight/paraiso-dark.min.css" />
#+html_head: <script src="https://combinatronics.com/sylvorg/settings/main/src/scripts/highlight/highlight.min.js"></script>
#+html_head: <script>hljs.highlightAll();</script>
#+html_head: <div class="header">
#+html_head: <h1>We Are Syvlorg.</h1>
#+html_head: <a href="">About Me</a>
#+html_head: <a href="">About This Website</a>
#+html_head: <a href="">About Syvlorg</a>
#+html_head: <a href="https://resume.syvl.org">Résumé</a>
#+html_head: <a href="https://index.syvl.org">Index</a>
#+html_head: </div>
:end:

*** Syvl Stylesheet

#+begin_src html
<link rel="stylesheet" type="text/css" href="https://combinatronics.com/sylvorg/settings/main/src/styles/primary/syvl.css" />
#+end_src

*** Favicons

#+begin_src html
<link rel="icon" href="https://combinatronics.com/sylvorg/settings/main/src/icons/favicons/shiny-sandshrew-alola.ico" sizes="any" />
<link rel="icon" href="https://combinatronics.com/sylvorg/settings/main/src/icons/favicons/shiny-sandshrew-alola.svg" />
#+end_src

*** Manifest

#+begin_src html
<link rel="manifest" href="https://combinatronics.com/sylvorg/settings/main/manifest.json" />
#+end_src

*** Highlightjs

Check out more styles here: https://highlightjs.org/static/demo/
Favorites include:
- https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/gradient-dark.min.css
- https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/kimbie-dark.min.css
- https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/paraiso-dark.min.css
- https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/base16/gruvbox-dark-hard.min.css

Unminify using [[https://unminify.com/][this]].

~Note:~ If just ~rel="stylesheet"~ and the ~href~ don't work, add ~type="text/css"~ as well.

Highlightjs theme for development:

#+begin_src html
<link rel="stylesheet" type="text/css" href="https://combinatronics.com/sylvorg/settings/main/src/styles/highlight/paraiso-dark.min.css" />
#+end_src

Custom bundle of languages, built using the instructions from [[https://github.com/highlightjs/highlight.js/issues/3033#issuecomment-943846001][here]]:

#+begin_src sh
node tools/build.js -t browser bash css diff dockerfile hy ini json lisp makefile nim nix plaintext python xml yaml
#+end_src

Highlightjs for development:

#+begin_src html
<script src="https://combinatronics.com/sylvorg/settings/main/src/scripts/highlight/highlight.min.js"></script>
#+end_src

#+begin_src html
<script>hljs.highlightAll();</script>
#+end_src

*** Header

#+begin_src html
<div class="header">
<h1>We Are Syvlorg.</h1>
#+end_src

**** About
***** Me

#+begin_src html
<a href="">About Me</a>
#+end_src

***** This Website

#+begin_src html
<a href="">About This Website</a>
#+end_src

***** Syvlorg

#+begin_src html
<a href="">About Syvlorg</a>
#+end_src

**** Résumé

#+begin_src html
<a href="https://resume.syvl.org">Résumé</a>
#+end_src

**** Index

#+begin_src html
<a href="https://index.syvl.org">Index</a>
#+end_src

**** End of Header

#+begin_src html
</div>
#+end_src

* manifest.json

Adapted from [[https://developer.mozilla.org/en-US/docs/Web/Manifest][here]] and [[https://css-tricks.com/svg-favicons-and-all-the-fun-things-we-can-do-with-them/][here]]:

#+begin_src json :tangle (meq/tangle-path)
{
  "$schema": "https://json.schemastore.org/web-manifest-combined.json",
  "name": "Syvl",
  "short_name": "Syvl",
  "start_url": ".",
  "display": "standalone",
  "description": "A readable Syvlorg.",
  "icons": [
    { "src": "https://combinatronics.com/sylvorg/settings/main/src/icons/favicons/shiny-sandshrew-alola-192.png", "type": "image/png", "sizes": "192x192" },
    { "src": "https://combinatronics.com/sylvorg/settings/main/src/icons/favicons/shiny-sandshrew-alola-512.png", "type": "image/png", "sizes": "512x512" }
  ]
}
#+end_src

* src
** icons
*** favicons
**** shiny-sandshrew-alola.svg

#+begin_src xml :tangle (meq/tangle-path)
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -0.5 68 56" shape-rendering="crispEdges">
<metadata>Made with Pixels to Svg https://codepen.io/shshaw/pen/XbxvNj</metadata>
<path stroke="#000000" d="M26 35h1M28 35h4M25 36h1M27 36h1M32 36h3M25 37h1M34 37h1M25 38h1M33 38h1M35 38h2M24 39h1M33 39h1M37 39h1M24 40h1M38 40h1M43 40h2M24 41h1M30 41h2M39 41h1M42 41h1M44 41h1M24 42h1M29 42h1M40 42h2M44 42h1M25 43h1M29 43h1M43 43h1M25 44h1M43 44h1M25 45h1M42 45h1M26 46h2M41 46h1M27 47h1M40 47h1M28 48h1M39 48h1M28 49h1M32 49h2M39 49h1M29 50h3M34 50h1M38 50h1M34 51h1M38 51h1M35 52h3" />
<path stroke="#c5e6f6" d="M26 36h1M29 36h1M27 37h4M28 38h1M31 38h1M25 39h1M30 39h1M36 39h1M34 40h1M36 40h2M33 41h3M37 41h1M25 42h1M28 42h1M33 42h1M35 42h4M42 42h1M26 43h2M34 43h2M38 43h1M40 43h2M38 44h1M41 44h2M34 45h1M38 45h2M41 45h1M34 46h2M39 46h1M38 47h1M38 48h1M34 49h1M37 49h1" />
<path stroke="#ffffff" d="M28 36h1M30 36h2M32 37h1M26 38h2M29 38h2M32 38h1M31 39h1M26 41h3M36 41h1M43 41h1M26 42h2M30 42h1M43 42h1M36 43h2M42 43h1M35 44h2M39 44h1M35 45h2M37 46h1M36 47h2M34 48h4M35 49h2M35 51h1M37 51h1" />
<path stroke="#7b94ac" d="M26 37h1M31 37h1M33 37h1M34 38h1M26 39h4M32 39h1M34 39h1M25 40h9M25 41h1M29 41h1M32 41h1M32 42h1M32 43h1M34 44h1M38 46h1M28 47h2M39 47h1M33 48h1M30 49h2M38 49h1M35 50h3" />
<path stroke="#414141" d="M35 39h1M35 40h1M38 41h1M34 42h1M39 42h1M33 43h1M39 43h1M31 44h2M37 44h1M40 44h1M29 45h2M33 45h1M37 45h1M40 45h1M28 46h2M33 46h1M36 46h1M40 46h1M30 47h1M34 47h2M29 48h3" />
<path stroke="#314183" d="M31 42h1M30 43h1" />
<path stroke="#7bbbe1" d="M28 43h1M31 43h1M26 44h5M27 45h1M31 47h3M32 48h1" />
<path stroke="#5696bc" d="M33 44h1M28 45h1M31 45h2M30 46h3" />
<path stroke="#7b7b7b" d="M26 45h1" />
<path stroke="#bdbdb4" d="M29 49h1M36 51h1" />
</svg>
#+end_src

**** shiny-zigzagoon-galar.svg

#+begin_src xml :tangle (meq/tangle-path)
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -0.5 68 56" shape-rendering="crispEdges">
<metadata>Made with Pixels to Svg https://codepen.io/shshaw/pen/XbxvNj</metadata>
<path stroke="#000000" d="M41 37h2M32 38h2M36 38h2M40 38h1M42 38h1M27 39h1M29 39h1M31 39h1M34 39h2M37 39h1M39 39h1M43 39h2M26 40h1M28 40h1M30 40h1M38 40h1M44 40h1M26 41h1M45 41h1M45 42h1M25 43h1M44 43h1M25 44h1M42 44h1M25 45h1M41 45h1M24 46h1M40 46h1M24 47h1M40 47h1M24 48h1M37 48h1M40 48h1M25 49h1M36 49h1M25 50h1M28 50h3M34 50h1M25 51h1M30 51h1M33 51h1M26 52h1M31 52h2" />
<path stroke="#d10048" d="M41 38h1M36 39h1M40 39h2M32 40h2M32 41h1M44 42h1M40 43h1M35 44h1M40 44h1M34 45h2M40 45h1" />
<path stroke="#d5004d" d="M32 39h1" />
<path stroke="#bdbebd" d="M33 39h1M38 43h1M37 44h1M36 45h2M25 48h1M36 48h1" />
<path stroke="#313031" d="M42 39h1M44 41h1M26 49h1" />
<path stroke="#ffffff" d="M27 40h1M29 40h1M35 40h1M40 40h1M27 41h1M35 41h3M41 41h2M28 42h2M33 42h1M36 42h2M27 43h4M32 43h3M36 43h1M28 44h1M30 44h4M31 45h2M25 46h2M32 46h2M26 47h1M31 47h2M26 48h2M31 48h3M39 48h1M28 49h3" />
<path stroke="#d20049" d="M31 40h1M31 41h1M38 41h2" />
<path stroke="#c0bfc0" d="M34 40h1M30 42h1M37 43h1M30 45h1" />
<path stroke="#d00047" d="M36 40h2M42 40h2M43 41h1M38 42h2M39 43h1M36 44h1" />
<path stroke="#3c3e3c" d="M39 40h1M30 41h1" />
<path stroke="#c4003b" d="M41 40h1M40 41h1M35 46h1M34 47h2M32 50h2M32 51h1" />
<path stroke="#aaaaaa" d="M28 41h1" />
<path stroke="#ca0042" d="M29 41h1M25 47h1" />
<path stroke="#424142" d="M33 41h2M31 42h2M34 42h2M40 42h2M31 43h1M35 43h1M41 43h1M34 44h1M33 45h1M34 46h1M33 47h1M32 49h2" />
<path stroke="#080808" d="M26 42h1M43 43h1" />
<path stroke="#acacac" d="M27 42h1M26 43h1" />
<path stroke="#bcc3bc" d="M42 42h1M42 43h1" />
<path stroke="#444644" d="M43 42h1" />
<path stroke="#c7003e" d="M26 44h2M26 45h2" />
<path stroke="#c6003d" d="M29 44h1M28 45h2M27 46h1M30 46h2M30 47h1M28 48h1M30 48h1" />
<path stroke="#c0bec0" d="M38 44h1" />
<path stroke="#c90040" d="M39 44h1M38 45h2" />
<path stroke="#b5b6b5" d="M41 44h1" />
<path stroke="#00afb6" d="M28 46h1M28 47h1" />
<path stroke="#ffeeff" d="M29 46h1" />
<path stroke="#bdbfbd" d="M36 46h3M39 47h1" />
<path stroke="#be0034" d="M39 46h1M36 47h3" />
<path stroke="#a8a8a8" d="M27 47h1M29 48h1" />
<path stroke="#5de4e7" d="M29 47h1" />
<path stroke="#474347" d="M34 48h2" />
<path stroke="#aaabaa" d="M38 48h1" />
<path stroke="#bababa" d="M27 49h1" />
<path stroke="#c5c5c5" d="M31 49h1" />
<path stroke="#c6c3c6" d="M34 49h1" />
<path stroke="#090409" d="M35 49h1" />
<path stroke="#000400" d="M38 49h2" />
<path stroke="#229ea4" d="M26 50h1" />
<path stroke="#6cdde3" d="M27 50h1M26 51h1" />
<path stroke="#c8003f" d="M31 50h1" />
<path stroke="#090400" d="M27 51h1" />
<path stroke="#f6fbf6" d="M31 51h1" />
</svg>
#+end_src

**** shiny-linoone-galar.svg

#+begin_src xml :tangle (meq/tangle-path)
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -0.5 68 56" shape-rendering="crispEdges">
<metadata>Made with Pixels to Svg https://codepen.io/shshaw/pen/XbxvNj</metadata>
<path stroke="#000000" d="M38 33h4M37 34h1M42 34h1M36 35h1M41 35h1M36 36h1M41 36h1M37 37h1M42 37h1M28 39h1M33 39h3M44 39h1M27 40h1M29 40h1M31 40h2M44 40h1M26 41h1M30 41h1M44 41h1M26 42h1M43 42h1M25 43h1M43 43h1M24 44h1M44 44h1M24 45h1M44 45h1M23 46h1M44 46h1M23 47h1M39 47h2M43 47h1M23 48h1M28 48h1M37 48h2M41 48h2M36 49h1M24 50h1M27 50h3M34 50h1M24 51h1M26 51h1M33 51h1M25 52h1M31 52h2" />
<path stroke="#c4aab1" d="M38 34h1M38 38h1M38 39h1M28 42h2M38 44h1M38 45h2M33 47h1M31 48h1M30 49h2" />
<path stroke="#ffffff" d="M39 34h3M38 35h2M38 36h3M39 37h3M40 38h2M36 39h2M40 39h3M28 40h1M33 40h3M40 40h3M27 41h2M31 41h1M39 41h4M27 42h1M33 42h1M38 42h4M26 43h1M32 43h2M35 43h5M30 44h4M28 45h4M24 46h1M24 47h2" />
<path stroke="#c7aab3" d="M37 35h1M25 44h1M25 48h1M34 48h2" />
<path stroke="#bea1a9" d="M40 35h1M32 41h1M27 43h1" />
<path stroke="#936e79" d="M37 36h1" />
<path stroke="#d00047" d="M38 37h1M38 40h2M43 40h1M38 41h1M43 41h1M25 46h1" />
<path stroke="#181818" d="M36 38h2" />
<path stroke="#ce0046" d="M39 38h1M39 39h1M28 43h2M39 44h1M25 45h1M32 46h2M32 47h1M30 48h1" />
<path stroke="#bea2a9" d="M42 38h1" />
<path stroke="#000400" d="M43 38h1M24 49h1M35 49h1" />
<path stroke="#cb0043" d="M43 39h1" />
<path stroke="#f6fbf6" d="M36 40h1" />
<path stroke="#a27f86" d="M37 40h1" />
<path stroke="#ca0042" d="M29 41h1M33 41h1M42 42h1M42 43h1" />
<path stroke="#946d79" d="M34 41h2M27 45h1M32 50h2" />
<path stroke="#c90040" d="M36 41h2" />
<path stroke="#d10048" d="M30 42h2M30 43h1M26 44h2M40 44h3M26 45h1M40 45h3" />
<path stroke="#424142" d="M32 42h1M31 43h1M43 44h1M43 45h1M26 47h2M36 48h1M32 49h2" />
<path stroke="#be0034" d="M34 42h2M34 43h1" />
<path stroke="#d20049" d="M36 42h1M41 43h1M28 44h1M33 45h1M38 46h1M40 46h2M38 47h1" />
<path stroke="#c0a5ab" d="M37 42h1M40 43h1M29 44h1M32 45h1" />
<path stroke="#c0a5ac" d="M34 44h1M30 46h1M37 46h1M34 47h1" />
<path stroke="#d5004d" d="M35 44h1M34 45h1M31 46h1M34 46h2M31 47h1M36 47h2" />
<path stroke="#393c39" d="M36 44h1" />
<path stroke="#f7f7f7" d="M37 44h1M27 46h1" />
<path stroke="#393839" d="M35 45h1M36 46h1M30 47h1M35 47h1" />
<path stroke="#c7b0b6" d="M36 45h2" />
<path stroke="#cab2b9" d="M26 46h1" />
<path stroke="#67394a" d="M28 46h2" />
<path stroke="#3c3e3c" d="M39 46h1M41 47h1M24 48h1M25 49h1M34 49h1" />
<path stroke="#3d3e3d" d="M42 46h1" />
<path stroke="#947078" d="M43 46h1" />
<path stroke="#ffeeff" d="M28 47h1" />
<path stroke="#9b7587" d="M29 47h1" />
<path stroke="#00b0b8" d="M42 47h1" />
<path stroke="#407072" d="M26 48h1" />
<path stroke="#00d9e1" d="M27 48h1" />
<path stroke="#3f3e3f" d="M29 48h1M29 49h1" />
<path stroke="#c3a9af" d="M32 48h2" />
<path stroke="#485652" d="M26 49h2" />
<path stroke="#97707c" d="M28 49h1" />
<path stroke="#009ca4" d="M25 50h1" />
<path stroke="#00d5dd" d="M26 50h1" />
<path stroke="#413e41" d="M30 50h2" />
<path stroke="#00dbe2" d="M25 51h1" />
<path stroke="#090409" d="M30 51h1" />
<path stroke="#00e8f0" d="M31 51h1" />
<path stroke="#00767b" d="M32 51h1" />
</svg>
#+end_src

**** shiny-obstagoon.svg

#+begin_src xml :tangle (meq/tangle-path)
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -0.5 68 56" shape-rendering="crispEdges">
<metadata>Made with Pixels to Svg https://codepen.io/shshaw/pen/XbxvNj</metadata>
<path stroke="#181818" d="M30 22h3M26 23h1M28 23h2M33 23h4M24 24h2M27 24h1M37 24h1M23 25h1M36 25h1M22 26h1M37 26h2M21 27h1M39 27h1M21 28h1M40 28h1M42 28h3M21 29h1M41 29h1M45 29h1M20 30h1M46 30h1M20 31h1M46 31h1M20 32h1M46 32h1M20 33h1M25 33h1M45 33h1M46 34h1M19 35h1M46 35h1M46 36h1M19 38h1M22 38h1M26 38h2M29 38h1M44 38h1M23 39h1M28 39h1M44 39h1M25 40h1M28 40h1M43 40h1M25 41h1M29 41h1M42 41h1M22 42h1M24 42h1M30 42h1M42 42h1M23 43h1M31 43h1M43 43h1M30 44h1M35 44h3M43 44h1M30 45h1M34 45h1M44 45h1M29 46h1M34 46h1M39 46h1M45 46h1M28 47h2M34 47h1M39 47h1M45 47h1M27 48h1M33 48h1M39 48h1M46 48h1M28 49h5M40 49h1M45 49h1M40 50h1M46 50h1M40 51h1M46 51h1M41 52h5" />
<path stroke="#c52550" d="M30 23h2M28 24h2M24 25h2M28 25h2M24 26h6M32 26h4M24 27h1M26 27h4M35 27h1M22 28h5M22 29h4M21 30h4M21 31h3M21 32h2M24 32h2M21 33h1M24 33h1" />
<path stroke="#c4244f" d="M32 23h1M26 24h1M30 24h2M33 24h4M26 25h1M30 25h1M32 25h2M30 26h2M22 27h1M29 30h1M22 34h2M22 35h1" />
<path stroke="#414041" d="M32 24h1M31 25h1M23 35h1" />
<path stroke="#6f1f35" d="M27 25h1M23 26h1M23 27h1M30 32h2M32 48h1" />
<path stroke="#424142" d="M34 25h2M40 30h1M43 30h1M30 31h1M43 31h1M38 32h1M42 32h1M38 33h1M28 34h1M29 35h1M32 35h1M41 35h1M40 36h1M40 46h3M30 47h1" />
<path stroke="#a82045" d="M36 26h1M36 27h2" />
<path stroke="#d37f99" d="M25 27h1" />
<path stroke="#313031" d="M30 27h2M28 30h1M32 30h1M32 31h1M26 32h1M38 34h1M39 35h1M28 36h1M30 36h1M32 36h3M39 36h1M29 37h3M35 37h1M39 37h1M36 38h1M37 39h1M35 40h2M38 40h2M34 41h1M40 41h2M31 42h5M39 42h1M36 43h3" />
<path stroke="#ffffff" d="M32 27h3M27 28h1M30 28h2M33 28h3M26 29h2M31 29h1M34 29h2M25 30h1M24 31h2M23 32h1M22 33h2M30 33h2M21 34h1M29 34h2M20 35h1M20 36h2M42 36h1M42 37h1" />
<path stroke="#a21a3f" d="M38 27h1M38 28h2M38 29h2M34 30h3M34 31h3M28 32h2M34 32h1M28 33h2M34 33h1M27 34h1M26 35h2M31 36h1M41 36h1M43 36h1M40 37h2M43 37h1M33 38h2M34 39h2M40 39h2M43 39h1M40 40h2M40 42h2M32 43h1M40 43h3M40 44h2M40 45h2" />
<path stroke="#f7f7f7" d="M28 28h1M26 30h1M19 36h1" />
<path stroke="#292829" d="M29 28h1M28 29h1" />
<path stroke="#393839" d="M32 28h1M32 29h2M36 34h1" />
<path stroke="#f7ffff" d="M36 28h1" />
<path stroke="#a31c40" d="M37 28h1M20 37h1M39 39h1M42 44h1M42 45h1" />
<path stroke="#0c92ae" d="M29 29h1" />
<path stroke="#32b8d4" d="M30 29h1M30 30h1M39 32h1M37 34h1M36 35h1M37 36h1M32 37h1M41 47h1" />
<path stroke="#cccccc" d="M36 29h2M33 30h1M37 30h2M33 31h1M37 31h2M35 32h2M33 33h1M35 33h2M32 34h2M28 35h1M31 35h1M33 35h2M22 36h1M27 36h1M21 37h1M20 38h1M40 38h4M42 39h1M42 40h1M34 43h2M33 44h2M38 44h1M33 45h1M39 45h1" />
<path stroke="#414241" d="M40 29h1M42 29h1M42 35h2M23 38h1M41 50h5" />
<path stroke="#34bad6" d="M43 29h2M44 32h2M44 33h1M38 35h1M34 40h1M44 46h1M41 51h1M43 51h1M45 51h1" />
<path stroke="#686768" d="M27 30h1M26 31h1" />
<path stroke="#c72752" d="M31 30h1M31 31h1" />
<path stroke="#9e163b" d="M39 30h1M39 31h1M32 44h1M32 45h1" />
<path stroke="#33b9d5" d="M41 30h2M44 30h2M40 31h3M44 31h2M40 32h2M43 32h1M41 33h3M31 38h2M31 39h3M32 40h2M43 46h1M42 47h2" />
<path stroke="#212021" d="M27 31h1" />
<path stroke="#a1193d" d="M28 31h2" />
<path stroke="#34edf0" d="M27 32h1M26 33h2M26 34h1" />
<path stroke="#9e173b" d="M32 32h2M32 33h1M23 36h1M22 37h2" />
<path stroke="#c62651" d="M37 32h1" />
<path stroke="#292429" d="M37 33h1" />
<path stroke="#169cb8" d="M39 33h1M40 47h1" />
<path stroke="#1197b3" d="M40 33h1M29 36h1M28 37h1M38 37h1M30 38h1M37 38h1M30 39h1M37 40h1M32 41h2M36 41h4M36 42h3" />
<path stroke="#101410" d="M20 34h1" />
<path stroke="#4aecef" d="M24 34h1" />
<path stroke="#082821" d="M25 34h1" />
<path stroke="#393c39" d="M31 34h1M30 35h1" />
<path stroke="#c2224d" d="M34 34h2" />
<path stroke="#1399b5" d="M39 34h1M42 34h2M35 36h1M36 37h1M35 41h1M40 48h2M44 48h2" />
<path stroke="#1298b4" d="M40 34h2M44 34h2M40 35h1M44 35h2M28 38h1M29 39h1M30 40h2M30 41h1M30 46h4M31 47h3M28 48h2M42 48h2" />
<path stroke="#cc2c57" d="M21 35h1" />
<path stroke="#324d4e" d="M24 35h2" />
<path stroke="#292021" d="M35 35h1" />
<path stroke="#014d5e" d="M37 35h1M36 36h1M37 37h1M29 40h1M31 41h1M42 51h1M44 51h1" />
<path stroke="#101010" d="M18 36h1M18 37h1" />
<path stroke="#174749" d="M24 36h1" />
<path stroke="#fff7ff" d="M25 36h1M24 37h1" />
<path stroke="#9f173c" d="M26 36h1M26 37h1" />
<path stroke="#474547" d="M38 36h1" />
<path stroke="#ae0e39" d="M44 36h1M44 37h1M41 49h1M44 49h1" />
<path stroke="#0f95b1" d="M45 36h1" />
<path stroke="#c82853" d="M19 37h1" />
<path stroke="#608384" d="M25 37h1" />
<path stroke="#100c08" d="M27 37h1" />
<path stroke="#a51d42" d="M33 37h1M36 39h1M39 43h1" />
<path stroke="#ff618c" d="M34 37h1" />
<path stroke="#181418" d="M45 37h1M20 39h2M22 40h1M22 41h1M38 45h1" />
<path stroke="#4f5154" d="M21 38h1" />
<path stroke="#5bc8cc" d="M24 38h1" />
<path stroke="#44797b" d="M25 38h1" />
<path stroke="#df3f6a" d="M35 38h1" />
<path stroke="#313131" d="M38 38h1M38 39h1" />
<path stroke="#413f41" d="M39 38h1" />
<path stroke="#71f2f4" d="M24 39h1M23 41h1" />
<path stroke="#081810" d="M25 39h1" />
<path stroke="#53cbcf" d="M23 40h1" />
<path stroke="#79f2f5" d="M24 40h1M24 41h1M23 42h1" />
<path stroke="#aa3e5b" d="M33 43h1" />
<path stroke="#9c1438" d="M31 44h1M31 48h1" />
<path stroke="#b56379" d="M39 44h1" />
<path stroke="#1096b2" d="M31 45h1M30 48h1" />
<path stroke="#3e3b3e" d="M43 45h1" />
<path stroke="#0a90ac" d="M44 47h1" />
<path stroke="#a82044" d="M42 49h2" />
</svg>
#+end_src

** styles
*** primary
**** syvl.css
:PROPERTIES:
:header-args:css+: :noweb-ref syvl.css
:END:

Adapted from the following:
- [[https://github.com/jessekelly881/Rethink][rethink]]
- [[https://github.com/gongzhitaao/orgcss][orgcss]]
- [[https://gitlab.com/OlMon/org-themes][org-themes]]

~Note:~ More settings can be found [[https://orgmode.org/manual/CSS-support.html][here]].

#+begin_src text :tangle (meq/tangle-path) :exports none
<<syvl.css>>
#+end_src

#+begin_src css
/* @import url('https://fonts.googleapis.com/css?family=Source+Code+Pro:200,300,400'); */

:root {
    --font-size-1: 2rem;
    --font-size-2: 1.5rem;
    --font-size-3: 1.25rem;
    --font-size-4: 1rem;
    --font-size-small: 0.5rem;
    --font-size-xsmall: 0.25rem;
    --margins: 5rem;
    --smaller-margins: 2.5rem;
    --padding: 1rem;
    --header-padding: 0.25rem;
    --background-color: #222222;
    --dracula-orange: #ffb86c;
    --exo-ui-red: #ff5156;
    --joker-purple: #be80ff;
    --acid-green: #DFFF00;
}

.header {
    text-align: center;
    background: var(--background-color);
    font-size: var(--font-size-3);
    border-bottom: 1px solid var(--dracula-orange);
    padding-bottom: var(--padding);
}

/* More information [[https://developer.mozilla.org/en-US/docs/Web/CSS/:not][here]]: */
.header>a:not(:last-child)::after {
    content: " |";
}

.header > a:link {
    color: var(--joker-purple);
    display: inline;
    text-decoration: none;
}

html,
body {
    background-color: var(--background-color);
    font-family: "Courier New", monospace;
    font-weight: 100;
    color: var(--joker-purple);
}

@media only screen and (min-width: 750px) /* Large screens */
{
    html,
    body {
        margin-left: var(--margins);
        margin-right: var(--margins);
    }
}

@media only screen and (max-width: 750px) /* Small screens */
{
    html,
    body {
        margin-left: var(--smaller-margins);
        margin-right: var(--smaller-margins);
    }
}

::selection {
    background-color: var(--dracula-orange);
    color: var(--background-color);
}

h1 {
    font-size: var(--font-size-1);
}

h2 {
    font-size: var(--font-size-2);
}

h1>.subtitle,
h3,
h4,
h5 {
    font-size: var(--font-size-3);
}

h1,
h2,
h3,
h4,
h5,
h6 {
    font-weight: 300;
    letter-spacing: -0.03em;
    color: var(--dracula-orange);
}

h2,
h3,
h4,
h5,
h6 {
    border-bottom: 1px solid var(--joker-purple);
    width: fit-content;
    padding-bottom: var(--header-padding);
}

#table-of-contents {
    padding-bottom: var(--padding);
    border-bottom: 1px solid var(--dracula-orange);
}

#table-of-contents ul,
#table-of-contents li {
    list-style-type: none;
    margin-top: var(--header-padding);
    margin-bottom: var(--header-padding);
}

#table-of-contents .tag {
    float: right;
}

#table-of-contents a:link {
    text-decoration: none;
    color: var(--joker-purple);
}

#table-of-contents a:hover {
    color: var(--exo-ui-red);
}

img {
    max-width: 100%;
}

blockquote {
    border-left: 0.2rem solid var(--dracula-orange);
    padding-left: 1rem;
    font-style: italic;
}

/* Adapted from [[https://css-tricks.com/forums/topic/need-help-to-override-font-color-for-blockquote/#post-99908][here]], and [[https://stackoverflow.com/users/3444240/potashin][potashin's]] answer [[https://stackoverflow.com/a/23631478/10827766][here]]: */
blockquote>p {
    color: var(--exo-ui-red);
}

p,
pre,
ol,
ul,
table,
code {
    color: var(--dracula-orange);
}

.done,
.priority,
.tag,
.todo,
code {
    color: var(--background-color);
    position: relative;
    bottom: .1rem;
    font-size: 80%;
}

.done,
.priority,
.todo,
code {
    font-weight: 400;
    background-clip: padding-box;
    font-family: "Courier New", monospace;
    font-weight: bold;
    line-height: 1
}

.done,
.priority,
.tag>span,
.todo,
code {
    border-radius: 3px;
    padding-top: .1rem;
    padding-left: .3rem;
    padding-right: .3rem;
    line-height: 1;
}

.priority,
.tag>span,
.todo,
code {
    background-image: linear-gradient(160deg, var(--dracula-orange), var(--exo-ui-red));
}

td > code {
    background-image: linear-gradient(160deg, var(--dracula-orange), var(--joker-purple));
}

/* ~.on>code~ refers to a checkbox's checked state; ~.off>code~ refers to the opposite. */
.on>code,
.done {
    background-image: linear-gradient(160deg, var(--dracula-orange), var(--joker-purple));
}

.tag {
    top: .1rem;
    display: block;
    float: right;
    font-weight: 550;
}

.tag>span {
    text-transform: uppercase;
}

table,
#table-of-contents {
    margin-bottom: var(--padding);
}

/* Even Table Row */

tr:nth-child(even) {
    background-color: #2f1e2e;
}

.org-org-meta-line,
.org-keyword {
    color: var(--dracula-orange);
}

a:link,
a:hover,
a:visited,
a:visited:hover {
    text-decoration: none;
}

a:link {
    color: var(--acid-green);
}

a:visited {
    color: var(--joker-purple);
}

/* Adapted from [[https://stackoverflow.com/users/3246606/harry-the-mad-lurker][Harry The Mad Lurker's]] answer [[https://stackoverflow.com/a/21977877/10827766][here]]: */
a:hover,
a:visited:hover {
    color: var(--exo-ui-red);
}

/* Adapted from [[https://css-tricks.com/forums/topic/need-help-to-override-font-color-for-blockquote/#post-99908][here]], and [[https://stackoverflow.com/users/3444240/potashin][potashin's]] answer [[https://stackoverflow.com/a/23631478/10827766][here]]: */
#postamble :not(:last-child)::after {
    content: " |";
}

#postamble>p {
    display: inline;
}

#postamble {
    text-align: center;
    width: 100%;
    font-size: var(--font-size-4)
}

.status {
    padding: var(--padding);
    border-top: 1px solid var(--dracula-orange);
    text-align: center;
}

.outline-text-2,
.outline-text-3,
.outline-text-4 {
    max-width: 100%;
    overflow-x: auto;
}

.underline {
    text-decoration: var(--exo-ui-red) wavy underline;
}

del {
    text-decoration: var(--joker-purple) wavy line-through;
}
#+end_src

*** highlight

Alpha levels for hex colors can be set using the guide [[https://www.digitalocean.com/community/tutorials/css-hex-code-colors-alpha-values][here]];
alpha hex codes can be found on [[https://stackoverflow.com/users/1048340/jared-rummler][Jared Rummler's]] answer [[https://stackoverflow.com/a/25170174][here]].

Regular expressions adapted from [[https://stackoverflow.com/users/4465/levik][levik's]] answer [[https://stackoverflow.com/a/159140][here]].

Peach gradient colorscheme can be found [[https://every-single-one-of-the-things.tumblr.com/post/186683107707/send-me-a-peach-part-of-a-collab-with][here]]:

| Color        | HEX     |
|--------------+---------|
| Tulip        | #F48191 |
| Dark Salmon  | #EF9188 |
| Tumbleweed   | #EDA58B |
| Peach-Orange | #F2BB9B |
| Apricot      | #FBCCB2 |

**** gradient-dark.min.css

#+begin_src css :tangle (meq/tangle-path)
pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{border-radius:0.2rem;background-color:#652487;background-image:linear-gradient(160deg,#F48191,#EF9188,#EDA58B,#F2BB9B,#FBCCB2);color:#222222}.hljs-subtr{color:#e7e4eb}.hljs-comment,.hljs-doctag,.hljs-meta,.hljs-quote{color:#af8dd9}.hljs-attr,.hljs-regexp,.hljs-selector-id,.hljs-selector-tag,.hljs-tag,.hljs-template-tag{color:#aefbff}.hljs-bullet,.hljs-params,.hljs-selector-class{color:#f19fff}.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-section,.hljs-symbol,.hljs-type{color:#17fc95}.hljs-addition,.hljs-link,.hljs-number{color:#c5fe00}.hljs-string{color:#38c0ff}.hljs-addition,.hljs-attribute{color:#e7ff9f}.hljs-template-variable,.hljs-variable{color:#e447ff}.hljs-built_in,.hljs-class,.hljs-formula,.hljs-function,.hljs-name,.hljs-title{color:#ffc800}.hljs-deletion,.hljs-literal,.hljs-selector-pseudo{color:#ff9e44}.hljs-emphasis,.hljs-quote{font-style:italic}.hljs-keyword,.hljs-params,.hljs-section,.hljs-selector-class,.hljs-selector-id,.hljs-selector-tag,.hljs-strong,.hljs-template-tag{font-weight:700}
#+end_src

**** gruvbox-dark-hard.min.css

#+begin_src css :tangle (meq/tangle-path)
pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{border-radius:0.2rem;color:#d5c4a1;background:#1d2021}.hljs ::selection,.hljs::selection{background-color:#504945;color:#d5c4a1}.hljs-comment{color:#665c54}.hljs-tag{color:#bdae93}.hljs-operator,.hljs-punctuation,.hljs-subst{color:#d5c4a1}.hljs-operator{opacity:.7}.hljs-bullet,.hljs-deletion,.hljs-name,.hljs-selector-tag,.hljs-template-variable,.hljs-variable{color:#fb4934}.hljs-attr,.hljs-link,.hljs-literal,.hljs-number,.hljs-symbol,.hljs-variable.constant_{color:#fe8019}.hljs-class .hljs-title,.hljs-title,.hljs-title.class_{color:#fabd2f}.hljs-strong{font-weight:700;color:#fabd2f}.hljs-addition,.hljs-code,.hljs-string,.hljs-title.class_.inherited__{color:#b8bb26}.hljs-built_in,.hljs-doctag,.hljs-keyword.hljs-atrule,.hljs-quote,.hljs-regexp{color:#8ec07c}.hljs-attribute,.hljs-function .hljs-title,.hljs-section,.hljs-title.function_,.ruby .hljs-property{color:#83a598}.diff .hljs-meta,.hljs-keyword,.hljs-template-tag,.hljs-type{color:#d3869b}.hljs-emphasis{color:#d3869b;font-style:italic}.hljs-meta,.hljs-meta .hljs-keyword,.hljs-meta .hljs-string{color:#d65d0e}.hljs-meta .hljs-keyword,.hljs-meta-keyword{font-weight:700}
#+end_src

**** kimbie-dark.min.css

#+begin_src css :tangle (meq/tangle-path)
pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{border-radius:0.2rem;background:#221a0f;color:#d3af86}.hljs-comment,.hljs-quote{color:#d6baad}.hljs-meta,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#dc3958}.hljs-built_in,.hljs-deletion,.hljs-link,.hljs-literal,.hljs-number,.hljs-params,.hljs-type{color:#f79a32}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#889b4a}.hljs-function,.hljs-keyword,.hljs-selector-tag{color:#98676a}.hljs-attribute,.hljs-section,.hljs-title{color:#f06431}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}
#+end_src

**** paraiso-dark.min.css

#+begin_src css :tangle (meq/tangle-path)
pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{border-radius:0.2rem;background:#2f1e2e;color:#a39e9b}.hljs-comment,.hljs-quote{color:#8d8687}.hljs-link,.hljs-meta,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ef6155}.hljs-built_in,.hljs-deletion,.hljs-literal,.hljs-number,.hljs-params,.hljs-type{color:#f99b15}.hljs-attribute,.hljs-section,.hljs-title{color:#fec418}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#48b685}.hljs-keyword,.hljs-selector-tag{color:#815ba4}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}
#+end_src

* patches
** bcachefs-module.patch

#+begin_src diff :tangle (meq/tangle-path)
diff --git a/nixos/modules/tasks/filesystems/bcachefs.nix b/nixos/modules/tasks/filesystems/bcachefs.nix
index 5fda24adb97..897ddf03927 100644
--- a/nixos/modules/tasks/filesystems/bcachefs.nix
+++ b/nixos/modules/tasks/filesystems/bcachefs.nix
@@ -45,7 +45,7 @@ in
       system.fsPackages = [ pkgs.bcachefs-tools ];
 
       # use kernel package with bcachefs support until it's in mainline
-      boot.kernelPackages = pkgs.linuxPackages_testing_bcachefs;
+      # boot.kernelPackages = pkgs.linuxPackages_testing_bcachefs;
     }
 
     (mkIf ((elem "bcachefs" config.boot.initrd.supportedFilesystems) || (bootFs != {})) {
#+end_src

** licenses.patch

#+begin_src diff :tangle (meq/tangle-path)
diff --git a/lib/licenses.nix b/lib/licenses.nix
index 4fa6d6abc7a..198b570e0ae 100644
--- a/lib/licenses.nix
+++ b/lib/licenses.nix
@@ -690,6 +690,11 @@ in mkLicense lset) ({
     fullName = "OpenSSL License";
   };
 
+  oreo = {
+    fullName = "Oreo Public License";
+    free = true;
+  };
+
   osl2 = {
     spdxId = "OSL-2.0";
     fullName = "Open Software License 2.0";
#+end_src

** python.patch

#+begin_src diff :tangle (meq/tangle-path)
diff --git a/pkgs/top-level/aliases.nix b/pkgs/top-level/aliases.nix
index 7b9c55ee702..4c86533cad5 100644
--- a/pkgs/top-level/aliases.nix
+++ b/pkgs/top-level/aliases.nix
@@ -1154,10 +1154,10 @@ mapAliases ({
   pyrex095 = throw "pyrex has been removed from nixpkgs as the project is still stuck on python2"; # Added 2022-01-12
   pyrex096 = throw "pyrex has been removed from nixpkgs as the project is still stuck on python2"; # Added 2022-01-12
   pyrit = throw "pyrit has been removed from nixpkgs as the project is still stuck on python2"; # Added 2022-01-01
-  python = python2; # Added 2022-01-11
+  python = python3; # Added 2022-01-11
   python-swiftclient = swiftclient; # Added 2021-09-09
   python2nix = throw "python2nix has been removed as it is outdated. Use e.g. nixpkgs-pytools instead"; # Added 2021-03-08
-  pythonFull = python2Full; # Added 2022-01-11
+  pythonFull = python3Full; # Added 2022-01-11
   pythonPackages = python.pkgs; # Added 2022-01-11
 
   ### Q ###
diff --git a/pkgs/top-level/all-packages.nix b/pkgs/top-level/all-packages.nix
index 1803508bdd4..da416ccaea6 100644
--- a/pkgs/top-level/all-packages.nix
+++ b/pkgs/top-level/all-packages.nix
@@ -14502,7 +14502,7 @@ with pkgs;
   # available as `pythonPackages.tkinter` and can be used as any other Python package.
   # When switching these sets, please update docs at ../../doc/languages-frameworks/python.md
   python2 = python27;
-  python3 = python39;
+  python3 = python310;
 
   # pythonPackages further below, but assigned here because they need to be in sync
   python2Packages = dontRecurseIntoAttrs python27Packages;
#+end_src

** hy.patch

#+begin_src diff :tangle (meq/tangle-path)
diff --git a/pkgs/development/python-modules/hy/default.nix b/pkgs/development/python-modules/hy/default.nix
index a962f868..a84a95ac 100644
--- a/pkgs/development/python-modules/hy/default.nix
+++ b/pkgs/development/python-modules/hy/default.nix
@@ -16,18 +16,22 @@
 
 buildPythonPackage rec {
   pname = "hy";
-  version = "1.0a4";
+  version = "0.24.0";
   format = "setuptools";
 
   disabled = pythonOlder "3.7";
 
   src = fetchFromGitHub {
-    owner = "hylang";
-    repo = pname;
-    rev = version;
-    sha256 = "sha256-MBzp3jqBg/kH233wcgYYHc+Yg9GuOaBsXIfjFDihD1E=";
+      owner = "hylang";
+      repo = pname;
+      rev = version;
+      sha256 = "1s458ymd9g3s8k2ccc300jr4w66c7q3vhmhs9z3d3a4qg0xdhs9y";
   };
 
+  postPatch = ''substituteInPlace setup.py --replace "\"funcparserlib ~= 1.0\"," ""'';
+
+  disabledTestPaths = [ "tests/test_bin.py" ];
+
   # https://github.com/hylang/hy/blob/1.0a4/get_version.py#L9-L10
   HY_VERSION = version;
#+end_src

* setup-var.pl

Adapted from [[https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/system/etc/setup-etc.pl][here]]:

#+begin_src perl :tangle (meq/tangle-path)
use strict;
use File::Find;
use File::Copy;
use File::Path;
use File::Basename;
use File::Slurp;

my $var = $ARGV[0] or die;
my $static = "/var/static";

sub atomicSymlink {
    my ($source, $target) = @_;
    my $tmp = "$target.tmp";
    unlink $tmp;
    symlink $source, $tmp or return 0;
    rename $tmp, $target or return 0;
    return 1;
}


# Atomically update /var/static to point at the var files of the
# current configuration.
atomicSymlink $var, $static or die;

# Returns 1 if the argument points to the files in /var/static.  That
# means either argument is a symlink to a file in /var/static or a
# directory with all children being static.
sub isStatic {
    my $path = shift;

    if (-l $path) {
        my $target = readlink $path;
        return substr($target, 0, length "/var/static/") eq "/var/static/";
    }

    if (-d $path) {
        opendir DIR, "$path" or return 0;
        my @names = readdir DIR or die;
        closedir DIR;

        foreach my $name (@names) {
            next if $name eq "." || $name eq "..";
            unless (isStatic("$path/$name")) {
                return 0;
            }
        }
        return 1;
    }

    return 0;
}

# Remove dangling symlinks that point to /var/static.  These are
# configuration files that existed in a previous configuration but not
# in the current one.  For efficiency, don't look under /var/nixos
# (where all the NixOS sources live).
sub cleanup {
    if ($File::Find::name eq "/var/nixos") {
        $File::Find::prune = 1;
        return;
    }
    if (-l $_) {
        my $target = readlink $_;
        if (substr($target, 0, length $static) eq $static) {
            my $x = "/var/static/" . substr($File::Find::name, length "/var/");
            unless (-l $x) {
                print STDERR "removing obsolete symlink ‘$File::Find::name’...\n";
                unlink "$_";
            }
        }
    }
}

find(\&cleanup, "/var");


# Use /var/.clean to keep track of copied files.
my @oldCopied = read_file("/var/.clean", chomp => 1, err_mode => 'quiet');
open CLEAN, ">>/var/.clean";


# For every file in the var tree, create a corresponding symlink in
# /var to /var/static.  The indirection through /var/static is to make
# switching to a new configuration somewhat more atomic.
my %created;
my @copied;

sub link {
    my $fn = substr $File::Find::name, length($var) + 1 or next;
    my $target = "/var/$fn";
    File::Path::make_path(dirname $target);
    $created{$fn} = 1;

    # Rename doesn't work if target is directory.
    if (-l $_ && -d $target) {
        if (isStatic $target) {
            rmtree $target or warn;
        } else {
            warn "$target directory contains user files. Symlinking may fail.";
        }
    }

    if (-e "$_.mode") {
        my $mode = read_file("$_.mode"); chomp $mode;
        if ($mode eq "direct-symlink") {
            atomicSymlink readlink("$static/$fn"), $target or warn;
        } else {
            my $uid = read_file("$_.uid"); chomp $uid;
            my $gid = read_file("$_.gid"); chomp $gid;
            copy "$static/$fn", "$target.tmp" or warn;
            $uid = getpwnam $uid unless $uid =~ /^\+/;
            $gid = getgrnam $gid unless $gid =~ /^\+/;
            chown int($uid), int($gid), "$target.tmp" or warn;
            chmod oct($mode), "$target.tmp" or warn;
            rename "$target.tmp", $target or warn;
        }
        push @copied, $fn;
        print CLEAN "$fn\n";
    } elsif (-l "$_") {
        atomicSymlink "$static/$fn", $target or warn;
    }
}

find(\&link, $var);


# Delete files that were copied in a previous version but not in the
# current.
foreach my $fn (@oldCopied) {
    if (!defined $created{$fn}) {
        $fn = "/var/$fn";
        print STDERR "removing obsolete file ‘$fn’...\n";
        unlink "$fn";
    }
}


# Rewrite /var/.clean.
close CLEAN;
write_file("/var/.clean", map { "$_\n" } @copied);

# Create /var/NIXOS tag if not exists.
# When /var is not on a persistent filesystem, it will be wiped after reboot,
# so we need to check and re-create it during activation.
open TAG, ">>/var/NIXOS";
close TAG;
#+end_src

* makefile

~Note:~ Deprecated

Adapted from the following places:
- https://www.systutorials.com/how-to-get-the-full-path-and-directory-of-a-makefile-itself/
- https://t-ravis.com/post/nix/nix-make/
- [[https://stackoverflow.com/a/50754044/10827766][this answer]] by [[https://stackoverflow.com/users/1296044/arielf][arielf]]
- [[https://stackoverflow.com/a/29098246/10827766][this answer]] by [[https://stackoverflow.com/users/939557/madscientist][MadScientist]]
- https://gist.github.com/weshouman/f44f330227972073371e1baa510c0d37
- [[https://unix.stackexchange.com/a/394491/270053][this answer]] by [[https://unix.stackexchange.com/users/148009/romanperekhrest][RomanPerekhrest]]
- [[https://stackoverflow.com/a/13945900/10827766][this answer]] by [[https://stackoverflow.com/users/77345/eric-melski][Eric Melski]]
- [[https://stackoverflow.com/a/44416055/10827766][this answer]] by [[https://stackoverflow.com/users/412080/maxim-egorushkin][Maxim Egorushkin]]

~Note:~ To export an environment variable for a single, multi-command command, use [[https://stackoverflow.com/a/10856211/10827766][this answer]] by [[https://stackoverflow.com/users/476371/0xc0000022l][0xC0000022L]].

#+name: makefile
#+begin_src makefile
.RECIPEPREFIX := |
.DEFAULT_GOAL := tangle
.ONESHELL:

mkfilePath := $(abspath $(lastword $(MAKEFILE_LIST)))
mkfileDir := $(dir $(mkfilePath))
realfileDir := $(realpath $(mkfileDir))

preFiles := $(mkfileDir)/nix.org $(mkfileDir)/flake.org $(mkfileDir)/tests.org $(mkfileDir)/README.org

removeTangleBackups := find $(mkfileDir) -name '.\#*.org*' -print | xargs rm &> /dev/null || :

define fallbackCommand
$(removeTangleBackups)
$1
if [ $$? -ne 0 ]; then
    org-tangle -f $2 > /dev/null
    $1
fi
endef

define preFallback
$(call fallbackCommand,$1,$(preFiles))
endef

define nixShell
nix-shell -E '(import $(realfileDir)).devShells.$${builtins.currentSystem}.makefile-$1' --show-trace --run
endef

define quickShell
nix-shell -E 'with (import $(realfileDir)).pkgs.$${builtins.currentSystem}; with lib; mkShell { buildInputs = flatten [ $1 ]; }' --show-trace
endef

projectName := $(subst ",,$(shell $(call preFallback,nix eval --show-trace --impure --expr '(import $(realfileDir)).pname')))
ifndef projectName
$(error Sorry; unable to get the name of the project)
endif

type := $(subst ",,$(shell $(call preFallback,nix eval --show-trace --impure --expr '(import $(realfileDir)).type')))
ifndef type
$(error Sorry; unable to get the type of project)
endif

files := $(preFiles) $(mkfileDir)/$(projectName)

define fallback
$(call fallbackCommand,$1,$(files))
endef

addCommand := git -C $(mkfileDir) add .
updateCommand := $(call fallback,nix flake update --show-trace $(realfileDir))

define tangleCommand
$(removeTangleBackups)
$(call nixShell,general) "org-tangle -f $1"
if [ $$? -ne 0 ]; then
    org-tangle -f $1
fi
$(addCommand)
endef

define wildcardValue
$(shell echo $1 | cut -d "-" -f2-)
endef

add:
|$(addCommand)

commit: | add
|git -C $(mkfileDir) commit --allow-empty-message -am ""

push: | commit
|git -C $(mkfileDir) push

update: | add
ifeq ($(projectName), settings)
|$(shell $(call fallback,nix eval --impure --expr 'with (import $(realfileDir)); with pkgs.$${builtins.currentSystem}.lib; "nix flake lock $(realfileDir) --update-input $${concatStringsSep " --update-input " (filter (input: ! ((elem input [ "nixos-master" "nixos-unstable" ]) || (hasSuffix "-small" input))) (attrNames inputs))}"' | tr -d '"'))
else
|$(updateCommand)
endif

update-%: updateInput := nix flake lock $(realfileDir) --show-trace --update-input
update-%: | add
|$(eval input := $(call wildcardValue,$@))
|if [ "$(input)" == "settings" ] && [ "$(projectName)" != "settings" ]; then
|    $(call fallback,$(updateInput) $(input))
|elif [ "$(input)" == "all" ]; then
|    $(updateCommand)
|else
|    $(call fallback,$(updateInput) $(input))
|fi

pre-tangle: | update-settings
|$(removeTangleBackups)

tangle: | pre-tangle
|$(call tangleCommand,$(files))

tangle-%: | pre-tangle
|$(eval file := $(mkfileDir)/$(call wildcardValue,$@).org)
|$(call tangleCommand,$(file))

tu: | tangle update

tu-%: | tangle update-% ;

develop: | tu
|nix develop --show-trace "$(realfileDir)#makefile-$(type)"

shell: | tu
|$(call quickShell,$(pkgs))

shell-%: | tu
|$(call quickShell,(with $(call wildcardValue,$@); [ $(pkgs) ]))

develop-%: | tu
|nix develop --show-trace "$(realfileDir)#$(call wildcardValue,$@)"

repl: | tu
|$(call nixShell,$(type)) "$(type)"

build: | tu
|nix build --show-trace "$(realfileDir)"

build-%: | tu
|nix build --show-trace "$(realfileDir)#$(call wildcardValue,$@)"

run: | tu
|cd $(mkfileDir)
|$(call nixShell,$(type)) "$(command)"

run-%: | tu
|nix run --show-trace "$(realfileDir)#$(call wildcardValue,$@)" -- $(args)

rund: | run-default

define touch-test-command
cd $(mkfileDir)
$(call nixShell,$(type)) "touch $1 && $(type) $1"
endef

touch-test: | tu
|$(call touch-test-command,$(file))

touch-test-%: | tu
|$(eval file := $(mkfileDir)/$(call wildcardValue,$@))
|$(call touch-test-command,$(file))

quick: | tangle push

super: | tu push

super-%: | tu-% push ;
#+end_src

* .envrc

#+name: envrc
#+begin_src shell :tangle (meq/tangle-path)
use nix
#+end_src

* templates
** general
*** makefile

~Note:~ Deprecated

#+begin_src makefile
<<makefile>>
#+end_src

*** nix.org

#+name: 97220a9c-af77-4056-b7f8-00e11819e210
#+begin_src emacs-lisp :var type="" isApp=""
(format "* .envrc

,#+begin_src shell :tangle (meq/tangle-path)
<<envrc>>
,#+end_src

,* shell.nix

Adapted from [[https://github.com/edolstra/flake-compat#usage][here]]:

,#+begin_src nix :tangle (meq/tangle-path)
<<shell.nix(elisp='t)>>
,#+end_src

,* default.nix

Adapted from [[https://github.com/edolstra/flake-compat#usage][here]]:

,#+begin_src nix :tangle (meq/tangle-path)
<<default.nix(elisp='t)>>
,#+end_src

,* flake.nix

,#+begin_src nix :tangle (meq/tangle-path)
{

    # TODO: Change this!
    description = \"\";

    inputs = rec {
        settings.url = github:sylvorg/settings;
        titan.url = github:syvlorg/titan;
        flake-utils.url = github:numtide/flake-utils;
        flake-compat = {
            url = \"github:edolstra/flake-compat\";
            flake = false;
        };
    };
    outputs = inputs@{ self, flake-utils, settings, ... }: with builtins; with settings.lib; with flake-utils.lib; settings.mkOutputs {
        inherit inputs;
        %s
        # TODO: Change this!
        pname = \"\";
        %s
        # TODO: Change this!
        callPackage = {}: {};
    };
}
,#+end_src" (if (string= type "") "" (format "type = \"%s\";\n" type))
            (if (string= isApp "") "" (format "\n        isApp = %s;\n" isApp)))
#+end_src

#+begin_src text :tangle (meq/tangle-path)
<<97220a9c-af77-4056-b7f8-00e11819e210()>>
#+end_src

** python-app
*** makefile

~Note:~ Deprecated

Adapted from [[https://stackoverflow.com/users/428803/joshua][Joshua's]] answer [[https://stackoverflow.com/a/4210080/10827766][here]],
[[https://superuser.com/users/48602/notinlist][Notinlist's]] answer [[https://superuser.com/a/566199/1154755][here]],
and [[https://www.cyberciti.biz/faq/how-to-show-recursive-directory-listing-on-linux-or-unix/][here]]:

#+name: 8524a302-71f9-4752-9fbf-675d99285846
#+begin_src makefile
<<makefile>>

poetry2setup: | tu
|cd $(mkfileDir)
|$(call nixShell,$(type)) "poetry2setup > $(mkfileDir)/setup.py"

touch-tests:
|-find $(mkfileDir)/tests -print | grep -v __pycache__ | xargs touch

tut: | tu touch-tests

define pytest
$(call nixShell,$(type)) "pytest $1 --suppress-no-test-exit-code $(mkfileDir)"
endef

test: | tut
|$(call pytest)

test-native: | tut
|$(call pytest,--tb=native)

test-%: | tut
|$(call pytest,-m $(call wildcardValue,$@))

super: | test push
#+end_src

*** nix.org

#+begin_src text :tangle (meq/tangle-path)
<<97220a9c-af77-4056-b7f8-00e11819e210(type="hy", isApp="true")>>
#+end_src

** python-package
*** makefile

#+begin_src makefile
<<8524a302-71f9-4752-9fbf-675d99285846>>
#+end_src

*** nix.org

#+begin_src text :tangle (meq/tangle-path)
<<97220a9c-af77-4056-b7f8-00e11819e210(type="hy")>>
#+end_src

* default.nix

Adapted from [[https://github.com/edolstra/flake-compat#usage][here]]:

#+name: default.nix
#+begin_src emacs-lisp :var elisp='nil
(format-spec "with builtins; if (builtins ? getFlake) then (getFlake (toString ./.)) else (import fetchTarball (let
    lockExists = pathExists ./flake.lock;
    lock = if lockExists then (fromJSON (readFile ./flake.lock)) else { nodes.flake-compat.locked.rev = %qmaster%q; };
in {
    url = %qhttps://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz%q;
    ${if lockExists then %qsha256%q else null} = lock.nodes.flake-compat.locked.narHash;
}) { src = ./.; }).defaultNix" `((?q . ,(if elisp "\\\"" "\""))))
#+end_src

#+begin_src nix :tangle (meq/tangle-path)
<<default.nix()>>
#+end_src

* shell.nix

#+name: shell.nix
#+begin_src emacs-lisp :var elisp='nil
(format-spec "with builtins; let
    this-flake = import ./.;
    flake = this-flake.inputs.titan or this-flake.inputs.settings.inputs.titan or (if (builtins ? getFlake) then (getFlake github:syvlorg/titan) else (import fetchTarball (let
        lockExists = pathExists ./flake.lock;
        lock = if lockExists then (fromJSON (readFile ./flake.lock)) else { nodes.titan.locked.rev = %qmain%q; };
    in {
        url = %qhttps://github.com/syvlorg/titan/archive/${lock.nodes.titan.locked.rev}.tar.gz%q;
        ${if lockExists then %qsha256%q else null} = lock.nodes.titan.locked.narHash;
    }) { src = ./.; }).defaultNix);
    inherit (flake.${currentSystem}) pkgs;
in with pkgs; mkShell rec {
    buildInputs = [ titan ];
    nativeBuildInputs = buildInputs;
}" `((?q . ,(if elisp "\\\"" "\""))))
#+end_src

#+begin_src nix :tangle (meq/tangle-path)
<<shell.nix()>>
#+end_src

* .gitignore

#+begin_src gitignore
**/*.*~
**/*.direnv
**/*.envrc:*
node_modules/
package-lock.json
package.json
#+end_src

* bin
** org-export

Adapted from [[https://github.com/hlissner/doom-emacs/blob/master/bin/org-tangle][here]]:

#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
;;; bin/org-export

;; Exports blocks from org files. Debug/info messages are directed to stderr and
;; can be ignored.
;;
;;   -a/--all
;;     Export all blocks by default (unless it has :exports none set or a
;;     :noexport: tag)
;;   -t/--tag TAG
;;      --and TAG
;;      --or TAG
;;     Only include blocks in trees that have these tags. Combine multiple --and
;;     and --or's, or just use --tag (implicit --and).
;;   -p/--print
;;     Prints exported code to stdout instead of to files
;;
;; Usage: org-export some-file.org another.org
;; Examples:
;;   org-export -l sh modules/some/module/README.org > install_module.sh
;;   org-export -l sh modules/lang/go/README.org | sh
;;   org-export --and tagA --and tagB my/literate/config.org

(require 'cl-lib)
(require 'ox)
(require 'ox-html)
(load-file (concat (file-name-directory (or load-file-name buffer-file-name)) "org-export-functions.el"))

(setq debug-on-error t)

(defun usage ()
  (with-temp-buffer
    (insert (format "%s %s [OPTIONS] [TARGETS...]\n"
                    "[1mUsage:[0m"
                    (file-name-nondirectory load-file-name))
            "\n"
            "A command line interface for tangling org-mode files. TARGETS can be\n"
            "files or folders (which are searched for org files recursively).\n"
            "\n"
            "This is useful for literate configs that rely on command line\n"
            "workflows to build it.\n"
            "\n"
            "[1mExample:[0m\n"
            "  org-export some-file.org\n"
            "  org-export literate/config/\n"
            "  org-export -p -l sh scripts.org > do_something.sh\n"
            "  org-export -p -l python -t tagA -t tagB file.org | python\n"
            "\n"
            "[1mOptions:[0m\n"
            "  -a --all\t\tExport all blocks by default\n"
            "  -p --print\t\tPrint exported output to stdout than to files\n"
            "  -t --tag TAG\n"
            "     --and TAG\n"
            "     --or TAG\n"
            "    Lets you export org blocks by tag. You may have more than one\n"
            "    of these options.\n")
    (princ (buffer-string))))

(defun *org-babel-export (fn &rest args)
  "Don't write exported blocks to files, print them to stdout."
  (cl-letf (((symbol-function 'write-region)
             (lambda (start end filename &optional append visit lockname mustbenew)
               (princ (buffer-string)))))
    (apply fn args)))

(defvar all-blocks nil)
(defvar and-tags nil)
(defvar or-tags nil)
(let (srcs and-tags or-tags)
  (pop argv)
  (while argv
    (let ((arg (pop argv)))
      (pcase arg
        ((or "-h" "--help")
         (usage)
         (error ""))
        ((or "-a" "--all")
         (setq all-blocks t))
        ((or "-p" "--print")
         (advice-add #'org-html-export-to-html :around #'*org-babel-export))
        ((or "-t" "--tag" "--and")
         (push (pop argv) and-tags))
        ("--or"
         (push (pop argv) or-tags))
        ((guard (file-directory-p arg))
         (setq srcs
               (append (directory-files-recursively arg "\\.org$")
                       srcs)))
        ((guard (file-exists-p arg))
         (push arg srcs))
        (_ (error "Unknown option or file: %s" arg)))))

  (dolist (file srcs)
                (message (format "\n\nNow exporting %s:\n" file))
    (let ((backup (make-temp-file (file-name-base file) nil ".backup.org")))
      (unwind-protect
          ;; Prevent slow hooks from interfering
          (let (org-mode-hook org-confirm-babel-evaluate)
               (with-current-buffer (find-file-noselect file)
               (org-html-export-to-html)))
        (ignore-errors (delete-file backup)))))
  (kill-emacs 0))
#+end_src

** org-export-functions.el
:PROPERTIES:
:header-args:emacs-lisp+: :noweb-ref 11788ba8-f3e9-4122-8cb4-d4c18d4f031d
:END:

Adapted from [[https://github.com/bzg/org-mode/blob/main/lisp/ox-html.el#L3471][here]], and inspired by [[https://stackoverflow.com/users/569280/ebpa][ebpa's]] answer [[https://stackoverflow.com/a/37404938][here]]:

#+begin_src text :tangle (meq/tangle-path) :exports none
<<11788ba8-f3e9-4122-8cb4-d4c18d4f031d>>
#+end_src

#+name: 777bbfd5-1d72-49ff-89d6-b3e7e8fc7609
#+begin_src emacs-lisp
(setq org-export-functions-directory (file-name-directory (or load-file-name buffer-file-name))
      windows (member system-type '(windows-nt ms-dos)))
(defun meq/oefd (&rest args) (apply #'concat org-export-functions-directory (mapcar #'(lambda (arg) (concat (if windows "\\" "/") arg)) args)))
#+end_src

~Note:~ ~org-tangle-functions.el~ is required due to [[https://github.com/bzg/org-mode/blob/d2f4d4b457a9fe7a7dbcfbd2d71c723ffa8c2726/lisp/ob-core.el#L625][this]].

#+begin_src emacs-lisp
(load-file (meq/oefd "org-tangle-functions.el"))
#+end_src

~Note:~ From [[https://narkive.com/69IaWEJV:2.1599.178][here]]:

#+begin_quote
The value of the variable is saved to the file when emacs exits and when org-id-find is called and cannot find the id (I think),
or you eval ~(org-id-locations-save)~ explicitly.
#+end_quote

#+begin_src emacs-lisp
(defun meq/org-html-src-block (src-block _contents info)
  "Transcode a SRC-BLOCK element from Org to HTML.
CONTENTS holds the contents of the item.  INFO is a plist holding
contextual information."
  (if (org-export-read-attribute :attr_html src-block :textarea)
      (org-html--textarea-block src-block)
    (let* ((lang (org-element-property :language src-block))
           (lang (cond ((member lang '("emacs-lisp")) "lisp")
                       ((member lang '("shell" "zsh" "bash")) "sh")
                       ((member lang '("text")) "plaintext")
                       (t lang)))
           (code (org-html-format-code src-block info))
           (label (let ((lbl (org-html--reference src-block info t)))
                    (if lbl (format " id=\"%s\"" lbl) "")))
           (klipsify  (and  (plist-get info :html-klipsify-src)
                            (member lang '("javascript" "js"
                                           "ruby" "scheme" "clojure" "php" "html")))))
      (if (not lang) (format "<pre class=\"example\"%s>\n%s</pre>" label code)
        (format "<div class=\"org-src-container\">\n%s%s\n</div>"
                ;; Build caption.
                (let ((caption (org-export-get-caption src-block)))
                  (if (not caption) ""
                    (let ((listing-number
                           (format
                            "<span class=\"listing-number\">%s </span>"
                            (format
                             (org-html--translate "Listing %d:" info)
                             (org-export-get-ordinal
                              src-block info nil #'org-html--has-caption-p)))))
                      (format "<label class=\"org-src-name\">%s%s</label>"
                              listing-number
                              (org-trim (org-export-data caption info))))))
                ;; Contents.
                (if klipsify
                    (format "<pre><code class=\"src src-%s\"%s%s>%s</code></pre>"
                            lang
                            label
                            (if (string= lang "html")
                                " data-editor-type=\"html\""
                              "")
                            code)
                  (format "<pre><code class=\"language-%s match-braces rainbow-braces\"%s>%s</code></pre>"
                          lang label code)))))))
        (advice-add #'org-html-src-block :override #'meq/org-html-src-block)
#+end_src

Adapted from [[https://github.com/bzg/org-mode/blob/main/lisp/ox-html.el#L2701][here]], and inspired by [[https://stackoverflow.com/users/569280/ebpa][ebpa's]] answer [[https://stackoverflow.com/a/37404938][here]]:

#+begin_src emacs-lisp
(defun meq/org-html-inline-src-block (inline-src-block _contents info)
  "Transcode an INLINE-SRC-BLOCK element from Org to HTML.
CONTENTS holds the contents of the item.  INFO is a plist holding
contextual information."
  (let* ((lang (org-element-property :language inline-src-block))
         (code (org-html-fontify-code
                (org-element-property :value inline-src-block)
                lang))
         (label
          (let ((lbl (org-html--reference inline-src-block info t)))
            (if (not lbl) "" (format " id=\"%s\"" lbl)))))
    (format "<code class=\"language-%s match-braces rainbow-braces\"%s>%s</code>" lang label code)))
(advice-add #'org-html-inline-src-block :override #'meq/org-html-inline-src-block)
#+end_src

Adapted from [[https://github.com/bzg/org-mode/blob/main/lisp/ox-html.el#L2676][here]]:

#+begin_src emacs-lisp
(defun meq/org-html-format-headline-default-function
    (todo _todo-type priority text tags info)
  "Default format function for a headline.
See `org-html-format-headline-function' for details."
  (let ((todo (org-html--todo todo info))
        (priority (org-html--priority priority info))
        (tags (org-html--tags tags info)))
    (concat todo (and todo " ")
            priority (and priority " ")
            text
            (and tags "&#xa0;") tags)))
(advice-add #'org-html-format-headline-default-function :override #'meq/org-html-format-headline-default-function)
#+end_src

** uuidgen.el

Taken from [[https://github.com/kanru/uuidgen-el/blob/master/uuidgen.el][here]]:

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; uuidgen.el --- Provides various UUID generating functions

;; Copyright (C) 2010, 2011, 2014, 2020, 2022 Kan-Ru Chen

;; Author: Kan-Ru Chen <kanru@kanru.info>
;; Created: 08 Nov 2010
;; Version: 1.2
;; Keywords: extensions, lisp, tools

;; This file is NOT part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; This is a naive implementation of RFC4122 Universally Unique
;; IDentifier generation in elisp.  Currently implemented are UUID v1
;; v3, v4 and v5 generation.  The resolution of the time based UUID is
;; microseconds, which is 10 times of the suggested 100-nanosecond
;; resolution, but should be enough for general usage.
;;
;; Get development version from git:
;;
;;     git clone git://github.com/kanru/uuidgen-el.git

;;; TODO:
;;
;; * Simplify implementation and interfaces.
;; * Unpack time-based UUID.

;;; Code:

(require 'calc-ext)
(require 'sha1)

(defgroup uuidgen nil
  "UUID generation."
  :group 'extensions
  :group 'tools)

(defcustom uuidgen-suppress-network-info-warnings nil
  "Non-nil means suppress warning messages for missing\
`network-interface-list' or `network-interface-info' support."
  :type 'boolean
  :group 'uuidgen)

(defcustom uuidgen-cid-format-string
  "{ 0x%02x%02x%02x%02x, 0x%02x%02x, 0x%02x%02x, { 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x } }"
  "Format string used to output CID string."
  :type 'string
  :group 'uuidgen)

(defcustom uuidgen-upcase nil
  "If non-nil upcase strings generated by interactive uuidgen."
  :type 'boolean
  :group 'uuidgen)

(defvar uuidgen-unix-epoch-delta (math-read-radix "1b21dd213814000" 16)
  "The interval between the UUID epoch and the Unix epoch.
That is the number of 100-nanoseconds between
1582-10-15 00:00:00 and 1970-01-01 00:00:00.")

(defcustom uuidgen-interface "eth0"
  "The default interface for time based UUID generation."
  :type 'string
  :group 'uuidgen)

;; Predefined namespace IDs
;; Ref: RFC4122 Appendix C

(defvar uuidgen-ns-dns "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
  "For UUID name string which is a fully-qualified domain name.")

(defvar uuidgen-ns-url "6ba7b811-9dad-11d1-80b4-00c04fd430c8"
  "For UUID name string which is a URL.")

(defvar uuidgen-ns-oid "6ba7b812-9dad-11d1-80b4-00c04fd430c8"
  "For UUID name string which is an ISO OID.")

(defvar uuidgen-ns-x500 "6ba7b814-9dad-11d1-80b4-00c04fd430c8"
  "For UUID name string which is an X.500 DN (in DER or a text output format).")

(defun uuidgen--string-to-octets (string &optional start)
  "Convert UUID string to a list of integers.
STRING should contain a UUID string, the 8-4-4-4-12 format is
preferred.  If START is not nil, start search form START
position."
  (if (string-match "[0-9a-f]\\{2\\}" string start)
      (cons (string-to-number (match-string 0 string) 16)
            (uuidgen--string-to-octets string (match-end 0)))))

(defun uuidgen--decode (id)
  "Convert UUID string to binary representation.
ID should contain a UUID string, the 8-4-4-4-12 format is
preferred."
  (apply (if (fboundp 'unibyte-string)
             'unibyte-string
           'string)
         (uuidgen--string-to-octets id)))

(defun uuidgen--fixnum (bignum)
  "Compatibility layer to convert a bignum to fixnum.
Emacs supports native bignum starting from version 27. For older
version will use calc for bignum calculation."
  (if (integerp bignum)
      bignum
    (if (fboundp 'math-fixnum)
        (math-fixnum bignum)
      (error "%s is not a supported number format" bignum))))

(defun uuidgen--current-unix-clock ()
  "Get the current Unix time as a 100-nanosecond intervals."
  (if (fboundp 'time-convert)
      (car (time-convert (current-time) 10000000))
    (let* ((unix-time (current-time))
           (high (nth 0 unix-time))
           (low (nth 1 unix-time))
           (micro (nth 2 unix-time)))
      (math-add
       (math-mul 10000000 (math-add (math-mul high #x10000) low))
       (* 10 micro)))))

(defun uuidgen--system-clock ()
  "Get the 100-nanosecond intervals after UUID epoch."
  (math-add (uuidgen--current-unix-clock) uuidgen-unix-epoch-delta))

(defun uuidgen--random-clock ()
  "Get a random generated 60 bit clock."
  (calcFunc-random (math-power-of-2 60)))

(defun uuidgen--format-time-low (clock)
  "Format the time_low part of the UUID.
CLOCK should be a integer less than 60 bits."
  (let ((time-low (uuidgen--fixnum (math-clip clock 32))))
    (format "%08x" time-low)))

(defun uuidgen--format-time-mid (clock)
  "Format the time_mid part of the UUID.
CLOCK should be a integer less than 60 bits."
  (let ((time-mid (uuidgen--fixnum
                   (math-clip
                    (car (math-idivmod clock (math-power-of-2 32))) 16))))
    (format "%04x" time-mid)))

(defun uuidgen--format-time-hi-version (clock &optional ver)
  "Format the time_hi_and_version part of the UUID.
CLOCK should be a integer less than 60 bits.
VER is the UUID variant number.  Valid VER are 1, 3, 4, 5."
  (let ((version (or ver 1))
        (time-hi (uuidgen--fixnum
                  (math-clip
                   (car (math-idivmod clock (math-power-of-2 48))) 12))))
    (format "%01x%03x" ver time-hi)))

(defun uuidgen--format-clock-seq-low (clock)
  "Format the clock_seq_low part of the UUID.
CLOCK should be a integer less than 60 bits."
  (format "%02x" (logand #xFF clock)))

(defun uuidgen--format-clock-seq-hi-reserved (clock)
  "Format the clock_seq_hi_and_reserved part of the UUID.
CLOCK should be a integer less than 60 bits."
  (format "%02x" (logior #x80 (logand #x3F (lsh clock -8)))))

(defun uuidgen--random-address ()
  "Return a address formed by list of random numbers."
  (mapcar (lambda (n) (random 256)) (make-list 6 0)))

(defun uuidgen--random-multicast-address ()
  "Return a random multicast address."
  (let ((addr (uuidgen--random-address)))
    ;; Set multicast bit. RFC4122#4.1.6
    (cons (logior #x10 (car addr))
          (cdr addr))))

(defun uuidgen--get-interface (interfaces &optional default)
  "Return the interface for UUID node information.
The INTERFACES is the same format of `network-interface-list' output.
If DEFAULT is not nil, check whether interface DEFAULT exists first."
  (if (and default (network-interface-info default))
      default
    (let ((ifname (caar interfaces)))
      (if (string= ifname "lo")
          (uuidgen--get-interface (cdr interfaces))
        ifname))))

(defun uuidgen--get-ieee-address ()
  "Return the IEEE address from `network-interface-info'.
The return value is a array consist of the address number.
If there is no interface available then return a random
multicast address list."
  ;; Some platform doesn't have network-interface-* so we have to
  ;; check this.
  (if (and (fboundp 'network-interface-list)
           (fboundp 'network-interface-info))
      (let ((info (network-interface-info
                   (uuidgen--get-interface
                    (network-interface-list) uuidgen-interface))))
        (if (and info
                 (nth 3 info))
            (cdr (nth 3 info))
          (progn
            (or uuidgen-suppress-network-info-warnings
                (display-warning
                 '(uuid network-interface-info)
                 "`network-interface-info' returned nil address.

This means either your NIC has no MAC address or the
`network-interface-info' implementation on your platform is buggy.

Will use random multicast address instead. Although this is suggested
by RFC4122, the result might not be desired.

You can customize `uuidgen-suppress-network-info-warnings' to
disable this warning or by adding the entry (uuid network-interface-info)
to the user option `warning-suppress-types', which is defined in the
`warnings' library.\n"))
            (uuidgen--random-multicast-address))))
    (progn
      (or uuidgen-suppress-network-info-warnings
          (display-warning
           'uuid
           "Missing `network-interface-info' or `network-interface-list' support.

Use random multicast address instead. Although this is suggested
by RFC4122, the result might not be desired.

You can customize `uuidgen-suppress-network-info-warnings' to
disable this warning or by adding the entry (uuid network-interface-info)
to the user option `warning-suppress-types', which is defined in the
`warnings' library.\n"))
      (uuidgen--random-multicast-address))))

(defun uuidgen--format-ieee-address ()
  "Format the IEEE address based node name of UUID."
  (let ((address (uuidgen--get-ieee-address)))
    (mapconcat (lambda (var) (format "%02x" var))
               address "")))

(defun uuidgen--format-random-address ()
  "Format the IEEE address based node name of UUID."
  (let ((address (uuidgen--random-address)))
    (mapconcat (lambda (var) (format "%02x" var))
               address "")))

(defun uuidgen--from-time (clock seq ver addr-function)
  "Generate UUID based on various value.
CLOCK should be a integer less than 60 bits.  SEQ should be a
integer less than 14 bits.  VER is the UUID variant number.
Valid VER are 1, 3, 4, 5.  ADDR-FUNCTION is a function generating
the node information.  Pre-defined ADDR-FUNCTION are
`uuidgen--format-ieee-address' and `uuidgen--format-random-address'."
  (mapconcat 'identity
             (list
              (uuidgen--format-time-low clock)
              (uuidgen--format-time-mid clock)
              (uuidgen--format-time-hi-version clock ver)
              (concat (uuidgen--format-clock-seq-hi-reserved seq)
                      (uuidgen--format-clock-seq-low seq))
              (funcall addr-function))
             "-"))

(defun uuidgen-1 ()
  "Generate time based UUID, aka UUIDv1."
  (let ((clock (uuidgen--system-clock))
        (seq (random)))
    (uuidgen--from-time clock seq 1 'uuidgen--format-ieee-address)))

(defun uuidgen-4 ()
  "Generate UUID form random numbers, aka UUIDv4."
  (let ((clock (uuidgen--random-clock))
        (seq (random)))
    (uuidgen--from-time clock seq 4 'uuidgen--format-random-address)))

(defun uuidgen-from-hash (hash ver)
  "Generate name based UUID form hash HASH and version VER."
  (mapconcat 'identity
             (list
              (substring hash 0 8)
              (substring hash 8 12)
              (concat (number-to-string ver)
                      (substring hash 13 16))
              (format "%04x"
                      (logior #x8000 (logand #x3FFF
                                             (string-to-number (substring hash 16 20) 16))))
              (substring hash 20 32))
             "-"))

(defun uuidgen-3 (ns name)
  "Generate name based UUID using MD5 hash algorithm, aka UUIDv3.
NS should be a generated UUID or predefined namespaces,
`uuidgen-ns-dns', `uuidgen-ns-url', `uuidgen-ns-oid', `uuidgen-ns-x500'.
NAME is the node name string."
  (let ((hash (md5 (concat (uuidgen--decode ns) (encode-coding-string name 'utf-8 t)))))
    (uuidgen-from-hash hash 3)))

(defun uuidgen-5 (ns name)
  "Generate name based UUID using SHA-1 hash algorithm, aka UUIDv5.
NS should be a generated UUID or predefined namespaces,
`uuidgen-ns-dns', `uuidgen-ns-url', `uuidgen-ns-oid', `uuidgen-ns-x500'.
NAME is the node name string."
  (let ((hash (sha1 (concat (uuidgen--decode ns) (encode-coding-string name 'utf-8 t)))))
    (uuidgen-from-hash hash 5)))

(defun uuidgen-urn (uuid)
  "Return the string representation of a UUID as a URN."
  (concat "urn:uuid:" uuid))

(defun uuidgen-cid (&optional uuid)
  "Return UUID string in CID format that is suitable for COM definition.
If UUID is nil will generate UUIDGEN-4 automatically.
You customize `uuidgen-cid-format-string' to change the default format."
  (let ((raw (uuidgen--string-to-octets (or uuid
                                         (uuidgen-4)))))
    (apply 'format uuidgen-cid-format-string raw)))

;;;###autoload
(defun insert-uuid-cid (uuid)
  "Insert UUID string in CID format that is suitable for COM definition.
If UUID is nil will generate UUIDGEN-4 automatically.
You customize `uuidgen-cid-format-string' to change the default format."
  (interactive (list (read-string "UUID: " (uuidgen-4))))
  (insert (uuidgen-cid uuid)))

;;;###autoload
(defun uuidgen (time-based)
  "Insert UUIDv4 at point. If TIME-BASED is non-nil, insert UUIDv1 instead."
  (interactive "P")
  (let ((uuid (if time-based (uuidgen-1)
                (uuidgen-4))))
    (insert (if uuidgen-upcase (upcase uuid)
              uuid))))

(provide 'uuidgen)
;;; uuidgen.el ends here
#+end_src

** a.el

Taken from [[https://github.com/plexus/a.el/blob/master/a.el][here]]:

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; a.el --- Associative data structure functions   -*- lexical-binding: t; -*-

;; Copyright (C) 2017-2021  Arne Brasseur

;; Author: Arne Brasseur <arne@arnebrasseur.net>
;; URL: https://github.com/plexus/a.el
;; Keywords: lisp
;; Version: 1.0.0
;; Package-Requires: ((emacs "25"))

;; This file is not part of GNU Emacs.

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.

;;; Commentary:

;; Library for dealing with associative data structures: alists, hash-maps, and
;; vectors (for vectors, the indices are treated as keys).
;;
;; This library is largely inspired by Clojure, it has many of the functions
;; found in clojure.core, prefixed with `a-'. All functions treat their
;; arguments as immutable, so e.g. `a-assoc' will clone the hash-table or alist
;; it is given. Keep this in mind when writing performance sensitive code.

;;; Code:

(eval-when-compile (require 'subr-x)) ;; for things like hash-table-keys

(require 'cl-lib)
(require 'seq)

(defun a-associative-p (obj)
  (or (not obj)
      (hash-table-p obj)
      (and (consp obj)
           (consp (car obj)))))

(defalias 'a-associative? 'a-associative-p)

(defun a-get (map key &optional not-found)
  "Return the value MAP mapped to KEY, NOT-FOUND or nil if key not present."
  (cond
   ;; own implementation instead of alist-get so keys are checked with equal
   ;; instead of eq
   ((listp map)
    (a--alist-get map key not-found))

   ((vectorp map)
    (if (a-has-key? map key)
        (aref map key)
      not-found))

   ((hash-table-p map)
    (gethash key map not-found))
   (t (user-error "Not associative: %S" map))))

(defun a--alist-get (map key &optional not-found)
  "Like alist-get, but uses equal instead of eq to look up in map MAP key KEY.
Returns NOT-FOUND if the key is not present, or `nil' if
NOT-FOUND is not specified."
  (cl-block nil
    (seq-doseq (pair map)
      (when (equal (car pair) key)
        (cl-return (cdr pair))))
    not-found))

(defun a-get-in (m ks &optional not-found)
  "Look up a value in a nested associative structure.

Given a data structure M, and a sequence of keys KS, find the
value found by using each key in turn to do a lookup in the next
\"layer\". Return `nil' if the key is not present, or the NOT-FOUND
value if supplied."
  (let ((result m))
    (cl-block nil
      (seq-doseq (k ks)
        (if (a-has-key? result k)
            (setq result (a-get result k))
          (cl-return not-found)))
      result)))

(defmacro a-get* (&rest keys)
  "Look up a value in a nested associative structure.

Like a-get-in, but takes the key sequence KEYS directly as vararg
arguments, rather than as a single sequence."
  (cl-labels ((rec (keys)
                   `(a-get ,(if (and (consp (cdr keys))
                                     (cddr keys))
                                (rec (cdr keys))
                              (cadr keys))
                           ,(car keys))))
    (rec (nreverse keys))))

(defun a-has-key (coll k)
  "Check if the given associative collection COLL has a certain key K."
  (cond
   ((listp coll)         (not (eq (a--alist-get coll k :not-found) :not-found)))
   ((vectorp coll)       (and (integerp k) (< -1 k (length coll))))
   ((hash-table-p coll)  (not (eq (gethash k coll :not-found) :not-found)))
   (t (user-error "Not associative: %S" coll))))

(defalias 'a-has-key? 'a-has-key)

(defun a-assoc-1 (coll k v)
  "Like `a-assoc', (in COLL assoc K with V) but only takes a single k-v pair.
Internal helper function."
  (cond
   ((listp coll)
    (if (a-has-key? coll k)
        (mapcar (lambda (entry)
                  (if (equal (car entry) k)
                      (cons k v)
                    entry))
                coll)
      (cons (cons k v) coll)))

   ((vectorp coll)
    (if (and (integerp k) (>= k 0))
        (if (< k (length coll))
            (let ((copy (copy-sequence coll)))
              (aset copy k v)
              copy)
          (vconcat coll (make-list (- k (length coll)) nil) (list v)))))

   ((hash-table-p coll)
    (let ((copy (copy-hash-table coll)))
      (puthash k v copy)
      copy))))

(defun a-assoc (coll &rest kvs)
  "Return an updated collection COLL, associating values with keys KVS."
  (when (not (cl-evenp (a-count kvs)))
    (user-error "a-assoc requires an even number of arguments!"))
  (seq-reduce (lambda (coll kv)
                  (seq-let [k v] kv
                    (a-assoc-1 coll k v)))
              (seq-partition kvs 2)
              coll))

(defun a-keys (coll)
  "Return the keys in the collection COLL."
  (cond
   ((listp coll)
    (mapcar #'car coll))

   ((hash-table-p coll)
    (hash-table-keys coll))))

(defun a-vals (coll)
  "Return the values in the collection COLL."
  (cond
   ((listp coll)
    (mapcar #'cdr coll))

   ((hash-table-p coll)
    (hash-table-values coll))))

(defun a-reduce-kv (fn from coll)
  "Reduce with FN starting from FROM the collection COLL.
Reduce an associative collection COLL, starting with an initial
value of FROM. The reducing function FN receives the intermediate
value, key, and value."
  (seq-reduce (lambda (acc key)
                  (funcall fn acc key (a-get coll key)))
              (a-keys coll)
              from))

(defun a-count (coll)
  "Count the number of key-value pairs in COLL.
Like length, but can also return the length of hash tables."
  (cond
   ((seqp coll)
    (length coll))

   ((hash-table-p coll)
    (hash-table-count coll))))

(defun a-equal (a b)
  "Compare collections A, B for value equality.

Associative collections (hash tables and a-lists) are considered
equal if they contain equal key-value pairs, regardless of order.

Sequences (lists or vectors) are considered equal if they contain
the same elements in the same order.

Collection elements are compared using `a-equal'. In other words,
the equality check is recursive, resulting in a \"deep\" equality
check.

Anything that isn't associative or a sequence is compared with
`equal'."
  (cond
   ((and (a-associative? a) (a-associative? b))
    (or (equal a b)
        (when (eq (a-count a) (a-count b))
          (cl-block nil
            (seq-doseq (k (a-keys a))
              (when (not (and
                          (a-has-key b k)
                          (a-equal (a-get a k) (a-get b k))))
                (cl-return nil)))
            (seq-doseq (k (a-keys b))
              (when (not (and
                          (a-has-key a k)
                          (a-equal (a-get a k) (a-get b k))))
                (cl-return nil)))
            t))))
   ((and (sequencep a) (sequencep b))
    (and (eq (length a) (length b))
         (or (and (seq-empty-p a) (seq-empty-p b))
             (and (a-equal (elt a 0) (elt b 0))
                  (a-equal (seq-drop a 1) (seq-drop b 1))))))
   (t
    (equal a b))))

(defalias 'a-equal? 'a-equal)

(defun a-merge (&rest colls)
  "Merge multiple associative collections.
Return the type of the first collection COLLS."
  (seq-reduce (lambda (this that)
                (a-reduce-kv (lambda (coll k v)
                               (a-assoc coll k v))
                             this
                             that))
              (cdr colls)
              (car colls)))

(defun a-merge-with (f &rest colls)
  "Merge multiple associative collections.
Return the type of the first collection COLLS. If a key exists in
both, then combine the associated values by calling f on them."
  (seq-reduce (lambda (this that)
                (a-reduce-kv (lambda (coll k v)
                               (a-assoc coll k (if (a-has-key coll k)
                                                   (funcall f v (a-get coll k))
                                                 v)))
                             this
                             that))
              (cdr colls)
              (car colls)))

(defun a-alist (&rest kvs)
  "Create an association list from the given keys and values KVS.
Arguments are simply provided in sequence, rather than as lists or cons cells.
For example: (a-alist :foo 123 :bar 456)"
  (mapcar (lambda (kv) (cons (car kv) (cadr kv))) (seq-partition kvs 2)))

(defalias 'a-list 'a-alist)

(defun a-hash-table (&rest kvs)
  "Create a hash table from the given keys and values KVS.
Arguments are simply provided in sequence, rather than as lists
or cons cells. As \"test\" for the hash table, equal is used. The
hash table is created without extra storage space, so with a size
equal to amount of key-value pairs, since it is assumed to be
treated as immutable.
For example: (a-hash-table :foo 123 :bar 456)"
  (let* ((kv-pairs (seq-partition kvs 2))
         (hash-map (make-hash-table :test 'equal :size (length kv-pairs))))
    (seq-do (lambda (pair)
              (puthash (car pair) (cadr pair) hash-map))
            kv-pairs)
    hash-map))

(defun a-assoc-in (coll keys value)
  "In collection COLL, at location KEYS, associate value VALUE.
Associates a value in a nested associative collection COLL, where
KEYS is a sequence of keys and VALUE is the new value and returns
a new nested structure. If any levels do not exist, association
lists will be created."
  (cl-case (length keys)
    (0 coll)
    (1 (a-assoc-1 coll (elt keys 0) value))
    (t (a-assoc-1 coll
                  (elt keys 0)
                  (a-assoc-in (a-get coll (elt keys 0))
                              (seq-drop keys 1)
                              value)))))

(defun a-dissoc--list (list keys)
  "Return updated LIST with KEYS removed.
Internal helper. Use `a-dissoc' instead."
  (a-reduce-kv (lambda (res k v)
                 (if (member k keys)
                     res
                   (cons (cons k v) res)))
               nil
               list))

(defun a-dissoc--hash-table (table keys)
  "Return updated TABLE with KEYS removed.
Internal helper. Use `a-dissoc' instead."
  (let ((new-table (make-hash-table :size (hash-table-count table)
                                    :test (hash-table-test table)))
        (rest-keys (seq-remove (lambda (k)
                                 (member k keys))
                               (a-keys table))))
    (seq-doseq (k rest-keys)
      (puthash k (gethash k table) new-table))
    new-table))

(defun a-dissoc (coll &rest keys)
  "Return an updated version of collection COLL with the KEY removed."
  (cond
   ((listp coll) (a-dissoc--list coll keys))
   ((hash-table-p coll) (a-dissoc--hash-table coll keys))))

(defun a-update (coll key fn &rest args)
  "In collection COLL, at location KEY, apply FN with extra args ARGS.
'Updates' a value in an associative collection COLL, where KEY is
a key and FN is a function that will take the old value and any
supplied args and return the new value, and returns a new
structure. If the key does not exist, nil is passed as the old
value."
  (a-assoc-1 coll
             key
             (apply #'funcall fn (a-get coll key) args)))

(defun a-update-in (coll keys fn &rest args)
  "In collection COLL, at location KEYS, apply FN with extra args ARGS.
'Updates' a value in a nested associative collection COLL, where
KEYS is a sequence of keys and FN is a function that will take
the old value and any supplied ARGS and return the new value, and
returns a new nested structure. If any levels do not exist,
association lists will be created."
  (cl-case (length keys)
    (0 coll)
    (1 (apply #'a-update coll (elt keys 0) fn args))
    (t (a-assoc-1 coll
                  (elt keys 0)
                  (apply #'a-update-in
                         (a-get coll (elt keys 0))
                         (seq-drop keys 1)
                         fn
                         args)))))

(provide 'a)

;;; a.el ends here
#+end_src

** dash.el

Taken from [[https://github.com/magnars/dash.el/blob/master/dash.el][here]]:

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; dash.el --- A modern list library for Emacs  -*- lexical-binding: t -*-

;; Copyright (C) 2012-2021 Free Software Foundation, Inc.

;; Author: Magnar Sveen <magnars@gmail.com>
;; Version: 2.19.1
;; Package-Requires: ((emacs "24"))
;; Keywords: extensions, lisp
;; Homepage: https://github.com/magnars/dash.el

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; A modern list API for Emacs.
;;
;; See its overview at https://github.com/magnars/dash.el#functions.

;;; Code:

(eval-when-compile
  ;; TODO: Emacs 24.3 first introduced `gv', so remove this and all
  ;; calls to `defsetf' when support for earlier versions is dropped.
  (unless (fboundp 'gv-define-setter)
    (require 'cl))

  ;; TODO: Emacs versions 24.3..24.5 complain about unknown `declare'
  ;; props, so remove this when support for those versions is dropped.
  (and (< emacs-major-version 25)
       (boundp 'defun-declarations-alist)
       (dolist (prop '(pure side-effect-free))
         (unless (assq prop defun-declarations-alist)
           (push (list prop #'ignore) defun-declarations-alist)))))

(defgroup dash ()
  "Customize group for Dash, a modern list library."
  :group 'extensions
  :group 'lisp
  :prefix "dash-")

(defmacro !cons (car cdr)
  "Destructive: Set CDR to the cons of CAR and CDR."
  (declare (debug (form symbolp)))
  `(setq ,cdr (cons ,car ,cdr)))

(defmacro !cdr (list)
  "Destructive: Set LIST to the cdr of LIST."
  (declare (debug (symbolp)))
  `(setq ,list (cdr ,list)))

(defmacro --each (list &rest body)
  "Evaluate BODY for each element of LIST and return nil.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating BODY.
This is the anaphoric counterpart to `-each'."
  (declare (debug (form body)) (indent 1))
  (let ((l (make-symbol "list"))
        (i (make-symbol "i")))
    `(let ((,l ,list)
           (,i 0))
       (while ,l
         (let ((it (pop ,l)) (it-index ,i))
           (ignore it it-index)
           ,@body)
         (setq ,i (1+ ,i))))))

(defun -each (list fn)
  "Call FN on each element of LIST.
Return nil; this function is intended for side effects.

Its anaphoric counterpart is `--each'.

For access to the current element's index in LIST, see
`-each-indexed'."
  (declare (indent 1))
  (ignore (mapc fn list)))

(defalias '--each-indexed '--each)

(defun -each-indexed (list fn)
  "Call FN on each index and element of LIST.
For each ITEM at INDEX in LIST, call (funcall FN INDEX ITEM).
Return nil; this function is intended for side effects.

See also: `-map-indexed'."
  (declare (indent 1))
  (--each list (funcall fn it-index it)))

(defmacro --each-while (list pred &rest body)
  "Evaluate BODY for each item in LIST, while PRED evaluates to non-nil.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating PRED or BODY.  Once
an element is reached for which PRED evaluates to nil, no further
BODY is evaluated.  The return value is always nil.
This is the anaphoric counterpart to `-each-while'."
  (declare (debug (form form body)) (indent 2))
  (let ((l (make-symbol "list"))
        (i (make-symbol "i"))
        (elt (make-symbol "elt")))
    `(let ((,l ,list)
           (,i 0)
           ,elt)
       (while (when ,l
                (setq ,elt (car-safe ,l))
                (let ((it ,elt) (it-index ,i))
                  (ignore it it-index)
                  ,pred))
         (let ((it ,elt) (it-index ,i))
           (ignore it it-index)
           ,@body)
         (setq ,i (1+ ,i) ,l (cdr ,l))))))

(defun -each-while (list pred fn)
  "Call FN on each ITEM in LIST, while (PRED ITEM) is non-nil.
Once an ITEM is reached for which PRED returns nil, FN is no
longer called.  Return nil; this function is intended for side
effects.

Its anaphoric counterpart is `--each-while'."
  (declare (indent 2))
  (--each-while list (funcall pred it) (funcall fn it)))

(defmacro --each-r (list &rest body)
  "Evaluate BODY for each element of LIST in reversed order.
Each element of LIST in turn, starting at its end, is bound to
`it' and its index within LIST to `it-index' before evaluating
BODY.  The return value is always nil.
This is the anaphoric counterpart to `-each-r'."
  (declare (debug (form body)) (indent 1))
  (let ((v (make-symbol "vector"))
        (i (make-symbol "i")))
    ;; Implementation note: building a vector is considerably faster
    ;; than building a reversed list (vector takes less memory, so
    ;; there is less GC), plus `length' comes naturally.  In-place
    ;; `nreverse' would be faster still, but BODY would be able to see
    ;; that, even if the modification was undone before we return.
    `(let* ((,v (vconcat ,list))
            (,i (length ,v))
            it it-index)
       (ignore it it-index)
       (while (> ,i 0)
         (setq ,i (1- ,i) it-index ,i it (aref ,v ,i))
         ,@body))))

(defun -each-r (list fn)
  "Call FN on each element of LIST in reversed order.
Return nil; this function is intended for side effects.

Its anaphoric counterpart is `--each-r'."
  (--each-r list (funcall fn it)))

(defmacro --each-r-while (list pred &rest body)
  "Eval BODY for each item in reversed LIST, while PRED evals to non-nil.
Each element of LIST in turn, starting at its end, is bound to
`it' and its index within LIST to `it-index' before evaluating
PRED or BODY.  Once an element is reached for which PRED
evaluates to nil, no further BODY is evaluated.  The return value
is always nil.
This is the anaphoric counterpart to `-each-r-while'."
  (declare (debug (form form body)) (indent 2))
  (let ((v (make-symbol "vector"))
        (i (make-symbol "i"))
        (elt (make-symbol "elt")))
    `(let* ((,v (vconcat ,list))
            (,i (length ,v))
            ,elt it it-index)
       (ignore it it-index)
       (while (when (> ,i 0)
                (setq ,i (1- ,i) it-index ,i)
                (setq ,elt (aref ,v ,i) it ,elt)
                ,pred)
         (setq it-index ,i it ,elt)
         ,@body))))

(defun -each-r-while (list pred fn)
  "Call FN on each ITEM in reversed LIST, while (PRED ITEM) is non-nil.
Once an ITEM is reached for which PRED returns nil, FN is no
longer called.  Return nil; this function is intended for side
effects.

Its anaphoric counterpart is `--each-r-while'."
  (--each-r-while list (funcall pred it) (funcall fn it)))

(defmacro --dotimes (num &rest body)
  "Evaluate BODY NUM times, presumably for side effects.
BODY is evaluated with the local variable `it' temporarily bound
to successive integers running from 0, inclusive, to NUM,
exclusive.  BODY is not evaluated if NUM is less than 1.
This is the anaphoric counterpart to `-dotimes'."
  (declare (debug (form body)) (indent 1))
  (let ((n (make-symbol "num"))
        (i (make-symbol "i")))
    `(let ((,n ,num)
           (,i 0)
           it)
       (ignore it)
       (while (< ,i ,n)
         (setq it ,i ,i (1+ ,i))
         ,@body))))

(defun -dotimes (num fn)
  "Call FN NUM times, presumably for side effects.
FN is called with a single argument on successive integers
running from 0, inclusive, to NUM, exclusive.  FN is not called
if NUM is less than 1.

This function's anaphoric counterpart is `--dotimes'."
  (declare (indent 1))
  (--dotimes num (funcall fn it)))

(defun -map (fn list)
  "Apply FN to each item in LIST and return the list of results.

This function's anaphoric counterpart is `--map'."
  (mapcar fn list))

(defmacro --map (form list)
  "Eval FORM for each item in LIST and return the list of results.
Each element of LIST in turn is bound to `it' before evaluating
FORM.
This is the anaphoric counterpart to `-map'."
  (declare (debug (def-form form)))
  `(mapcar (lambda (it) (ignore it) ,form) ,list))

(defmacro --reduce-from (form init list)
  "Accumulate a value by evaluating FORM across LIST.
This macro is like `--each' (which see), but it additionally
provides an accumulator variable `acc' which it successively
binds to the result of evaluating FORM for the current LIST
element before processing the next element.  For the first
element, `acc' is initialized with the result of evaluating INIT.
The return value is the resulting value of `acc'.  If LIST is
empty, FORM is not evaluated, and the return value is the result
of INIT.
This is the anaphoric counterpart to `-reduce-from'."
  (declare (debug (form form form)))
  `(let ((acc ,init))
     (--each ,list (setq acc ,form))
     acc))

(defun -reduce-from (fn init list)
  "Reduce the function FN across LIST, starting with INIT.
Return the result of applying FN to INIT and the first element of
LIST, then applying FN to that result and the second element,
etc.  If LIST is empty, return INIT without calling FN.

This function's anaphoric counterpart is `--reduce-from'.

For other folds, see also `-reduce' and `-reduce-r'."
  (--reduce-from (funcall fn acc it) init list))

(defmacro --reduce (form list)
  "Accumulate a value by evaluating FORM across LIST.
This macro is like `--reduce-from' (which see), except the first
element of LIST is taken as INIT.  Thus if LIST contains a single
item, it is returned without evaluating FORM.  If LIST is empty,
FORM is evaluated with `it' and `acc' bound to nil.
This is the anaphoric counterpart to `-reduce'."
  (declare (debug (form form)))
  (let ((lv (make-symbol "list-value")))
    `(let ((,lv ,list))
       (if ,lv
           (--reduce-from ,form (car ,lv) (cdr ,lv))
         ;; Explicit nil binding pacifies lexical "variable left uninitialized"
         ;; warning.  See issue #377 and upstream https://bugs.gnu.org/47080.
         (let ((acc nil) (it nil))
           (ignore acc it)
           ,form)))))

(defun -reduce (fn list)
  "Reduce the function FN across LIST.
Return the result of applying FN to the first two elements of
LIST, then applying FN to that result and the third element, etc.
If LIST contains a single element, return it without calling FN.
If LIST is empty, return the result of calling FN with no
arguments.

This function's anaphoric counterpart is `--reduce'.

For other folds, see also `-reduce-from' and `-reduce-r'."
  (if list
      (-reduce-from fn (car list) (cdr list))
    (funcall fn)))

(defmacro --reduce-r-from (form init list)
  "Accumulate a value by evaluating FORM across LIST in reverse.
This macro is like `--reduce-from', except it starts from the end
of LIST.
This is the anaphoric counterpart to `-reduce-r-from'."
  (declare (debug (form form form)))
  `(let ((acc ,init))
     (--each-r ,list (setq acc ,form))
     acc))

(defun -reduce-r-from (fn init list)
  "Reduce the function FN across LIST in reverse, starting with INIT.
Return the result of applying FN to the last element of LIST and
INIT, then applying FN to the second-to-last element and the
previous result of FN, etc.  That is, the first argument of FN is
the current element, and its second argument the accumulated
value.  If LIST is empty, return INIT without calling FN.

This function is like `-reduce-from' but the operation associates
from the right rather than left.  In other words, it starts from
the end of LIST and flips the arguments to FN.  Conceptually, it
is like replacing the conses in LIST with applications of FN, and
its last link with INIT, and evaluating the resulting expression.

This function's anaphoric counterpart is `--reduce-r-from'.

For other folds, see also `-reduce-r' and `-reduce'."
  (--reduce-r-from (funcall fn it acc) init list))

(defmacro --reduce-r (form list)
  "Accumulate a value by evaluating FORM across LIST in reverse order.
This macro is like `--reduce', except it starts from the end of
LIST.
This is the anaphoric counterpart to `-reduce-r'."
  (declare (debug (form form)))
  `(--reduce ,form (reverse ,list)))

(defun -reduce-r (fn list)
  "Reduce the function FN across LIST in reverse.
Return the result of applying FN to the last two elements of
LIST, then applying FN to the third-to-last element and the
previous result of FN, etc.  That is, the first argument of FN is
the current element, and its second argument the accumulated
value.  If LIST contains a single element, return it without
calling FN.  If LIST is empty, return the result of calling FN
with no arguments.

This function is like `-reduce' but the operation associates from
the right rather than left.  In other words, it starts from the
end of LIST and flips the arguments to FN.  Conceptually, it is
like replacing the conses in LIST with applications of FN,
ignoring its last link, and evaluating the resulting expression.

This function's anaphoric counterpart is `--reduce-r'.

For other folds, see also `-reduce-r-from' and `-reduce'."
  (if list
      (--reduce-r (funcall fn it acc) list)
    (funcall fn)))

(defmacro --reductions-from (form init list)
  "Return a list of FORM's intermediate reductions across LIST.
That is, a list of the intermediate values of the accumulator
when `--reduce-from' (which see) is called with the same
arguments.
This is the anaphoric counterpart to `-reductions-from'."
  (declare (debug (form form form)))
  `(nreverse
    (--reduce-from (cons (let ((acc (car acc))) (ignore acc) ,form) acc)
                   (list ,init)
                   ,list)))

(defun -reductions-from (fn init list)
  "Return a list of FN's intermediate reductions across LIST.
That is, a list of the intermediate values of the accumulator
when `-reduce-from' (which see) is called with the same
arguments.

This function's anaphoric counterpart is `--reductions-from'.

For other folds, see also `-reductions' and `-reductions-r'."
  (--reductions-from (funcall fn acc it) init list))

(defmacro --reductions (form list)
  "Return a list of FORM's intermediate reductions across LIST.
That is, a list of the intermediate values of the accumulator
when `--reduce' (which see) is called with the same arguments.
This is the anaphoric counterpart to `-reductions'."
  (declare (debug (form form)))
  (let ((lv (make-symbol "list-value")))
    `(let ((,lv ,list))
       (if ,lv
           (--reductions-from ,form (car ,lv) (cdr ,lv))
         ;; Explicit nil binding pacifies lexical "variable left uninitialized"
         ;; warning.  See issue #377 and upstream https://bugs.gnu.org/47080.
         (let ((acc nil) (it nil))
           (ignore acc it)
           (list ,form))))))

(defun -reductions (fn list)
  "Return a list of FN's intermediate reductions across LIST.
That is, a list of the intermediate values of the accumulator
when `-reduce' (which see) is called with the same arguments.

This function's anaphoric counterpart is `--reductions'.

For other folds, see also `-reductions' and `-reductions-r'."
  (if list
      (--reductions-from (funcall fn acc it) (car list) (cdr list))
    (list (funcall fn))))

(defmacro --reductions-r-from (form init list)
  "Return a list of FORM's intermediate reductions across reversed LIST.
That is, a list of the intermediate values of the accumulator
when `--reduce-r-from' (which see) is called with the same
arguments.
This is the anaphoric counterpart to `-reductions-r-from'."
  (declare (debug (form form form)))
  `(--reduce-r-from (cons (let ((acc (car acc))) (ignore acc) ,form) acc)
                    (list ,init)
                    ,list))

(defun -reductions-r-from (fn init list)
  "Return a list of FN's intermediate reductions across reversed LIST.
That is, a list of the intermediate values of the accumulator
when `-reduce-r-from' (which see) is called with the same
arguments.

This function's anaphoric counterpart is `--reductions-r-from'.

For other folds, see also `-reductions' and `-reductions-r'."
  (--reductions-r-from (funcall fn it acc) init list))

(defmacro --reductions-r (form list)
  "Return a list of FORM's intermediate reductions across reversed LIST.
That is, a list of the intermediate values of the accumulator
when `--reduce-re' (which see) is called with the same arguments.
This is the anaphoric counterpart to `-reductions-r'."
  (declare (debug (form list)))
  (let ((lv (make-symbol "list-value")))
    `(let ((,lv (reverse ,list)))
       (if ,lv
           (--reduce-from (cons (let ((acc (car acc))) (ignore acc) ,form) acc)
                          (list (car ,lv))
                          (cdr ,lv))
         ;; Explicit nil binding pacifies lexical "variable left uninitialized"
         ;; warning.  See issue #377 and upstream https://bugs.gnu.org/47080.
         (let ((acc nil) (it nil))
           (ignore acc it)
           (list ,form))))))

(defun -reductions-r (fn list)
  "Return a list of FN's intermediate reductions across reversed LIST.
That is, a list of the intermediate values of the accumulator
when `-reduce-r' (which see) is called with the same arguments.

This function's anaphoric counterpart is `--reductions-r'.

For other folds, see also `-reductions-r-from' and
`-reductions'."
  (if list
      (--reductions-r (funcall fn it acc) list)
    (list (funcall fn))))

(defmacro --filter (form list)
  "Return a new list of the items in LIST for which FORM evals to non-nil.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.
This is the anaphoric counterpart to `-filter'.
For the opposite operation, see also `--remove'."
  (declare (debug (form form)))
  (let ((r (make-symbol "result")))
    `(let (,r)
       (--each ,list (when ,form (push it ,r)))
       (nreverse ,r))))

(defun -filter (pred list)
  "Return a new list of the items in LIST for which PRED returns non-nil.

Alias: `-select'.

This function's anaphoric counterpart is `--filter'.

For similar operations, see also `-keep' and `-remove'."
  (--filter (funcall pred it) list))

(defalias '-select '-filter)
(defalias '--select '--filter)

(defmacro --remove (form list)
  "Return a new list of the items in LIST for which FORM evals to nil.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.
This is the anaphoric counterpart to `-remove'.
For the opposite operation, see also `--filter'."
  (declare (debug (form form)))
  `(--filter (not ,form) ,list))

(defun -remove (pred list)
  "Return a new list of the items in LIST for which PRED returns nil.

Alias: `-reject'.

This function's anaphoric counterpart is `--remove'.

For similar operations, see also `-keep' and `-filter'."
  (--remove (funcall pred it) list))

(defalias '-reject '-remove)
(defalias '--reject '--remove)

(defmacro --remove-first (form list)
  "Remove the first item from LIST for which FORM evals to non-nil.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.  This is a
non-destructive operation, but only the front of LIST leading up
to the removed item is a copy; the rest is LIST's original tail.
If no item is removed, then the result is a complete copy.
This is the anaphoric counterpart to `-remove-first'."
  (declare (debug (form form)))
  (let ((front (make-symbol "front"))
        (tail (make-symbol "tail")))
    `(let ((,tail ,list) ,front)
       (--each-while ,tail (not ,form)
         (push (pop ,tail) ,front))
       (if ,tail
           (nconc (nreverse ,front) (cdr ,tail))
         (nreverse ,front)))))

(defun -remove-first (pred list)
  "Remove the first item from LIST for which PRED returns non-nil.
This is a non-destructive operation, but only the front of LIST
leading up to the removed item is a copy; the rest is LIST's
original tail.  If no item is removed, then the result is a
complete copy.

Alias: `-reject-first'.

This function's anaphoric counterpart is `--remove-first'.

See also `-map-first', `-remove-item', and `-remove-last'."
  (--remove-first (funcall pred it) list))

(defalias '-reject-first '-remove-first)
(defalias '--reject-first '--remove-first)

(defmacro --remove-last (form list)
  "Remove the last item from LIST for which FORM evals to non-nil.
Each element of LIST in turn is bound to `it' before evaluating
FORM.  The result is a copy of LIST regardless of whether an
element is removed.
This is the anaphoric counterpart to `-remove-last'."
  (declare (debug (form form)))
  `(nreverse (--remove-first ,form (reverse ,list))))

(defun -remove-last (pred list)
  "Remove the last item from LIST for which PRED returns non-nil.
The result is a copy of LIST regardless of whether an element is
removed.

Alias: `-reject-last'.

This function's anaphoric counterpart is `--remove-last'.

See also `-map-last', `-remove-item', and `-remove-first'."
  (--remove-last (funcall pred it) list))

(defalias '-reject-last '-remove-last)
(defalias '--reject-last '--remove-last)

(defalias '-remove-item #'remove
  "Return a copy of LIST with all occurrences of ITEM removed.
The comparison is done with `equal'.
\n(fn ITEM LIST)")

(defmacro --keep (form list)
  "Eval FORM for each item in LIST and return the non-nil results.
Like `--filter', but returns the non-nil results of FORM instead
of the corresponding elements of LIST.  Each element of LIST in
turn is bound to `it' and its index within LIST to `it-index'
before evaluating FORM.
This is the anaphoric counterpart to `-keep'."
  (declare (debug (form form)))
  (let ((r (make-symbol "result"))
        (m (make-symbol "mapped")))
    `(let (,r)
       (--each ,list (let ((,m ,form)) (when ,m (push ,m ,r))))
       (nreverse ,r))))

(defun -keep (fn list)
  "Return a new list of the non-nil results of applying FN to each item in LIST.
Like `-filter', but returns the non-nil results of FN instead of
the corresponding elements of LIST.

Its anaphoric counterpart is `--keep'."
  (--keep (funcall fn it) list))

(defun -non-nil (list)
  "Return a copy of LIST with all nil items removed."
  (declare (pure t) (side-effect-free t))
  (--filter it list))

(defmacro --map-indexed (form list)
  "Eval FORM for each item in LIST and return the list of results.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.  This is like
`--map', but additionally makes `it-index' available to FORM.

This is the anaphoric counterpart to `-map-indexed'."
  (declare (debug (form form)))
  (let ((r (make-symbol "result")))
    `(let (,r)
       (--each ,list
         (push ,form ,r))
       (nreverse ,r))))

(defun -map-indexed (fn list)
  "Apply FN to each index and item in LIST and return the list of results.
This is like `-map', but FN takes two arguments: the index of the
current element within LIST, and the element itself.

This function's anaphoric counterpart is `--map-indexed'.

For a side-effecting variant, see also `-each-indexed'."
  (--map-indexed (funcall fn it-index it) list))

(defmacro --map-when (pred rep list)
  "Anaphoric form of `-map-when'."
  (declare (debug (form form form)))
  (let ((r (make-symbol "result")))
    `(let (,r)
       (--each ,list (!cons (if ,pred ,rep it) ,r))
       (nreverse ,r))))

(defun -map-when (pred rep list)
  "Use PRED to conditionally apply REP to each item in LIST.
Return a copy of LIST where the items for which PRED returns nil
are unchanged, and the rest are mapped through the REP function.

Alias: `-replace-where'

See also: `-update-at'"
  (--map-when (funcall pred it) (funcall rep it) list))

(defalias '-replace-where '-map-when)
(defalias '--replace-where '--map-when)

(defun -map-first (pred rep list)
  "Use PRED to determine the first item in LIST to call REP on.
Return a copy of LIST where the first item for which PRED returns
non-nil is replaced with the result of calling REP on that item.

See also: `-map-when', `-replace-first'"
  (let (front)
    (while (and list (not (funcall pred (car list))))
      (push (car list) front)
      (!cdr list))
    (if list
        (-concat (nreverse front) (cons (funcall rep (car list)) (cdr list)))
      (nreverse front))))

(defmacro --map-first (pred rep list)
  "Anaphoric form of `-map-first'."
  (declare (debug (def-form def-form form)))
  `(-map-first (lambda (it) (ignore it) ,pred)
               (lambda (it) (ignore it) ,rep)
               ,list))

(defun -map-last (pred rep list)
  "Use PRED to determine the last item in LIST to call REP on.
Return a copy of LIST where the last item for which PRED returns
non-nil is replaced with the result of calling REP on that item.

See also: `-map-when', `-replace-last'"
  (nreverse (-map-first pred rep (reverse list))))

(defmacro --map-last (pred rep list)
  "Anaphoric form of `-map-last'."
  (declare (debug (def-form def-form form)))
  `(-map-last (lambda (it) (ignore it) ,pred)
              (lambda (it) (ignore it) ,rep)
              ,list))

(defun -replace (old new list)
  "Replace all OLD items in LIST with NEW.

Elements are compared using `equal'.

See also: `-replace-at'"
  (declare (pure t) (side-effect-free t))
  (--map-when (equal it old) new list))

(defun -replace-first (old new list)
  "Replace the first occurrence of OLD with NEW in LIST.

Elements are compared using `equal'.

See also: `-map-first'"
  (declare (pure t) (side-effect-free t))
  (--map-first (equal old it) new list))

(defun -replace-last (old new list)
  "Replace the last occurrence of OLD with NEW in LIST.

Elements are compared using `equal'.

See also: `-map-last'"
  (declare (pure t) (side-effect-free t))
  (--map-last (equal old it) new list))

(defmacro --mapcat (form list)
  "Anaphoric form of `-mapcat'."
  (declare (debug (form form)))
  `(apply 'append (--map ,form ,list)))

(defun -mapcat (fn list)
  "Return the concatenation of the result of mapping FN over LIST.
Thus function FN should return a list."
  (--mapcat (funcall fn it) list))

(defmacro --iterate (form init n)
  "Anaphoric version of `-iterate'."
  (declare (debug (form form form)))
  (let ((res (make-symbol "result"))
        (len (make-symbol "n")))
    `(let ((,len ,n))
       (when (> ,len 0)
         (let* ((it ,init)
                (,res (list it)))
           (dotimes (_ (1- ,len))
             (push (setq it ,form) ,res))
           (nreverse ,res))))))

(defun -iterate (fun init n)
  "Return a list of iterated applications of FUN to INIT.

This means a list of the form:

  (INIT (FUN INIT) (FUN (FUN INIT)) ...)

N is the length of the returned list."
  (--iterate (funcall fun it) init n))

(defun -flatten (l)
  "Take a nested list L and return its contents as a single, flat list.

Note that because nil represents a list of zero elements (an
empty list), any mention of nil in L will disappear after
flattening.  If you need to preserve nils, consider `-flatten-n'
or map them to some unique symbol and then map them back.

Conses of two atoms are considered \"terminals\", that is, they
aren't flattened further.

See also: `-flatten-n'"
  (declare (pure t) (side-effect-free t))
  (if (and (listp l) (listp (cdr l)))
      (-mapcat '-flatten l)
    (list l)))

(defun -flatten-n (num list)
  "Flatten NUM levels of a nested LIST.

See also: `-flatten'"
  (declare (pure t) (side-effect-free t))
  (dotimes (_ num)
    (setq list (apply #'append (mapcar #'-list list))))
  list)

(defalias '-concat #'append)

(defalias '-copy 'copy-sequence
  "Create a shallow copy of LIST.

\(fn LIST)")

(defmacro --splice (pred form list)
  "Splice lists generated by FORM in place of items satisfying PRED in LIST.

Evaluate PRED for each element of LIST in turn bound to `it'.
Whenever the result of PRED is nil, leave that `it' is-is.
Otherwise, evaluate FORM with the same `it' binding still in
place.  The result should be a (possibly empty) list of items to
splice in place of `it' in LIST.

This can be useful as an alternative to the `,@' construct in a
`\\=`' structure, in case you need to splice several lists at
marked positions (for example with keywords).

This is the anaphoric counterpart to `-splice'."
  (declare (debug (form form form)))
  (let ((r (make-symbol "result")))
    `(let (,r)
       (--each ,list
         (if ,pred
             (--each ,form (push it ,r))
           (push it ,r)))
       (nreverse ,r))))

(defun -splice (pred fun list)
  "Splice lists generated by FUN in place of items satisfying PRED in LIST.

Call PRED on each element of LIST.  Whenever the result of PRED
is nil, leave that `it' as-is.  Otherwise, call FUN on the same
`it' that satisfied PRED.  The result should be a (possibly
empty) list of items to splice in place of `it' in LIST.

This can be useful as an alternative to the `,@' construct in a
`\\=`' structure, in case you need to splice several lists at
marked positions (for example with keywords).

This function's anaphoric counterpart is `--splice'.

See also: `-splice-list', `-insert-at'."
  (--splice (funcall pred it) (funcall fun it) list))

(defun -splice-list (pred new-list list)
  "Splice NEW-LIST in place of elements matching PRED in LIST.

See also: `-splice', `-insert-at'"
  (-splice pred (lambda (_) new-list) list))

(defmacro --splice-list (pred new-list list)
  "Anaphoric form of `-splice-list'."
  (declare (debug (def-form form form)))
  `(-splice-list (lambda (it) (ignore it) ,pred) ,new-list ,list))

(defun -cons* (&rest args)
  "Make a new list from the elements of ARGS.
The last 2 elements of ARGS are used as the final cons of the
result, so if the final element of ARGS is not a list, the result
is a dotted list.  With no ARGS, return nil."
  (declare (pure t) (side-effect-free t))
  (let* ((len (length args))
         (tail (nthcdr (- len 2) args))
         (last (cdr tail)))
    (if (null last)
        (car args)
      (setcdr tail (car last))
      args)))

(defun -snoc (list elem &rest elements)
  "Append ELEM to the end of the list.

This is like `cons', but operates on the end of list.

If any ELEMENTS are given, append them to the list as well."
  (-concat list (list elem) elements))

(defmacro --first (form list)
  "Return the first item in LIST for which FORM evals to non-nil.
Return nil if no such element is found.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.
This is the anaphoric counterpart to `-first'."
  (declare (debug (form form)))
  (let ((n (make-symbol "needle")))
    `(let (,n)
       (--each-while ,list (or (not ,form)
                               (ignore (setq ,n it))))
       ,n)))

(defun -first (pred list)
  "Return the first item in LIST for which PRED returns non-nil.
Return nil if no such element is found.

To get the first item in the list no questions asked,
use `-first-item'.

Alias: `-find'.

This function's anaphoric counterpart is `--first'."
  (--first (funcall pred it) list))

(defalias '-find #'-first)
(defalias '--find '--first)

(defmacro --some (form list)
  "Return non-nil if FORM evals to non-nil for at least one item in LIST.
If so, return the first such result of FORM.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.
This is the anaphoric counterpart to `-some'."
  (declare (debug (form form)))
  (let ((n (make-symbol "needle")))
    `(let (,n)
       (--each-while ,list (not (setq ,n ,form)))
       ,n)))

(defun -some (pred list)
  "Return (PRED x) for the first LIST item where (PRED x) is non-nil, else nil.

Alias: `-any'.

This function's anaphoric counterpart is `--some'."
  (--some (funcall pred it) list))

(defalias '-any '-some)
(defalias '--any '--some)

(defmacro --every (form list)
  "Return non-nil if FORM evals to non-nil for all items in LIST.
If so, return the last such result of FORM.  Otherwise, once an
item is reached for which FORM yields nil, return nil without
evaluating FORM for any further LIST elements.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.

This macro is like `--every-p', but on success returns the last
non-nil result of FORM instead of just t.

This is the anaphoric counterpart to `-every'."
  (declare (debug (form form)))
  (let ((a (make-symbol "all")))
    `(let ((,a t))
       (--each-while ,list (setq ,a ,form))
       ,a)))

(defun -every (pred list)
  "Return non-nil if PRED returns non-nil for all items in LIST.
If so, return the last such result of PRED.  Otherwise, once an
item is reached for which PRED returns nil, return nil without
calling PRED on any further LIST elements.

This function is like `-every-p', but on success returns the last
non-nil result of PRED instead of just t.

This function's anaphoric counterpart is `--every'."
  (--every (funcall pred it) list))

(defmacro --last (form list)
  "Anaphoric form of `-last'."
  (declare (debug (form form)))
  (let ((n (make-symbol "needle")))
    `(let (,n)
       (--each ,list
         (when ,form (setq ,n it)))
       ,n)))

(defun -last (pred list)
  "Return the last x in LIST where (PRED x) is non-nil, else nil."
  (--last (funcall pred it) list))

(defalias '-first-item #'car
  "Return the first item of LIST, or nil on an empty list.

See also: `-second-item', `-last-item', etc.

\(fn LIST)")

;; Ensure that calls to `-first-item' are compiled to a single opcode,
;; just like `car'.
(put '-first-item 'byte-opcode 'byte-car)
(put '-first-item 'byte-compile 'byte-compile-one-arg)
(put '-first-item 'pure t)
(put '-first-item 'side-effect-free t)

(defalias '-second-item #'cadr
  "Return the second item of LIST, or nil if LIST is too short.

See also: `-first-item', `-third-item', etc.

\(fn LIST)")

(put '-second-item 'pure t)
(put '-second-item 'side-effect-free t)

(defalias '-third-item
  (if (fboundp 'caddr)
      #'caddr
    (lambda (list) (car (cddr list))))
  "Return the third item of LIST, or nil if LIST is too short.

See also: `-second-item', `-fourth-item', etc.

\(fn LIST)")

(put '-third-item 'pure t)
(put '-third-item 'side-effect-free t)

(defalias '-fourth-item
  (if (fboundp 'cadddr)
      #'cadddr
    (lambda (list) (cadr (cddr list))))
  "Return the fourth item of LIST, or nil if LIST is too short.

See also: `-third-item', `-fifth-item', etc.

\(fn LIST)")

(put '-fourth-item 'pure t)
(put '-fourth-item 'side-effect-free t)

(defun -fifth-item (list)
  "Return the fifth item of LIST, or nil if LIST is too short.

See also: `-fourth-item', `-last-item', etc."
  (declare (pure t) (side-effect-free t))
  (car (cddr (cddr list))))

(defun -last-item (list)
  "Return the last item of LIST, or nil on an empty list.

See also: `-first-item', etc."
  (declare (pure t) (side-effect-free t))
  (car (last list)))

;; Use `with-no-warnings' to suppress unbound `-last-item' or
;; undefined `gv--defsetter' warnings arising from both
;; `gv-define-setter' and `defsetf' in certain Emacs versions.
(with-no-warnings
  (if (fboundp 'gv-define-setter)
      (gv-define-setter -last-item (val x) `(setcar (last ,x) ,val))
    (defsetf -last-item (x) (val) `(setcar (last ,x) ,val))))

(defun -butlast (list)
  "Return a list of all items in list except for the last."
  ;; no alias as we don't want magic optional argument
  (declare (pure t) (side-effect-free t))
  (butlast list))

(defmacro --count (pred list)
  "Anaphoric form of `-count'."
  (declare (debug (form form)))
  (let ((r (make-symbol "result")))
    `(let ((,r 0))
       (--each ,list (when ,pred (setq ,r (1+ ,r))))
       ,r)))

(defun -count (pred list)
  "Counts the number of items in LIST where (PRED item) is non-nil."
  (--count (funcall pred it) list))

(defun ---truthy? (obj)
  "Return OBJ as a boolean value (t or nil)."
  (declare (pure t) (side-effect-free error-free))
  (and obj t))

(defmacro --any? (form list)
  "Anaphoric form of `-any?'."
  (declare (debug (form form)))
  `(and (--some ,form ,list) t))

(defun -any? (pred list)
  "Return t if (PRED X) is non-nil for any X in LIST, else nil.

Alias: `-any-p', `-some?', `-some-p'"
  (--any? (funcall pred it) list))

(defalias '-some? '-any?)
(defalias '--some? '--any?)
(defalias '-any-p '-any?)
(defalias '--any-p '--any?)
(defalias '-some-p '-any?)
(defalias '--some-p '--any?)

(defmacro --all? (form list)
  "Return t if FORM evals to non-nil for all items in LIST.
Otherwise, once an item is reached for which FORM yields nil,
return nil without evaluating FORM for any further LIST elements.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.

The similar macro `--every' is more widely useful, since it
returns the last non-nil result of FORM instead of just t on
success.

Alias: `--all-p', `--every-p', `--every?'.

This is the anaphoric counterpart to `-all?'."
  (declare (debug (form form)))
  `(and (--every ,form ,list) t))

(defun -all? (pred list)
  "Return t if (PRED X) is non-nil for all X in LIST, else nil.
In the latter case, stop after the first X for which (PRED X) is
nil, without calling PRED on any subsequent elements of LIST.

The similar function `-every' is more widely useful, since it
returns the last non-nil result of PRED instead of just t on
success.

Alias: `-all-p', `-every-p', `-every?'.

This function's anaphoric counterpart is `--all?'."
  (--all? (funcall pred it) list))

(defalias '-every? '-all?)
(defalias '--every? '--all?)
(defalias '-all-p '-all?)
(defalias '--all-p '--all?)
(defalias '-every-p '-all?)
(defalias '--every-p '--all?)

(defmacro --none? (form list)
  "Anaphoric form of `-none?'."
  (declare (debug (form form)))
  `(--all? (not ,form) ,list))

(defun -none? (pred list)
  "Return t if (PRED X) is nil for all X in LIST, else nil.

Alias: `-none-p'"
  (--none? (funcall pred it) list))

(defalias '-none-p '-none?)
(defalias '--none-p '--none?)

(defmacro --only-some? (form list)
  "Anaphoric form of `-only-some?'."
  (declare (debug (form form)))
  (let ((y (make-symbol "yes"))
        (n (make-symbol "no")))
    `(let (,y ,n)
       (--each-while ,list (not (and ,y ,n))
         (if ,form (setq ,y t) (setq ,n t)))
       (---truthy? (and ,y ,n)))))

(defun -only-some? (pred list)
  "Return t if different LIST items both satisfy and do not satisfy PRED.
That is, if PRED returns both nil for at least one item, and
non-nil for at least one other item in LIST.  Return nil if all
items satisfy the predicate or none of them do.

Alias: `-only-some-p'"
  (--only-some? (funcall pred it) list))

(defalias '-only-some-p '-only-some?)
(defalias '--only-some-p '--only-some?)

(defun -slice (list from &optional to step)
  "Return copy of LIST, starting from index FROM to index TO.

FROM or TO may be negative.  These values are then interpreted
modulo the length of the list.

If STEP is a number, only each STEPth item in the resulting
section is returned.  Defaults to 1."
  (declare (pure t) (side-effect-free t))
  (let ((length (length list))
        (new-list nil))
    ;; to defaults to the end of the list
    (setq to (or to length))
    (setq step (or step 1))
    ;; handle negative indices
    (when (< from 0)
      (setq from (mod from length)))
    (when (< to 0)
      (setq to (mod to length)))

    ;; iterate through the list, keeping the elements we want
    (--each-while list (< it-index to)
      (when (and (>= it-index from)
                 (= (mod (- from it-index) step) 0))
        (push it new-list)))
    (nreverse new-list)))

(defmacro --take-while (form list)
  "Take successive items from LIST for which FORM evals to non-nil.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.  Return a new
list of the successive elements from the start of LIST for which
FORM evaluates to non-nil.
This is the anaphoric counterpart to `-take-while'."
  (declare (debug (form form)))
  (let ((r (make-symbol "result")))
    `(let (,r)
       (--each-while ,list ,form (push it ,r))
       (nreverse ,r))))

(defun -take-while (pred list)
  "Take successive items from LIST for which PRED returns non-nil.
PRED is a function of one argument.  Return a new list of the
successive elements from the start of LIST for which PRED returns
non-nil.

This function's anaphoric counterpart is `--take-while'.

For another variant, see also `-drop-while'."
  (--take-while (funcall pred it) list))

(defmacro --drop-while (form list)
  "Drop successive items from LIST for which FORM evals to non-nil.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.  Return the
tail (not a copy) of LIST starting from its first element for
which FORM evaluates to nil.
This is the anaphoric counterpart to `-drop-while'."
  (declare (debug (form form)))
  (let ((l (make-symbol "list")))
    `(let ((,l ,list))
       (--each-while ,l ,form (pop ,l))
       ,l)))

(defun -drop-while (pred list)
  "Drop successive items from LIST for which PRED returns non-nil.
PRED is a function of one argument.  Return the tail (not a copy)
of LIST starting from its first element for which PRED returns
nil.

This function's anaphoric counterpart is `--drop-while'.

For another variant, see also `-take-while'."
  (--drop-while (funcall pred it) list))

(defun -take (n list)
  "Return a copy of the first N items in LIST.
Return a copy of LIST if it contains N items or fewer.
Return nil if N is zero or less.

See also: `-take-last'."
  (declare (pure t) (side-effect-free t))
  (--take-while (< it-index n) list))

(defun -take-last (n list)
  "Return a copy of the last N items of LIST in order.
Return a copy of LIST if it contains N items or fewer.
Return nil if N is zero or less.

See also: `-take'."
  (declare (pure t) (side-effect-free t))
  (copy-sequence (last list n)))

(defalias '-drop #'nthcdr
  "Return the tail (not a copy) of LIST without the first N items.
Return nil if LIST contains N items or fewer.
Return LIST if N is zero or less.

For another variant, see also `-drop-last'.
\n(fn N LIST)")

(defun -drop-last (n list)
  "Return a copy of LIST without its last N items.
Return a copy of LIST if N is zero or less.
Return nil if LIST contains N items or fewer.

See also: `-drop'."
  (declare (pure t) (side-effect-free t))
  (nbutlast (copy-sequence list) n))

(defun -split-at (n list)
  "Split LIST into two sublists after the Nth element.
The result is a list of two elements (TAKE DROP) where TAKE is a
new list of the first N elements of LIST, and DROP is the
remaining elements of LIST (not a copy).  TAKE and DROP are like
the results of `-take' and `-drop', respectively, but the split
is done in a single list traversal."
  (declare (pure t) (side-effect-free t))
  (let (result)
    (--each-while list (< it-index n)
      (push (pop list) result))
    (list (nreverse result) list)))

(defun -rotate (n list)
  "Rotate LIST N places to the right (left if N is negative).
The time complexity is O(n)."
  (declare (pure t) (side-effect-free t))
  (cond ((null list) ())
        ((zerop n) (copy-sequence list))
        ((let* ((len (length list))
                (n-mod-len (mod n len))
                (new-tail-len (- len n-mod-len)))
           (append (nthcdr new-tail-len list) (-take new-tail-len list))))))

(defun -insert-at (n x list)
  "Return a list with X inserted into LIST at position N.

See also: `-splice', `-splice-list'"
  (declare (pure t) (side-effect-free t))
  (let ((split-list (-split-at n list)))
    (nconc (car split-list) (cons x (cadr split-list)))))

(defun -replace-at (n x list)
  "Return a list with element at Nth position in LIST replaced with X.

See also: `-replace'"
  (declare (pure t) (side-effect-free t))
  (let ((split-list (-split-at n list)))
    (nconc (car split-list) (cons x (cdr (cadr split-list))))))

(defun -update-at (n func list)
  "Use FUNC to update the Nth element of LIST.
Return a copy of LIST where the Nth element is replaced with the
result of calling FUNC on it.

See also: `-map-when'"
  (let ((split-list (-split-at n list)))
    (nconc (car split-list)
           (cons (funcall func (car (cadr split-list)))
                 (cdr (cadr split-list))))))

(defmacro --update-at (n form list)
  "Anaphoric version of `-update-at'."
  (declare (debug (form def-form form)))
  `(-update-at ,n (lambda (it) (ignore it) ,form) ,list))

(defun -remove-at (n list)
  "Return a list with element at Nth position in LIST removed.

See also: `-remove-at-indices', `-remove'"
  (declare (pure t) (side-effect-free t))
  (-remove-at-indices (list n) list))

(defun -remove-at-indices (indices list)
  "Return a list whose elements are elements from LIST without
elements selected as `(nth i list)` for all i
from INDICES.

See also: `-remove-at', `-remove'"
  (declare (pure t) (side-effect-free t))
  (let* ((indices (-sort '< indices))
         (diffs (cons (car indices) (-map '1- (-zip-with '- (cdr indices) indices))))
         r)
    (--each diffs
      (let ((split (-split-at it list)))
        (!cons (car split) r)
        (setq list (cdr (cadr split)))))
    (!cons list r)
    (apply '-concat (nreverse r))))

(defmacro --split-with (pred list)
  "Anaphoric form of `-split-with'."
  (declare (debug (form form)))
  (let ((l (make-symbol "list"))
        (r (make-symbol "result"))
        (c (make-symbol "continue")))
    `(let ((,l ,list)
           (,r nil)
           (,c t))
       (while (and ,l ,c)
         (let ((it (car ,l)))
           (if (not ,pred)
               (setq ,c nil)
             (!cons it ,r)
             (!cdr ,l))))
       (list (nreverse ,r) ,l))))

(defun -split-with (pred list)
  "Split LIST into a prefix satisfying PRED, and the rest.
The first sublist is the prefix of LIST with successive elements
satisfying PRED, and the second sublist is the remaining elements
that do not.  The result is like performing

  ((-take-while PRED LIST) (-drop-while PRED LIST))

but in no more than a single pass through LIST."
  (--split-with (funcall pred it) list))

(defmacro -split-on (item list)
  "Split the LIST each time ITEM is found.

Unlike `-partition-by', the ITEM is discarded from the results.
Empty lists are also removed from the result.

Comparison is done by `equal'.

See also `-split-when'"
  (declare (debug (def-form form)))
  `(-split-when (lambda (it) (equal it ,item)) ,list))

(defmacro --split-when (form list)
  "Anaphoric version of `-split-when'."
  (declare (debug (def-form form)))
  `(-split-when (lambda (it) (ignore it) ,form) ,list))

(defun -split-when (fn list)
  "Split the LIST on each element where FN returns non-nil.

Unlike `-partition-by', the \"matched\" element is discarded from
the results.  Empty lists are also removed from the result.

This function can be thought of as a generalization of
`split-string'."
  (let (r s)
    (while list
      (if (not (funcall fn (car list)))
          (push (car list) s)
        (when s (push (nreverse s) r))
        (setq s nil))
      (!cdr list))
    (when s (push (nreverse s) r))
    (nreverse r)))

(defmacro --separate (form list)
  "Anaphoric form of `-separate'."
  (declare (debug (form form)))
  (let ((y (make-symbol "yes"))
        (n (make-symbol "no")))
    `(let (,y ,n)
       (--each ,list (if ,form (!cons it ,y) (!cons it ,n)))
       (list (nreverse ,y) (nreverse ,n)))))

(defun -separate (pred list)
  "Split LIST into two sublists based on whether items satisfy PRED.
The result is like performing

  ((-filter PRED LIST) (-remove PRED LIST))

but in a single pass through LIST."
  (--separate (funcall pred it) list))

(defun dash--partition-all-in-steps-reversed (n step list)
  "Like `-partition-all-in-steps', but the result is reversed."
  (when (< step 1)
    (signal 'wrong-type-argument
            `("Step size < 1 results in juicy infinite loops" ,step)))
  (let (result)
    (while list
      (push (-take n list) result)
      (setq list (nthcdr step list)))
    result))

(defun -partition-all-in-steps (n step list)
  "Partition LIST into sublists of length N that are STEP items apart.
Adjacent groups may overlap if N exceeds the STEP stride.
Trailing groups may contain less than N items."
  (declare (pure t) (side-effect-free t))
  (nreverse (dash--partition-all-in-steps-reversed n step list)))

(defun -partition-in-steps (n step list)
  "Partition LIST into sublists of length N that are STEP items apart.
Like `-partition-all-in-steps', but if there are not enough items
to make the last group N-sized, those items are discarded."
  (declare (pure t) (side-effect-free t))
  (let ((result (dash--partition-all-in-steps-reversed n step list)))
    (while (and result (< (length (car result)) n))
      (pop result))
    (nreverse result)))

(defun -partition-all (n list)
  "Return a new list with the items in LIST grouped into N-sized sublists.
The last group may contain less than N items."
  (declare (pure t) (side-effect-free t))
  (-partition-all-in-steps n n list))

(defun -partition (n list)
  "Return a new list with the items in LIST grouped into N-sized sublists.
If there are not enough items to make the last group N-sized,
those items are discarded."
  (declare (pure t) (side-effect-free t))
  (-partition-in-steps n n list))

(defmacro --partition-by (form list)
  "Anaphoric form of `-partition-by'."
  (declare (debug (form form)))
  (let ((r (make-symbol "result"))
        (s (make-symbol "sublist"))
        (v (make-symbol "value"))
        (n (make-symbol "new-value"))
        (l (make-symbol "list")))
    `(let ((,l ,list))
       (when ,l
         (let* ((,r nil)
                (it (car ,l))
                (,s (list it))
                (,v ,form)
                (,l (cdr ,l)))
           (while ,l
             (let* ((it (car ,l))
                    (,n ,form))
               (unless (equal ,v ,n)
                 (!cons (nreverse ,s) ,r)
                 (setq ,s nil)
                 (setq ,v ,n))
               (!cons it ,s)
               (!cdr ,l)))
           (!cons (nreverse ,s) ,r)
           (nreverse ,r))))))

(defun -partition-by (fn list)
  "Apply FN to each item in LIST, splitting it each time FN returns a new value."
  (--partition-by (funcall fn it) list))

(defmacro --partition-by-header (form list)
  "Anaphoric form of `-partition-by-header'."
  (declare (debug (form form)))
  (let ((r (make-symbol "result"))
        (s (make-symbol "sublist"))
        (h (make-symbol "header-value"))
        (b (make-symbol "seen-body?"))
        (n (make-symbol "new-value"))
        (l (make-symbol "list")))
    `(let ((,l ,list))
       (when ,l
         (let* ((,r nil)
                (it (car ,l))
                (,s (list it))
                (,h ,form)
                (,b nil)
                (,l (cdr ,l)))
           (while ,l
             (let* ((it (car ,l))
                    (,n ,form))
               (if (equal ,h ,n)
                   (when ,b
                     (!cons (nreverse ,s) ,r)
                     (setq ,s nil)
                     (setq ,b nil))
                 (setq ,b t))
               (!cons it ,s)
               (!cdr ,l)))
           (!cons (nreverse ,s) ,r)
           (nreverse ,r))))))

(defun -partition-by-header (fn list)
  "Apply FN to the first item in LIST. That is the header
value. Apply FN to each item in LIST, splitting it each time FN
returns the header value, but only after seeing at least one
other value (the body)."
  (--partition-by-header (funcall fn it) list))

(defmacro --partition-after-pred (form list)
  "Partition LIST after each element for which FORM evaluates to non-nil.
Each element of LIST in turn is bound to `it' before evaluating
FORM.

This is the anaphoric counterpart to `-partition-after-pred'."
  (let ((l (make-symbol "list"))
        (r (make-symbol "result"))
        (s (make-symbol "sublist")))
    `(let ((,l ,list) ,r ,s)
       (when ,l
         (--each ,l
           (push it ,s)
           (when ,form
             (push (nreverse ,s) ,r)
             (setq ,s ())))
         (when ,s
           (push (nreverse ,s) ,r))
         (nreverse ,r)))))

(defun -partition-after-pred (pred list)
  "Partition LIST after each element for which PRED returns non-nil.

This function's anaphoric counterpart is `--partition-after-pred'."
  (--partition-after-pred (funcall pred it) list))

(defun -partition-before-pred (pred list)
  "Partition directly before each time PRED is true on an element of LIST."
  (nreverse (-map #'reverse
                  (-partition-after-pred pred (reverse list)))))

(defun -partition-after-item (item list)
  "Partition directly after each time ITEM appears in LIST."
  (-partition-after-pred (lambda (ele) (equal ele item))
                         list))

(defun -partition-before-item (item list)
  "Partition directly before each time ITEM appears in LIST."
  (-partition-before-pred (lambda (ele) (equal ele item))
                          list))

(defmacro --group-by (form list)
  "Anaphoric form of `-group-by'."
  (declare (debug t))
  (let ((n (make-symbol "n"))
        (k (make-symbol "k"))
        (grp (make-symbol "grp")))
    `(nreverse
      (-map
       (lambda (,n)
         (cons (car ,n)
               (nreverse (cdr ,n))))
       (--reduce-from
        (let* ((,k (,@form))
               (,grp (assoc ,k acc)))
          (if ,grp
              (setcdr ,grp (cons it (cdr ,grp)))
            (push
             (list ,k it)
             acc))
          acc)
        nil ,list)))))

(defun -group-by (fn list)
  "Separate LIST into an alist whose keys are FN applied to the
elements of LIST.  Keys are compared by `equal'."
  (--group-by (funcall fn it) list))

(defun -interpose (sep list)
  "Return a new list of all elements in LIST separated by SEP."
  (declare (pure t) (side-effect-free t))
  (let (result)
    (when list
      (!cons (car list) result)
      (!cdr list))
    (while list
      (setq result (cons (car list) (cons sep result)))
      (!cdr list))
    (nreverse result)))

(defun -interleave (&rest lists)
  "Return a new list of the first item in each list, then the second etc."
  (declare (pure t) (side-effect-free t))
  (when lists
    (let (result)
      (while (-none? 'null lists)
        (--each lists (!cons (car it) result))
        (setq lists (-map 'cdr lists)))
      (nreverse result))))

(defmacro --zip-with (form list1 list2)
  "Anaphoric form of `-zip-with'.

Each element in turn of LIST1 is bound to `it', and of LIST2 to
`other', before evaluating FORM."
  (declare (debug (form form form)))
  (let ((r (make-symbol "result"))
        (l1 (make-symbol "list1"))
        (l2 (make-symbol "list2")))
    `(let ((,r nil)
           (,l1 ,list1)
           (,l2 ,list2))
       (while (and ,l1 ,l2)
         (let ((it (car ,l1))
               (other (car ,l2)))
           (!cons ,form ,r)
           (!cdr ,l1)
           (!cdr ,l2)))
       (nreverse ,r))))

(defun -zip-with (fn list1 list2)
  "Zip the two lists LIST1 and LIST2 using a function FN.  This
function is applied pairwise taking as first argument element of
LIST1 and as second argument element of LIST2 at corresponding
position.

The anaphoric form `--zip-with' binds the elements from LIST1 as symbol `it',
and the elements from LIST2 as symbol `other'."
  (--zip-with (funcall fn it other) list1 list2))

(defun -zip-lists (&rest lists)
  "Zip LISTS together.  Group the head of each list, followed by the
second elements of each list, and so on. The lengths of the returned
groupings are equal to the length of the shortest input list.

The return value is always list of lists, which is a difference
from `-zip-pair' which returns a cons-cell in case two input
lists are provided.

See also: `-zip'"
  (declare (pure t) (side-effect-free t))
  (when lists
    (let (results)
      (while (-none? 'null lists)
        (setq results (cons (mapcar 'car lists) results))
        (setq lists (mapcar 'cdr lists)))
      (nreverse results))))

(defun -zip (&rest lists)
  "Zip LISTS together.  Group the head of each list, followed by the
second elements of each list, and so on. The lengths of the returned
groupings are equal to the length of the shortest input list.

If two lists are provided as arguments, return the groupings as a list
of cons cells. Otherwise, return the groupings as a list of lists.

Use `-zip-lists' if you need the return value to always be a list
of lists.

Alias: `-zip-pair'

See also: `-zip-lists'"
  (declare (pure t) (side-effect-free t))
  (when lists
    (let (results)
      (while (-none? 'null lists)
        (setq results (cons (mapcar 'car lists) results))
        (setq lists (mapcar 'cdr lists)))
      (setq results (nreverse results))
      (if (= (length lists) 2)
          ;; to support backward compatibility, return
          ;; a cons cell if two lists were provided
          (--map (cons (car it) (cadr it)) results)
        results))))

(defalias '-zip-pair '-zip)

(defun -zip-fill (fill-value &rest lists)
  "Zip LISTS, with FILL-VALUE padded onto the shorter lists. The
lengths of the returned groupings are equal to the length of the
longest input list."
  (declare (pure t) (side-effect-free t))
  (apply '-zip (apply '-pad (cons fill-value lists))))

(defun -unzip (lists)
  "Unzip LISTS.

This works just like `-zip' but takes a list of lists instead of
a variable number of arguments, such that

  (-unzip (-zip L1 L2 L3 ...))

is identity (given that the lists are the same length).

Note in particular that calling this on a list of two lists will
return a list of cons-cells such that the above identity works.

See also: `-zip'"
  (apply '-zip lists))

(defun -cycle (list)
  "Return an infinite circular copy of LIST.
The returned list cycles through the elements of LIST and repeats
from the beginning."
  (declare (pure t) (side-effect-free t))
  ;; Also works with sequences that aren't lists.
  (let ((newlist (append list ())))
    (nconc newlist newlist)))

(defun -pad (fill-value &rest lists)
  "Pad each of LISTS with FILL-VALUE until they all have equal lengths.

Ensure all LISTS are as long as the longest one by repeatedly
appending FILL-VALUE to the shorter lists, and return the
resulting LISTS."
  (declare (pure t) (side-effect-free t))
  (let* ((lens (mapcar #'length lists))
         (maxlen (apply #'max 0 lens)))
    (--map (append it (make-list (- maxlen (pop lens)) fill-value)) lists)))

(defmacro --annotate (form list)
  "Pair each item in LIST with the result of evaluating FORM.

Return an alist of (RESULT . ITEM), where each ITEM is the
corresponding element of LIST, and RESULT is the value obtained
by evaluating FORM with ITEM bound to `it'.

This is the anaphoric counterpart to `-annotate'."
  (declare (debug (form form)))
  `(--map (cons ,form it) ,list))

(defun -annotate (fn list)
  "Pair each item in LIST with the result of passing it to FN.

Return an alist of (RESULT . ITEM), where each ITEM is the
corresponding element of LIST, and RESULT is the value obtained
by calling FN on ITEM.

This function's anaphoric counterpart is `--annotate'."
  (--annotate (funcall fn it) list))

(defun dash--table-carry (lists restore-lists &optional re)
  "Helper for `-table' and `-table-flat'.

If a list overflows, carry to the right and reset the list."
  (while (not (or (car lists)
                  (equal lists '(nil))))
    (setcar lists (car restore-lists))
    (pop (cadr lists))
    (!cdr lists)
    (!cdr restore-lists)
    (when re
      (push (nreverse (car re)) (cadr re))
      (setcar re nil)
      (!cdr re))))

(defun -table (fn &rest lists)
  "Compute outer product of LISTS using function FN.

The function FN should have the same arity as the number of
supplied lists.

The outer product is computed by applying fn to all possible
combinations created by taking one element from each list in
order.  The dimension of the result is (length lists).

See also: `-table-flat'"
  (let ((restore-lists (copy-sequence lists))
        (last-list (last lists))
        (re (make-list (length lists) nil)))
    (while (car last-list)
      (let ((item (apply fn (-map 'car lists))))
        (push item (car re))
        (setcar lists (cdar lists)) ;; silence byte compiler
        (dash--table-carry lists restore-lists re)))
    (nreverse (car (last re)))))

(defun -table-flat (fn &rest lists)
  "Compute flat outer product of LISTS using function FN.

The function FN should have the same arity as the number of
supplied lists.

The outer product is computed by applying fn to all possible
combinations created by taking one element from each list in
order.  The results are flattened, ignoring the tensor structure
of the result.  This is equivalent to calling:

  (-flatten-n (1- (length lists)) (apply \\='-table fn lists))

but the implementation here is much more efficient.

See also: `-flatten-n', `-table'"
  (let ((restore-lists (copy-sequence lists))
        (last-list (last lists))
        re)
    (while (car last-list)
      (let ((item (apply fn (-map 'car lists))))
        (push item re)
        (setcar lists (cdar lists)) ;; silence byte compiler
        (dash--table-carry lists restore-lists)))
    (nreverse re)))

(defmacro --find-index (form list)
  "Return the first index in LIST for which FORM evals to non-nil.
Return nil if no such index is found.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.
This is the anaphoric counterpart to `-find-index'."
  (declare (debug (form form)))
  `(--some (and ,form it-index) ,list))

(defun -find-index (pred list)
  "Return the index of the first item satisfying PRED in LIST.
Return nil if no such item is found.

PRED is called with one argument, the current list element, until
it returns non-nil, at which point the search terminates.

This function's anaphoric counterpart is `--find-index'.

See also: `-first', `-find-last-index'."
  (--find-index (funcall pred it) list))

(defun -elem-index (elem list)
  "Return the first index of ELEM in LIST.
That is, the index within LIST of the first element that is
`equal' to ELEM.  Return nil if there is no such element.

See also: `-find-index'."
  (declare (pure t) (side-effect-free t))
  (--find-index (equal elem it) list))

(defmacro --find-indices (form list)
  "Return the list of indices in LIST for which FORM evals to non-nil.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.
This is the anaphoric counterpart to `-find-indices'."
  (declare (debug (form form)))
  `(--keep (and ,form it-index) ,list))

(defun -find-indices (pred list)
  "Return the list of indices in LIST satisfying PRED.

Each element of LIST in turn is passed to PRED.  If the result is
non-nil, the index of that element in LIST is included in the
result.  The returned indices are in ascending order, i.e., in
the same order as they appear in LIST.

This function's anaphoric counterpart is `--find-indices'.

See also: `-find-index', `-elem-indices'."
  (--find-indices (funcall pred it) list))

(defun -elem-indices (elem list)
  "Return the list of indices at which ELEM appears in LIST.
That is, the indices of all elements of LIST `equal' to ELEM, in
the same ascending order as they appear in LIST."
  (declare (pure t) (side-effect-free t))
  (--find-indices (equal elem it) list))

(defmacro --find-last-index (form list)
  "Return the last index in LIST for which FORM evals to non-nil.
Return nil if no such index is found.
Each element of LIST in turn is bound to `it' and its index
within LIST to `it-index' before evaluating FORM.
This is the anaphoric counterpart to `-find-last-index'."
  (declare (debug (form form)))
  (let ((i (make-symbol "index")))
    `(let (,i)
       (--each ,list
         (when ,form (setq ,i it-index)))
       ,i)))

(defun -find-last-index (pred list)
  "Return the index of the last item satisfying PRED in LIST.
Return nil if no such item is found.

Predicate PRED is called with one argument each time, namely the
current list element.

This function's anaphoric counterpart is `--find-last-index'.

See also: `-last', `-find-index'."
  (--find-last-index (funcall pred it) list))

(defun -select-by-indices (indices list)
  "Return a list whose elements are elements from LIST selected
as `(nth i list)` for all i from INDICES."
  (declare (pure t) (side-effect-free t))
  (let (r)
    (--each indices
      (!cons (nth it list) r))
    (nreverse r)))

(defun -select-columns (columns table)
  "Select COLUMNS from TABLE.

TABLE is a list of lists where each element represents one row.
It is assumed each row has the same length.

Each row is transformed such that only the specified COLUMNS are
selected.

See also: `-select-column', `-select-by-indices'"
  (declare (pure t) (side-effect-free t))
  (--map (-select-by-indices columns it) table))

(defun -select-column (column table)
  "Select COLUMN from TABLE.

TABLE is a list of lists where each element represents one row.
It is assumed each row has the same length.

The single selected column is returned as a list.

See also: `-select-columns', `-select-by-indices'"
  (declare (pure t) (side-effect-free t))
  (--mapcat (-select-by-indices (list column) it) table))

(defmacro -> (x &optional form &rest more)
  "Thread the expr through the forms. Insert X as the second item
in the first form, making a list of it if it is not a list
already. If there are more forms, insert the first form as the
second item in second form, etc."
  (declare (debug (form &rest [&or symbolp (sexp &rest form)])))
  (cond
   ((null form) x)
   ((null more) (if (listp form)
                    `(,(car form) ,x ,@(cdr form))
                  (list form x)))
   (:else `(-> (-> ,x ,form) ,@more))))

(defmacro ->> (x &optional form &rest more)
  "Thread the expr through the forms. Insert X as the last item
in the first form, making a list of it if it is not a list
already. If there are more forms, insert the first form as the
last item in second form, etc."
  (declare (debug ->))
  (cond
   ((null form) x)
   ((null more) (if (listp form)
                    `(,@form ,x)
                  (list form x)))
   (:else `(->> (->> ,x ,form) ,@more))))

(defmacro --> (x &rest forms)
  "Starting with the value of X, thread each expression through FORMS.

Insert X at the position signified by the symbol `it' in the first
form.  If there are more forms, insert the first form at the position
signified by `it' in in second form, etc."
  (declare (debug (form body)))
  `(-as-> ,x it ,@forms))

(defmacro -as-> (value variable &rest forms)
  "Starting with VALUE, thread VARIABLE through FORMS.

In the first form, bind VARIABLE to VALUE.  In the second form, bind
VARIABLE to the result of the first form, and so forth."
  (declare (debug (form symbolp body)))
  (if (null forms)
      `,value
    `(let ((,variable ,value))
       (-as-> ,(if (symbolp (car forms))
                   (list (car forms) variable)
                 (car forms))
              ,variable
              ,@(cdr forms)))))

(defmacro -some-> (x &optional form &rest more)
  "When expr is non-nil, thread it through the first form (via `->'),
and when that result is non-nil, through the next form, etc."
  (declare (debug ->)
           (indent 1))
  (if (null form) x
    (let ((result (make-symbol "result")))
      `(-some-> (-when-let (,result ,x)
                  (-> ,result ,form))
         ,@more))))

(defmacro -some->> (x &optional form &rest more)
  "When expr is non-nil, thread it through the first form (via `->>'),
and when that result is non-nil, through the next form, etc."
  (declare (debug ->)
           (indent 1))
  (if (null form) x
    (let ((result (make-symbol "result")))
      `(-some->> (-when-let (,result ,x)
                   (->> ,result ,form))
         ,@more))))

(defmacro -some--> (expr &rest forms)
  "Thread EXPR through FORMS via `-->', while the result is non-nil.
When EXPR evaluates to non-nil, thread the result through the
first of FORMS, and when that result is non-nil, thread it
through the next form, etc."
  (declare (debug (form &rest &or symbolp consp)) (indent 1))
  (if (null forms) expr
    (let ((result (make-symbol "result")))
      `(-some--> (-when-let (,result ,expr)
                   (--> ,result ,(car forms)))
         ,@(cdr forms)))))

(defmacro -doto (init &rest forms)
  "Evaluate INIT and pass it as argument to FORMS with `->'.
The RESULT of evaluating INIT is threaded through each of FORMS
individually using `->', which see.  The return value is RESULT,
which FORMS may have modified by side effect."
  (declare (debug (form &rest &or symbolp consp)) (indent 1))
  (let ((retval (make-symbol "result")))
    `(let ((,retval ,init))
       ,@(mapcar (lambda (form) `(-> ,retval ,form)) forms)
       ,retval)))

(defmacro --doto (init &rest forms)
  "Anaphoric form of `-doto'.
This just evaluates INIT, binds the result to `it', evaluates
FORMS, and returns the final value of `it'.
Note: `it' need not be used in each form."
  (declare (debug (form body)) (indent 1))
  `(let ((it ,init))
     ,@forms
     it))

(defun -grade-up (comparator list)
  "Grade elements of LIST using COMPARATOR relation.
This yields a permutation vector such that applying this
permutation to LIST sorts it in ascending order."
  (->> (--map-indexed (cons it it-index) list)
       (-sort (lambda (it other) (funcall comparator (car it) (car other))))
       (mapcar #'cdr)))

(defun -grade-down (comparator list)
  "Grade elements of LIST using COMPARATOR relation.
This yields a permutation vector such that applying this
permutation to LIST sorts it in descending order."
  (->> (--map-indexed (cons it it-index) list)
       (-sort (lambda (it other) (funcall comparator (car other) (car it))))
       (mapcar #'cdr)))

(defvar dash--source-counter 0
  "Monotonic counter for generated symbols.")

(defun dash--match-make-source-symbol ()
  "Generate a new dash-source symbol.

All returned symbols are guaranteed to be unique."
  (prog1 (make-symbol (format "--dash-source-%d--" dash--source-counter))
    (setq dash--source-counter (1+ dash--source-counter))))

(defun dash--match-ignore-place-p (symbol)
  "Return non-nil if SYMBOL is a symbol and starts with _."
  (and (symbolp symbol)
       (eq (aref (symbol-name symbol) 0) ?_)))

(defun dash--match-cons-skip-cdr (skip-cdr source)
  "Helper function generating idiomatic shifting code."
  (cond
   ((= skip-cdr 0)
    `(pop ,source))
   (t
    `(prog1 ,(dash--match-cons-get-car skip-cdr source)
       (setq ,source ,(dash--match-cons-get-cdr (1+ skip-cdr) source))))))

(defun dash--match-cons-get-car (skip-cdr source)
  "Helper function generating idiomatic code to get nth car."
  (cond
   ((= skip-cdr 0)
    `(car ,source))
   ((= skip-cdr 1)
    `(cadr ,source))
   (t
    `(nth ,skip-cdr ,source))))

(defun dash--match-cons-get-cdr (skip-cdr source)
  "Helper function generating idiomatic code to get nth cdr."
  (cond
   ((= skip-cdr 0)
    source)
   ((= skip-cdr 1)
    `(cdr ,source))
   (t
    `(nthcdr ,skip-cdr ,source))))

(defun dash--match-cons (match-form source)
  "Setup a cons matching environment and call the real matcher."
  (let ((s (dash--match-make-source-symbol))
        (n 0)
        (m match-form))
    (while (and (consp m)
                (dash--match-ignore-place-p (car m)))
      (setq n (1+ n)) (!cdr m))
    (cond
     ;; when we only have one pattern in the list, we don't have to
     ;; create a temporary binding (--dash-source--) for the source
     ;; and just use the input directly
     ((and (consp m)
           (not (cdr m)))
      (dash--match (car m) (dash--match-cons-get-car n source)))
     ;; handle other special types
     ((> n 0)
      (dash--match m (dash--match-cons-get-cdr n source)))
     ;; this is the only entry-point for dash--match-cons-1, that's
     ;; why we can't simply use the above branch, it would produce
     ;; infinite recursion
     (t
      (cons (list s source) (dash--match-cons-1 match-form s))))))

(defun dash--get-expand-function (type)
  "Get expand function name for TYPE."
  (intern-soft (format "dash-expand:%s" type)))

(defun dash--match-cons-1 (match-form source &optional props)
  "Match MATCH-FORM against SOURCE.

MATCH-FORM is a proper or improper list.  Each element of
MATCH-FORM is either a symbol, which gets bound to the respective
value in source or another match form which gets destructured
recursively.

If the cdr of last cons cell in the list is nil, matching stops
there.

SOURCE is a proper or improper list."
  (let ((skip-cdr (or (plist-get props :skip-cdr) 0)))
    (cond
     ((consp match-form)
      (cond
       ((cdr match-form)
        (cond
         ((and (symbolp (car match-form))
               (functionp (dash--get-expand-function (car match-form))))
          (dash--match-kv (dash--match-kv-normalize-match-form match-form) (dash--match-cons-get-cdr skip-cdr source)))
         ((dash--match-ignore-place-p (car match-form))
          (dash--match-cons-1 (cdr match-form) source
                              (plist-put props :skip-cdr (1+ skip-cdr))))
         (t
          (-concat (dash--match (car match-form) (dash--match-cons-skip-cdr skip-cdr source))
                   (dash--match-cons-1 (cdr match-form) source)))))
       (t ;; Last matching place, no need for shift
        (dash--match (car match-form) (dash--match-cons-get-car skip-cdr source)))))
     ((eq match-form nil)
      nil)
     (t ;; Handle improper lists.  Last matching place, no need for shift
      (dash--match match-form (dash--match-cons-get-cdr skip-cdr source))))))

(defun dash--match-vector (match-form source)
  "Setup a vector matching environment and call the real matcher."
  (let ((s (dash--match-make-source-symbol)))
    (cond
     ;; don't bind `s' if we only have one sub-pattern
     ((= (length match-form) 1)
      (dash--match (aref match-form 0) `(aref ,source 0)))
     ;; if the source is a symbol, we don't need to re-bind it
     ((symbolp source)
      (dash--match-vector-1 match-form source))
     ;; don't bind `s' if we only have one sub-pattern which is not ignored
     ((let* ((ignored-places (mapcar 'dash--match-ignore-place-p match-form))
             (ignored-places-n (length (-remove 'null ignored-places))))
        (when (= ignored-places-n (1- (length match-form)))
          (let ((n (-find-index 'null ignored-places)))
            (dash--match (aref match-form n) `(aref ,source ,n))))))
     (t
      (cons (list s source) (dash--match-vector-1 match-form s))))))

(defun dash--match-vector-1 (match-form source)
  "Match MATCH-FORM against SOURCE.

MATCH-FORM is a vector.  Each element of MATCH-FORM is either a
symbol, which gets bound to the respective value in source or
another match form which gets destructured recursively.

If second-from-last place in MATCH-FORM is the symbol &rest, the
next element of the MATCH-FORM is matched against the tail of
SOURCE, starting at index of the &rest symbol.  This is
conceptually the same as the (head . tail) match for improper
lists, where dot plays the role of &rest.

SOURCE is a vector.

If the MATCH-FORM vector is shorter than SOURCE vector, only
the (length MATCH-FORM) places are bound, the rest of the SOURCE
is discarded."
  (let ((i 0)
        (l (length match-form))
        (re))
    (while (< i l)
      (let ((m (aref match-form i)))
        (push (cond
               ((and (symbolp m)
                     (eq m '&rest))
                (prog1 (dash--match
                        (aref match-form (1+ i))
                        `(substring ,source ,i))
                  (setq i l)))
               ((and (symbolp m)
                     ;; do not match symbols starting with _
                     (not (eq (aref (symbol-name m) 0) ?_)))
                (list (list m `(aref ,source ,i))))
               ((not (symbolp m))
                (dash--match m `(aref ,source ,i))))
              re)
        (setq i (1+ i))))
    (-flatten-n 1 (nreverse re))))

(defun dash--match-kv-normalize-match-form (pattern)
  "Normalize kv PATTERN.

This method normalizes PATTERN to the format expected by
`dash--match-kv'.  See `-let' for the specification."
  (let ((normalized (list (car pattern)))
        (skip nil)
        (fill-placeholder (make-symbol "--dash-fill-placeholder--")))
    (-each (apply '-zip (-pad fill-placeholder (cdr pattern) (cddr pattern)))
      (lambda (pair)
        (let ((current (car pair))
              (next (cdr pair)))
          (if skip
              (setq skip nil)
            (if (or (eq fill-placeholder next)
                    (not (or (and (symbolp next)
                                  (not (keywordp next))
                                  (not (eq next t))
                                  (not (eq next nil)))
                             (and (consp next)
                                  (not (eq (car next) 'quote)))
                             (vectorp next))))
                (progn
                  (cond
                   ((keywordp current)
                    (push current normalized)
                    (push (intern (substring (symbol-name current) 1)) normalized))
                   ((stringp current)
                    (push current normalized)
                    (push (intern current) normalized))
                   ((and (consp current)
                         (eq (car current) 'quote))
                    (push current normalized)
                    (push (cadr current) normalized))
                   (t (error "-let: found key `%s' in kv destructuring but its pattern `%s' is invalid and can not be derived from the key" current next)))
                  (setq skip nil))
              (push current normalized)
              (push next normalized)
              (setq skip t))))))
    (nreverse normalized)))

(defun dash--match-kv (match-form source)
  "Setup a kv matching environment and call the real matcher.

kv can be any key-value store, such as plist, alist or hash-table."
  (let ((s (dash--match-make-source-symbol)))
    (cond
     ;; don't bind `s' if we only have one sub-pattern (&type key val)
     ((= (length match-form) 3)
      (dash--match-kv-1 (cdr match-form) source (car match-form)))
     ;; if the source is a symbol, we don't need to re-bind it
     ((symbolp source)
      (dash--match-kv-1 (cdr match-form) source (car match-form)))
     (t
      (cons (list s source) (dash--match-kv-1 (cdr match-form) s (car match-form)))))))

(defun dash-expand:&hash (key source)
  "Generate extracting KEY from SOURCE for &hash destructuring."
  `(gethash ,key ,source))

(defun dash-expand:&plist (key source)
  "Generate extracting KEY from SOURCE for &plist destructuring."
  `(plist-get ,source ,key))

(defun dash-expand:&alist (key source)
  "Generate extracting KEY from SOURCE for &alist destructuring."
  `(cdr (assoc ,key ,source)))

(defun dash-expand:&hash? (key source)
  "Generate extracting KEY from SOURCE for &hash? destructuring.
Similar to &hash but check whether the map is not nil."
  (let ((src (make-symbol "src")))
    `(let ((,src ,source))
       (when ,src (gethash ,key ,src)))))

(defalias 'dash-expand:&keys 'dash-expand:&plist)

(defun dash--match-kv-1 (match-form source type)
  "Match MATCH-FORM against SOURCE of type TYPE.

MATCH-FORM is a proper list of the form (key1 place1 ... keyN
placeN).  Each placeK is either a symbol, which gets bound to the
value of keyK retrieved from the key-value store, or another
match form which gets destructured recursively.

SOURCE is a key-value store of type TYPE, which can be a plist,
an alist or a hash table.

TYPE is a token specifying the type of the key-value store.
Valid values are &plist, &alist and &hash."
  (-flatten-n 1 (-map
                 (lambda (kv)
                   (let* ((k (car kv))
                          (v (cadr kv))
                          (getter
                           (funcall (dash--get-expand-function type) k source)))
                     (cond
                      ((symbolp v)
                       (list (list v getter)))
                      (t (dash--match v getter)))))
                 (-partition 2 match-form))))

(defun dash--match-symbol (match-form source)
  "Bind a symbol.

This works just like `let', there is no destructuring."
  (list (list match-form source)))

(defun dash--match (match-form source)
  "Match MATCH-FORM against SOURCE.

This function tests the MATCH-FORM and dispatches to specific
matchers based on the type of the expression.

Key-value stores are disambiguated by placing a token &plist,
&alist or &hash as a first item in the MATCH-FORM."
  (cond
   ((and (symbolp match-form)
         ;; Don't bind things like &keys as if they were vars (#395).
         (not (functionp (dash--get-expand-function match-form))))
    (dash--match-symbol match-form source))
   ((consp match-form)
    (cond
     ;; Handle the "x &as" bindings first.
     ((and (consp (cdr match-form))
           (symbolp (car match-form))
           (eq '&as (cadr match-form)))
      (let ((s (car match-form)))
        (cons (list s source)
              (dash--match (cddr match-form) s))))
     ((functionp (dash--get-expand-function (car match-form)))
      (dash--match-kv (dash--match-kv-normalize-match-form match-form) source))
     (t (dash--match-cons match-form source))))
   ((vectorp match-form)
    ;; We support the &as binding in vectors too
    (cond
     ((and (> (length match-form) 2)
           (symbolp (aref match-form 0))
           (eq '&as (aref match-form 1)))
      (let ((s (aref match-form 0)))
        (cons (list s source)
              (dash--match (substring match-form 2) s))))
     (t (dash--match-vector match-form source))))))

(defun dash--normalize-let-varlist (varlist)
  "Normalize VARLIST so that every binding is a list.

`let' allows specifying a binding which is not a list but simply
the place which is then automatically bound to nil, such that all
three of the following are identical and evaluate to nil.

  (let (a) a)
  (let ((a)) a)
  (let ((a nil)) a)

This function normalizes all of these to the last form."
  (--map (if (consp it) it (list it nil)) varlist))

(defmacro -let* (varlist &rest body)
  "Bind variables according to VARLIST then eval BODY.

VARLIST is a list of lists of the form (PATTERN SOURCE).  Each
PATTERN is matched against the SOURCE structurally.  SOURCE is
only evaluated once for each PATTERN.

Each SOURCE can refer to the symbols already bound by this
VARLIST.  This is useful if you want to destructure SOURCE
recursively but also want to name the intermediate structures.

See `-let' for the list of all possible patterns."
  (declare (debug ((&rest [&or (sexp form) sexp]) body))
           (indent 1))
  (let* ((varlist (dash--normalize-let-varlist varlist))
         (bindings (--mapcat (dash--match (car it) (cadr it)) varlist)))
    `(let* ,bindings
       ,@body)))

(defmacro -let (varlist &rest body)
  "Bind variables according to VARLIST then eval BODY.

VARLIST is a list of lists of the form (PATTERN SOURCE).  Each
PATTERN is matched against the SOURCE \"structurally\".  SOURCE
is only evaluated once for each PATTERN.  Each PATTERN is matched
recursively, and can therefore contain sub-patterns which are
matched against corresponding sub-expressions of SOURCE.

All the SOURCEs are evalled before any symbols are
bound (i.e. \"in parallel\").

If VARLIST only contains one (PATTERN SOURCE) element, you can
optionally specify it using a vector and discarding the
outer-most parens.  Thus

  (-let ((PATTERN SOURCE)) ...)

becomes

  (-let [PATTERN SOURCE] ...).

`-let' uses a convention of not binding places (symbols) starting
with _ whenever it's possible.  You can use this to skip over
entries you don't care about.  However, this is not *always*
possible (as a result of implementation) and these symbols might
get bound to undefined values.

Following is the overview of supported patterns.  Remember that
patterns can be matched recursively, so every a, b, aK in the
following can be a matching construct and not necessarily a
symbol/variable.

Symbol:

  a - bind the SOURCE to A.  This is just like regular `let'.

Conses and lists:

  (a) - bind `car' of cons/list to A

  (a . b) - bind car of cons to A and `cdr' to B

  (a b) - bind car of list to A and `cadr' to B

  (a1 a2 a3 ...) - bind 0th car of list to A1, 1st to A2, 2nd to A3...

  (a1 a2 a3 ... aN . rest) - as above, but bind the Nth cdr to REST.

Vectors:

  [a] - bind 0th element of a non-list sequence to A (works with
        vectors, strings, bit arrays...)

  [a1 a2 a3 ...] - bind 0th element of non-list sequence to A0, 1st to
                   A1, 2nd to A2, ...
                   If the PATTERN is shorter than SOURCE, the values at
                   places not in PATTERN are ignored.
                   If the PATTERN is longer than SOURCE, an `error' is
                   thrown.

  [a1 a2 a3 ... &rest rest] - as above, but bind the rest of
                              the sequence to REST.  This is
                              conceptually the same as improper list
                              matching (a1 a2 ... aN . rest)

Key/value stores:

  (&plist key0 a0 ... keyN aN) - bind value mapped by keyK in the
                                 SOURCE plist to aK.  If the
                                 value is not found, aK is nil.
                                 Uses `plist-get' to fetch values.

  (&alist key0 a0 ... keyN aN) - bind value mapped by keyK in the
                                 SOURCE alist to aK.  If the
                                 value is not found, aK is nil.
                                 Uses `assoc' to fetch values.

  (&hash key0 a0 ... keyN aN) - bind value mapped by keyK in the
                                SOURCE hash table to aK.  If the
                                value is not found, aK is nil.
                                Uses `gethash' to fetch values.

Further, special keyword &keys supports \"inline\" matching of
plist-like key-value pairs, similarly to &keys keyword of
`cl-defun'.

  (a1 a2 ... aN &keys key1 b1 ... keyN bK)

This binds N values from the list to a1 ... aN, then interprets
the cdr as a plist (see key/value matching above).

A shorthand notation for kv-destructuring exists which allows the
patterns be optionally left out and derived from the key name in
the following fashion:

- a key :foo is converted into `foo' pattern,
- a key \\='bar is converted into `bar' pattern,
- a key \"baz\" is converted into `baz' pattern.

That is, the entire value under the key is bound to the derived
variable without any further destructuring.

This is possible only when the form following the key is not a
valid pattern (i.e. not a symbol, a cons cell or a vector).
Otherwise the matching proceeds as usual and in case of an
invalid spec fails with an error.

Thus the patterns are normalized as follows:

   ;; derive all the missing patterns
   (&plist :foo \\='bar \"baz\") => (&plist :foo foo \\='bar bar \"baz\" baz)

   ;; we can specify some but not others
   (&plist :foo \\='bar explicit-bar) => (&plist :foo foo \\='bar explicit-bar)

   ;; nothing happens, we store :foo in x
   (&plist :foo x) => (&plist :foo x)

   ;; nothing happens, we match recursively
   (&plist :foo (a b c)) => (&plist :foo (a b c))

You can name the source using the syntax SYMBOL &as PATTERN.
This syntax works with lists (proper or improper), vectors and
all types of maps.

  (list &as a b c) (list 1 2 3)

binds A to 1, B to 2, C to 3 and LIST to (1 2 3).

Similarly:

  (bounds &as beg . end) (cons 1 2)

binds BEG to 1, END to 2 and BOUNDS to (1 . 2).

  (items &as first . rest) (list 1 2 3)

binds FIRST to 1, REST to (2 3) and ITEMS to (1 2 3)

  [vect &as _ b c] [1 2 3]

binds B to 2, C to 3 and VECT to [1 2 3] (_ avoids binding as usual).

  (plist &as &plist :b b) (list :a 1 :b 2 :c 3)

binds B to 2 and PLIST to (:a 1 :b 2 :c 3).  Same for &alist and &hash.

This is especially useful when we want to capture the result of a
computation and destructure at the same time.  Consider the
form (function-returning-complex-structure) returning a list of
two vectors with two items each.  We want to capture this entire
result and pass it to another computation, but at the same time
we want to get the second item from each vector.  We can achieve
it with pattern

  (result &as [_ a] [_ b]) (function-returning-complex-structure)

Note: Clojure programmers may know this feature as the \":as
binding\".  The difference is that we put the &as at the front
because we need to support improper list binding."
  (declare (debug ([&or (&rest [&or (sexp form) sexp])
                        (vector [&rest [sexp form]])]
                   body))
           (indent 1))
  (if (vectorp varlist)
      `(let* ,(dash--match (aref varlist 0) (aref varlist 1))
         ,@body)
    (let* ((varlist (dash--normalize-let-varlist varlist))
           (inputs (--map-indexed (list (make-symbol (format "input%d" it-index)) (cadr it)) varlist))
           (new-varlist (--map (list (caar it) (cadr it)) (-zip varlist inputs))))
      `(let ,inputs
         (-let* ,new-varlist ,@body)))))

(defmacro -lambda (match-form &rest body)
  "Return a lambda which destructures its input as MATCH-FORM and executes BODY.

Note that you have to enclose the MATCH-FORM in a pair of parens,
such that:

  (-lambda (x) body)
  (-lambda (x y ...) body)

has the usual semantics of `lambda'.  Furthermore, these get
translated into normal `lambda', so there is no performance
penalty.

See `-let' for a description of the destructuring mechanism."
  (declare (doc-string 2) (indent defun)
           (debug (&define sexp
                           [&optional stringp]
                           [&optional ("interactive" interactive)]
                           def-body)))
  (cond
   ((nlistp match-form)
    (signal 'wrong-type-argument (list #'listp match-form)))
   ;; No destructuring, so just return regular `lambda' for speed.
   ((-all? #'symbolp match-form)
    `(lambda ,match-form ,@body))
   ((let ((inputs (--map-indexed
                   (list it (make-symbol (format "input%d" it-index)))
                   match-form)))
      ;; TODO: because inputs to the `lambda' are evaluated only once,
      ;; `-let*' need not create the extra bindings to ensure that.
      ;; We should find a way to optimize that.  Not critical however.
      `(lambda ,(mapcar #'cadr inputs)
         (-let* ,inputs ,@body))))))

(defmacro -setq (&rest forms)
  "Bind each MATCH-FORM to the value of its VAL.

MATCH-FORM destructuring is done according to the rules of `-let'.

This macro allows you to bind multiple variables by destructuring
the value, so for example:

  (-setq (a b) x
         (&plist :c c) plist)

expands roughly speaking to the following code

  (setq a (car x)
        b (cadr x)
        c (plist-get plist :c))

Care is taken to only evaluate each VAL once so that in case of
multiple assignments it does not cause unexpected side effects.

\(fn [MATCH-FORM VAL]...)"
  (declare (debug (&rest sexp form))
           (indent 1))
  (when (= (mod (length forms) 2) 1)
    (signal 'wrong-number-of-arguments (list '-setq (1+ (length forms)))))
  (let* ((forms-and-sources
          ;; First get all the necessary mappings with all the
          ;; intermediate bindings.
          (-map (lambda (x) (dash--match (car x) (cadr x)))
                (-partition 2 forms)))
         ;; To preserve the logic of dynamic scoping we must ensure
         ;; that we `setq' the variables outside of the `let*' form
         ;; which holds the destructured intermediate values.  For
         ;; this we generate for each variable a placeholder which is
         ;; bound to (lexically) the result of the destructuring.
         ;; Then outside of the helper `let*' form we bind all the
         ;; original variables to their respective placeholders.
         ;; TODO: There is a lot of room for possible optimization,
         ;; for start playing with `special-variable-p' to eliminate
         ;; unnecessary re-binding.
         (variables-to-placeholders
          (-mapcat
           (lambda (bindings)
             (-map
              (lambda (binding)
                (let ((var (car binding)))
                  (list var (make-symbol (concat "--dash-binding-" (symbol-name var) "--")))))
              (--filter (not (string-prefix-p "--" (symbol-name (car it)))) bindings)))
           forms-and-sources)))
    `(let ,(-map 'cadr variables-to-placeholders)
       (let* ,(-flatten-n 1 forms-and-sources)
         (setq ,@(-flatten (-map 'reverse variables-to-placeholders))))
       (setq ,@(-flatten variables-to-placeholders)))))

(defmacro -if-let* (vars-vals then &rest else)
  "If all VALS evaluate to true, bind them to their corresponding
VARS and do THEN, otherwise do ELSE. VARS-VALS should be a list
of (VAR VAL) pairs.

Note: binding is done according to `-let*'.  VALS are evaluated
sequentially, and evaluation stops after the first nil VAL is
encountered."
  (declare (debug ((&rest (sexp form)) form body))
           (indent 2))
  (->> vars-vals
       (--mapcat (dash--match (car it) (cadr it)))
       (--reduce-r-from
        (let ((var (car it))
              (val (cadr it)))
          `(let ((,var ,val))
             (if ,var ,acc ,@else)))
        then)))

(defmacro -if-let (var-val then &rest else)
  "If VAL evaluates to non-nil, bind it to VAR and do THEN,
otherwise do ELSE.

Note: binding is done according to `-let'.

\(fn (VAR VAL) THEN &rest ELSE)"
  (declare (debug ((sexp form) form body))
           (indent 2))
  `(-if-let* (,var-val) ,then ,@else))

(defmacro --if-let (val then &rest else)
  "If VAL evaluates to non-nil, bind it to symbol `it' and do THEN,
otherwise do ELSE."
  (declare (debug (form form body))
           (indent 2))
  `(-if-let (it ,val) ,then ,@else))

(defmacro -when-let* (vars-vals &rest body)
  "If all VALS evaluate to true, bind them to their corresponding
VARS and execute body. VARS-VALS should be a list of (VAR VAL)
pairs.

Note: binding is done according to `-let*'.  VALS are evaluated
sequentially, and evaluation stops after the first nil VAL is
encountered."
  (declare (debug ((&rest (sexp form)) body))
           (indent 1))
  `(-if-let* ,vars-vals (progn ,@body)))

(defmacro -when-let (var-val &rest body)
  "If VAL evaluates to non-nil, bind it to VAR and execute body.

Note: binding is done according to `-let'.

\(fn (VAR VAL) &rest BODY)"
  (declare (debug ((sexp form) body))
           (indent 1))
  `(-if-let ,var-val (progn ,@body)))

(defmacro --when-let (val &rest body)
  "If VAL evaluates to non-nil, bind it to symbol `it' and
execute body."
  (declare (debug (form body))
           (indent 1))
  `(--if-let ,val (progn ,@body)))

;; TODO: Get rid of this dynamic variable, passing it as an argument
;; instead?
(defvar -compare-fn nil
  "Tests for equality use this function, or `equal' if this is nil.

As a dynamic variable, this should be temporarily bound around
the relevant operation, rather than permanently modified.  For
example:

  (let ((-compare-fn #\\='=))
    (-union \\='(1 2 3) \\='(2 3 4)))")

(defun dash--member-fn ()
  "Return the flavor of `member' that goes best with `-compare-fn'."
  (declare (side-effect-free error-free))
  (let ((cmp -compare-fn))
    (cond ((memq cmp '(nil equal)) #'member)
          ((eq cmp #'eq) #'memq)
          ((eq cmp #'eql) #'memql)
          ((lambda (elt list)
             (while (and list (not (funcall cmp elt (car list))))
               (pop list))
             list)))))

(defun dash--assoc-fn ()
  "Return the flavor of `assoc' that goes best with `-compare-fn'."
  (declare (side-effect-free error-free))
  (let ((cmp -compare-fn))
    (cond ((memq cmp '(nil equal)) #'assoc)
          ((eq cmp #'eq) #'assq)
          ;; Since Emacs 26, `assoc' accepts a custom `testfn'.
          ;; Version testing would be simpler here, but feature
          ;; testing gets more brownie points, I guess.
          ((condition-case nil
               (with-no-warnings (assoc nil () #'eql))
             (wrong-number-of-arguments t))
           (lambda (key alist)
             (--first (and (consp it) (funcall cmp (car it) key)) alist)))
          ((with-no-warnings
             (lambda (key alist)
               (assoc key alist cmp)))))))

(defun dash--hash-test-fn ()
  "Return the hash table test function corresponding to `-compare-fn'.
Return nil if `-compare-fn' is not a known test function."
  (declare (side-effect-free error-free))
  ;; In theory this could also recognize values that are custom
  ;; `hash-table-test's, but too often the :test name is different
  ;; from the equality function, so it doesn't seem worthwile.
  (car (memq (or -compare-fn #'equal) '(equal eq eql))))

(defvar dash--short-list-length 32
  "Maximum list length considered short, for optimizations.
For example, the speedup afforded by hash table lookup may start
to outweigh its runtime and memory overhead for problem sizes
greater than this value.  See also the discussion in PR #305.")

(defun -distinct (list)
  "Return a copy of LIST with all duplicate elements removed.

The test for equality is done with `equal', or with `-compare-fn'
if that is non-nil.

Alias: `-uniq'."
  (let (test len)
    (cond ((null list) ())
          ;; Use a hash table if `-compare-fn' is a known hash table
          ;; test function and the list is long enough.
          ((and (setq test (dash--hash-test-fn))
                (> (setq len (length list)) dash--short-list-length))
           (let ((ht (make-hash-table :test test :size len)))
             (--filter (unless (gethash it ht) (puthash it t ht)) list)))
          ((let ((member (dash--member-fn)) uniq)
             (--each list (unless (funcall member it uniq) (push it uniq)))
             (nreverse uniq))))))

(defalias '-uniq #'-distinct)

(defun dash--size+ (size1 size2)
  "Return the sum of nonnegative fixnums SIZE1 and SIZE2.
Return `most-positive-fixnum' on overflow.  This ensures the
result is a valid size, particularly for allocating hash tables,
even in the presence of bignum support."
  (declare (side-effect-free t))
  (if (< size1 (- most-positive-fixnum size2))
      (+ size1 size2)
    most-positive-fixnum))

(defun -union (list1 list2)
  "Return a new list of distinct elements appearing in either LIST1 or LIST2.

The test for equality is done with `equal', or with `-compare-fn'
if that is non-nil."
  (let ((lists (list list1 list2)) test len union)
    (cond ((null (or list1 list2)))
          ;; Use a hash table if `-compare-fn' is a known hash table
          ;; test function and the lists are long enough.
          ((and (setq test (dash--hash-test-fn))
                (> (setq len (dash--size+ (length list1) (length list2)))
                   dash--short-list-length))
           (let ((ht (make-hash-table :test test :size len)))
             (dolist (l lists)
               (--each l (unless (gethash it ht)
                           (puthash it t ht)
                           (push it union))))))
          ((let ((member (dash--member-fn)))
             (dolist (l lists)
               (--each l (unless (funcall member it union) (push it union)))))))
    (nreverse union)))

(defun -intersection (list1 list2)
  "Return a new list of distinct elements appearing in both LIST1 and LIST2.

The test for equality is done with `equal', or with `-compare-fn'
if that is non-nil."
  (let (test len)
    (cond ((null (and list1 list2)) ())
          ;; Use a hash table if `-compare-fn' is a known hash table
          ;; test function and either list is long enough.
          ((and (setq test (dash--hash-test-fn))
                (> (setq len (length list2)) dash--short-list-length))
           (let ((ht (make-hash-table :test test :size len)))
             (--each list2 (puthash it t ht))
             ;; Remove visited elements to avoid duplicates.
             (--filter (when (gethash it ht) (remhash it ht) t) list1)))
          ((let ((member (dash--member-fn)) intersection)
             (--each list1 (and (funcall member it list2)
                                (not (funcall member it intersection))
                                (push it intersection)))
             (nreverse intersection))))))

(defun -difference (list1 list2)
  "Return a new list with the distinct members of LIST1 that are not in LIST2.

The test for equality is done with `equal', or with `-compare-fn'
if that is non-nil."
  (let (test len1 len2)
    (cond ((null list1) ())
          ((null list2) (-distinct list1))
          ;; Use a hash table if `-compare-fn' is a known hash table
          ;; test function and the subtrahend is long enough.
          ((and (setq test (dash--hash-test-fn))
                (setq len1 (length list1))
                (setq len2 (length list2))
                (> (max len1 len2) dash--short-list-length))
           (let ((ht1 (make-hash-table :test test :size len1))
                 (ht2 (make-hash-table :test test :size len2)))
             (--each list2 (puthash it t ht2))
             ;; Avoid duplicates by tracking visited items in `ht1'.
             (--filter (unless (or (gethash it ht2) (gethash it ht1))
                         (puthash it t ht1))
                       list1)))
          ((let ((member (dash--member-fn)) difference)
             (--each list1
               (unless (or (funcall member it list2)
                           (funcall member it difference))
                 (push it difference)))
             (nreverse difference))))))

(defun -powerset (list)
  "Return the power set of LIST."
  (if (null list) (list ())
    (let ((last (-powerset (cdr list))))
      (nconc (mapcar (lambda (x) (cons (car list) x)) last)
             last))))

(defun -frequencies (list)
  "Count the occurrences of each distinct element of LIST.

Return an alist of (ELEMENT . N), where each ELEMENT occurs N
times in LIST.

The test for equality is done with `equal', or with `-compare-fn'
if that is non-nil.

See also `-count' and `-group-by'."
  (let (test len freqs)
    (cond ((null list))
          ((and (setq test (dash--hash-test-fn))
                (> (setq len (length list)) dash--short-list-length))
           (let ((ht (make-hash-table :test test :size len)))
             ;; Share structure between hash table and returned list.
             ;; This affords a single pass that preserves the input
             ;; order, conses less garbage, and is faster than a
             ;; second traversal (e.g., with `maphash').
             (--each list
               (let ((freq (gethash it ht)))
                 (if freq
                     (setcdr freq (1+ (cdr freq)))
                   (push (puthash it (cons it 1) ht) freqs))))))
          ((let ((assoc (dash--assoc-fn)))
             (--each list
               (let ((freq (funcall assoc it freqs)))
                 (if freq
                     (setcdr freq (1+ (cdr freq)))
                   (push (cons it 1) freqs)))))))
    (nreverse freqs)))

(defun dash--numbers<= (nums)
  "Return non-nil if NUMS is a list of non-decreasing numbers."
  (declare (pure t) (side-effect-free t))
  (or (null nums)
      (let ((prev (pop nums)))
        (and (numberp prev)
             (--every (and (numberp it) (<= prev (setq prev it))) nums)))))

(defun dash--next-lex-perm (array n)
  "Update ARRAY of N numbers with its next lexicographic permutation.
Return nil if there is no such successor.  N should be nonzero.

This implements the salient steps of Algorithm L (Lexicographic
permutation generation) as described in DE Knuth's The Art of
Computer Programming, Volume 4A / Combinatorial Algorithms,
Part I, Addison-Wesley, 2011, § 7.2.1.2, p. 319."
  (setq n (1- n))
  (let* ((l n)
         (j (1- n))
         (al (aref array n))
         (aj al))
    ;; L2. [Find j].
    ;; Decrement j until a[j] < a[j+1].
    (while (and (<= 0 j)
                (<= aj (setq aj (aref array j))))
      (setq j (1- j)))
    ;; Terminate algorithm if j not found.
    (when (>= j 0)
      ;; L3. [Increase a[j]].
      ;; Decrement l until a[j] < a[l].
      (while (>= aj al)
        (setq l (1- l) al (aref array l)))
      ;; Swap a[j] and a[l].
      (aset array j al)
      (aset array l aj)
      ;; L4. [Reverse a[j+1]...a[n]].
      (setq l n)
      (while (< (setq j (1+ j)) l)
        (setq aj (aref array j))
        (aset array j (aref array l))
        (aset array l aj)
        (setq l (1- l)))
      array)))

(defun dash--lex-perms (vec &optional original)
  "Return a list of permutations of VEC in lexicographic order.
Specifically, return only the successors of VEC in lexicographic
order.  Each returned permutation is a list.  VEC should comprise
one or more numbers, and may be destructively modified.

If ORIGINAL is a vector, then VEC is interpreted as a set of
indices into ORIGINAL.  In this case, the indices are permuted,
and the resulting index permutations are used to dereference
elements of ORIGINAL."
  (let ((len (length vec)) perms)
    (while vec
      (push (if original
                (--map (aref original it) vec)
              (append vec ()))
            perms)
      (setq vec (dash--next-lex-perm vec len)))
    (nreverse perms)))

(defun dash--uniq-perms (list)
  "Return a list of permutations of LIST.
LIST is treated as if all its elements are distinct."
  (let* ((vec (vconcat list))
         (idxs (copy-sequence vec)))
    ;; Just construct a vector of the list's indices and permute that.
    (dotimes (i (length idxs))
      (aset idxs i i))
    (dash--lex-perms idxs vec)))

(defun dash--multi-perms (list freqs)
  "Return a list of permutations of the multiset LIST.
FREQS should be an alist describing the frequency of each element
in LIST, as returned by `-frequencies'."
  (let (;; Distinct items in `list', aka the cars of `freqs'.
        (uniq (make-vector (length freqs) nil))
        ;; Indices into `uniq'.
        (idxs (make-vector (length list) nil))
        ;; Current index into `idxs'.
        (i 0))
    (--each freqs
      (aset uniq it-index (car it))
      ;; Populate `idxs' with as many copies of each `it-index' as
      ;; there are corresponding duplicates.
      (dotimes (_ (cdr it))
        (aset idxs i it-index)
        (setq i (1+ i))))
    (dash--lex-perms idxs uniq)))

(defun -permutations (list)
  "Return the distinct permutations of LIST.

Duplicate elements of LIST are determined by `equal', or by
`-compare-fn' if that is non-nil."
  (cond ((null list) (list ()))
        ;; Optimization: a traversal of `list' is faster than the
        ;; round trip via `dash--uniq-perms' or `dash--multi-perms'.
        ((dash--numbers<= list)
         (dash--lex-perms (vconcat list)))
        ((let ((freqs (-frequencies list)))
           ;; Is each element distinct?
           (unless (--every (= (cdr it) 1) freqs)
             (dash--multi-perms list freqs))))
        ((dash--uniq-perms list))))

(defun -inits (list)
  "Return all prefixes of LIST."
  (let ((res (list list)))
    (setq list (reverse list))
    (while list
      (push (reverse (!cdr list)) res))
    res))

(defun -tails (list)
  "Return all suffixes of LIST"
  (-reductions-r-from 'cons nil list))

(defun -common-prefix (&rest lists)
  "Return the longest common prefix of LISTS."
  (declare (pure t) (side-effect-free t))
  (--reduce (--take-while (and acc (equal (pop acc) it)) it)
            lists))

(defun -common-suffix (&rest lists)
  "Return the longest common suffix of LISTS."
  (nreverse (apply #'-common-prefix (mapcar #'reverse lists))))

(defun -contains? (list element)
  "Return non-nil if LIST contains ELEMENT.

The test for equality is done with `equal', or with `-compare-fn'
if that is non-nil.  As with `member', the return value is
actually the tail of LIST whose car is ELEMENT.

Alias: `-contains-p'."
  (funcall (dash--member-fn) element list))

(defalias '-contains-p #'-contains?)

(defun -same-items? (list1 list2)
  "Return non-nil if LIST1 and LIST2 have the same distinct elements.

The order of the elements in the lists does not matter.  The
lists may be of different lengths, i.e., contain duplicate
elements.  The test for equality is done with `equal', or with
`-compare-fn' if that is non-nil.

Alias: `-same-items-p'."
  (let (test len1 len2)
    (cond ((null (or list1 list2)))
          ((null (and list1 list2)) nil)
          ;; Use a hash table if `-compare-fn' is a known hash table
          ;; test function and either list is long enough.
          ((and (setq test (dash--hash-test-fn))
                (setq len1 (length list1))
                (setq len2 (length list2))
                (> (max len1 len2) dash--short-list-length))
           (let ((ht1 (make-hash-table :test test :size len1))
                 (ht2 (make-hash-table :test test :size len2)))
             (--each list1 (puthash it t ht1))
             ;; Move visited elements from `ht1' to `ht2'.  This way,
             ;; if visiting all of `list2' leaves `ht1' empty, then
             ;; all elements from both lists have been accounted for.
             (and (--every (cond ((gethash it ht1)
                                  (remhash it ht1)
                                  (puthash it t ht2))
                                 ((gethash it ht2)))
                           list2)
                  (zerop (hash-table-count ht1)))))
          ((let ((member (dash--member-fn)))
             (and (--all? (funcall member it list2) list1)
                  (--all? (funcall member it list1) list2)))))))

(defalias '-same-items-p #'-same-items?)

(defun -is-prefix? (prefix list)
  "Return non-nil if PREFIX is a prefix of LIST.

Alias: `-is-prefix-p'."
  (declare (pure t) (side-effect-free t))
  (--each-while list (and (equal (car prefix) it)
                          (!cdr prefix)))
  (null prefix))

(defun -is-suffix? (suffix list)
  "Return non-nil if SUFFIX is a suffix of LIST.

Alias: `-is-suffix-p'."
  (declare (pure t) (side-effect-free t))
  (equal suffix (last list (length suffix))))

(defun -is-infix? (infix list)
  "Return non-nil if INFIX is infix of LIST.

This operation runs in O(n^2) time

Alias: `-is-infix-p'"
  (declare (pure t) (side-effect-free t))
  (let (done)
    (while (and (not done) list)
      (setq done (-is-prefix? infix list))
      (!cdr list))
    done))

(defalias '-is-prefix-p '-is-prefix?)
(defalias '-is-suffix-p '-is-suffix?)
(defalias '-is-infix-p '-is-infix?)

(defun -sort (comparator list)
  "Sort LIST, stably, comparing elements using COMPARATOR.
Return the sorted list.  LIST is NOT modified by side effects.
COMPARATOR is called with two elements of LIST, and should return non-nil
if the first element should sort before the second."
  (sort (copy-sequence list) comparator))

(defmacro --sort (form list)
  "Anaphoric form of `-sort'."
  (declare (debug (def-form form)))
  `(-sort (lambda (it other) (ignore it other) ,form) ,list))

(defun -list (&optional arg &rest args)
  "Ensure ARG is a list.
If ARG is already a list, return it as is (not a copy).
Otherwise, return a new list with ARG as its only element.

Another supported calling convention is (-list &rest ARGS).
In this case, if ARG is not a list, a new list with all of
ARGS as elements is returned.  This use is supported for
backward compatibility and is otherwise deprecated."
  (declare (advertised-calling-convention (arg) "2.18.0")
           (pure t) (side-effect-free error-free))
  (if (listp arg) arg (cons arg args)))

(defun -repeat (n x)
  "Return a new list of length N with each element being X.
Return nil if N is less than 1."
  (declare (pure t) (side-effect-free t))
  (and (>= n 0) (make-list n x)))

(defun -sum (list)
  "Return the sum of LIST."
  (declare (pure t) (side-effect-free t))
  (apply '+ list))

(defun -running-sum (list)
  "Return a list with running sums of items in LIST.
LIST must be non-empty."
  (declare (pure t) (side-effect-free t))
  (or list (signal 'wrong-type-argument (list #'consp list)))
  (-reductions #'+ list))

(defun -product (list)
  "Return the product of LIST."
  (declare (pure t) (side-effect-free t))
  (apply '* list))

(defun -running-product (list)
  "Return a list with running products of items in LIST.
LIST must be non-empty."
  (declare (pure t) (side-effect-free t))
  (or list (signal 'wrong-type-argument (list #'consp list)))
  (-reductions #'* list))

(defun -max (list)
  "Return the largest value from LIST of numbers or markers."
  (declare (pure t) (side-effect-free t))
  (apply 'max list))

(defun -min (list)
  "Return the smallest value from LIST of numbers or markers."
  (declare (pure t) (side-effect-free t))
  (apply 'min list))

(defun -max-by (comparator list)
  "Take a comparison function COMPARATOR and a LIST and return
the greatest element of the list by the comparison function.

See also combinator `-on' which can transform the values before
comparing them."
  (--reduce (if (funcall comparator it acc) it acc) list))

(defun -min-by (comparator list)
  "Take a comparison function COMPARATOR and a LIST and return
the least element of the list by the comparison function.

See also combinator `-on' which can transform the values before
comparing them."
  (--reduce (if (funcall comparator it acc) acc it) list))

(defmacro --max-by (form list)
  "Anaphoric version of `-max-by'.

The items for the comparator form are exposed as \"it\" and \"other\"."
  (declare (debug (def-form form)))
  `(-max-by (lambda (it other) (ignore it other) ,form) ,list))

(defmacro --min-by (form list)
  "Anaphoric version of `-min-by'.

The items for the comparator form are exposed as \"it\" and \"other\"."
  (declare (debug (def-form form)))
  `(-min-by (lambda (it other) (ignore it other) ,form) ,list))

(defun -iota (count &optional start step)
  "Return a list containing COUNT numbers.
Starts from START and adds STEP each time.  The default START is
zero, the default STEP is 1.
This function takes its name from the corresponding primitive in
the APL language."
  (declare (pure t) (side-effect-free t))
  (unless (natnump count)
    (signal 'wrong-type-argument (list #'natnump count)))
  (or start (setq start 0))
  (or step (setq step 1))
  (if (zerop step)
      (make-list count start)
    (--iterate (+ it step) start count)))

(defun -fix (fn list)
  "Compute the (least) fixpoint of FN with initial input LIST.

FN is called at least once, results are compared with `equal'."
  (let ((re (funcall fn list)))
    (while (not (equal list re))
      (setq list re)
      (setq re (funcall fn re)))
    re))

(defmacro --fix (form list)
  "Anaphoric form of `-fix'."
  (declare (debug (def-form form)))
  `(-fix (lambda (it) (ignore it) ,form) ,list))

(defun -unfold (fun seed)
  "Build a list from SEED using FUN.

This is \"dual\" operation to `-reduce-r': while -reduce-r
consumes a list to produce a single value, `-unfold' takes a
seed value and builds a (potentially infinite!) list.

FUN should return nil to stop the generating process, or a
cons (A . B), where A will be prepended to the result and B is
the new seed."
  (let ((last (funcall fun seed)) r)
    (while last
      (push (car last) r)
      (setq last (funcall fun (cdr last))))
    (nreverse r)))

(defmacro --unfold (form seed)
  "Anaphoric version of `-unfold'."
  (declare (debug (def-form form)))
  `(-unfold (lambda (it) (ignore it) ,form) ,seed))

(defun -cons-pair? (obj)
  "Return non-nil if OBJ is a true cons pair.
That is, a cons (A . B) where B is not a list.

Alias: `-cons-pair-p'."
  (declare (pure t) (side-effect-free error-free))
  (nlistp (cdr-safe obj)))

(defalias '-cons-pair-p '-cons-pair?)

(defun -cons-to-list (con)
  "Convert a cons pair to a list with `car' and `cdr' of the pair respectively."
  (declare (pure t) (side-effect-free t))
  (list (car con) (cdr con)))

(defun -value-to-list (val)
  "Convert a value to a list.

If the value is a cons pair, make a list with two elements, `car'
and `cdr' of the pair respectively.

If the value is anything else, wrap it in a list."
  (declare (pure t) (side-effect-free t))
  (if (-cons-pair? val) (-cons-to-list val) (list val)))

(defun -tree-mapreduce-from (fn folder init-value tree)
  "Apply FN to each element of TREE, and make a list of the results.
If elements of TREE are lists themselves, apply FN recursively to
elements of these nested lists.

Then reduce the resulting lists using FOLDER and initial value
INIT-VALUE. See `-reduce-r-from'.

This is the same as calling `-tree-reduce-from' after `-tree-map'
but is twice as fast as it only traverse the structure once."
  (cond
   ((null tree) ())
   ((-cons-pair? tree) (funcall fn tree))
   ((consp tree)
    (-reduce-r-from
     folder init-value
     (mapcar (lambda (x) (-tree-mapreduce-from fn folder init-value x)) tree)))
   ((funcall fn tree))))

(defmacro --tree-mapreduce-from (form folder init-value tree)
  "Anaphoric form of `-tree-mapreduce-from'."
  (declare (debug (def-form def-form form form)))
  `(-tree-mapreduce-from (lambda (it) (ignore it) ,form)
                         (lambda (it acc) (ignore it acc) ,folder)
                         ,init-value
                         ,tree))

(defun -tree-mapreduce (fn folder tree)
  "Apply FN to each element of TREE, and make a list of the results.
If elements of TREE are lists themselves, apply FN recursively to
elements of these nested lists.

Then reduce the resulting lists using FOLDER and initial value
INIT-VALUE. See `-reduce-r-from'.

This is the same as calling `-tree-reduce' after `-tree-map'
but is twice as fast as it only traverse the structure once."
  (cond
   ((null tree) ())
   ((-cons-pair? tree) (funcall fn tree))
   ((consp tree)
    (-reduce-r folder (mapcar (lambda (x) (-tree-mapreduce fn folder x)) tree)))
   ((funcall fn tree))))

(defmacro --tree-mapreduce (form folder tree)
  "Anaphoric form of `-tree-mapreduce'."
  (declare (debug (def-form def-form form)))
  `(-tree-mapreduce (lambda (it) (ignore it) ,form)
                    (lambda (it acc) (ignore it acc) ,folder)
                    ,tree))

(defun -tree-map (fn tree)
  "Apply FN to each element of TREE while preserving the tree structure."
  (cond
   ((null tree) ())
   ((-cons-pair? tree) (funcall fn tree))
   ((consp tree)
    (mapcar (lambda (x) (-tree-map fn x)) tree))
   ((funcall fn tree))))

(defmacro --tree-map (form tree)
  "Anaphoric form of `-tree-map'."
  (declare (debug (def-form form)))
  `(-tree-map (lambda (it) (ignore it) ,form) ,tree))

(defun -tree-reduce-from (fn init-value tree)
  "Use FN to reduce elements of list TREE.
If elements of TREE are lists themselves, apply the reduction recursively.

FN is first applied to INIT-VALUE and first element of the list,
then on this result and second element from the list etc.

The initial value is ignored on cons pairs as they always contain
two elements."
  (cond
   ((null tree) ())
   ((-cons-pair? tree) tree)
   ((consp tree)
    (-reduce-r-from
     fn init-value
     (mapcar (lambda (x) (-tree-reduce-from fn init-value x)) tree)))
   (tree)))

(defmacro --tree-reduce-from (form init-value tree)
  "Anaphoric form of `-tree-reduce-from'."
  (declare (debug (def-form form form)))
  `(-tree-reduce-from (lambda (it acc) (ignore it acc) ,form)
                      ,init-value ,tree))

(defun -tree-reduce (fn tree)
  "Use FN to reduce elements of list TREE.
If elements of TREE are lists themselves, apply the reduction recursively.

FN is first applied to first element of the list and second
element, then on this result and third element from the list etc.

See `-reduce-r' for how exactly are lists of zero or one element handled."
  (cond
   ((null tree) ())
   ((-cons-pair? tree) tree)
   ((consp tree)
    (-reduce-r fn (mapcar (lambda (x) (-tree-reduce fn x)) tree)))
   (tree)))

(defmacro --tree-reduce (form tree)
  "Anaphoric form of `-tree-reduce'."
  (declare (debug (def-form form)))
  `(-tree-reduce (lambda (it acc) (ignore it acc) ,form) ,tree))

(defun -tree-map-nodes (pred fun tree)
  "Call FUN on each node of TREE that satisfies PRED.

If PRED returns nil, continue descending down this node.  If PRED
returns non-nil, apply FUN to this node and do not descend
further."
  (cond ((funcall pred tree) (funcall fun tree))
        ((and (listp tree) (listp (cdr tree)))
         (-map (lambda (x) (-tree-map-nodes pred fun x)) tree))
        (tree)))

(defmacro --tree-map-nodes (pred form tree)
  "Anaphoric form of `-tree-map-nodes'."
  (declare (debug (def-form def-form form)))
  `(-tree-map-nodes (lambda (it) (ignore it) ,pred)
                    (lambda (it) (ignore it) ,form)
                    ,tree))

(defun -tree-seq (branch children tree)
  "Return a sequence of the nodes in TREE, in depth-first search order.

BRANCH is a predicate of one argument that returns non-nil if the
passed argument is a branch, that is, a node that can have children.

CHILDREN is a function of one argument that returns the children
of the passed branch node.

Non-branch nodes are simply copied."
  (cons tree
        (and (funcall branch tree)
             (-mapcat (lambda (x) (-tree-seq branch children x))
                      (funcall children tree)))))

(defmacro --tree-seq (branch children tree)
  "Anaphoric form of `-tree-seq'."
  (declare (debug (def-form def-form form)))
  `(-tree-seq (lambda (it) (ignore it) ,branch)
              (lambda (it) (ignore it) ,children)
              ,tree))

(defun -clone (list)
  "Create a deep copy of LIST.
The new list has the same elements and structure but all cons are
replaced with new ones.  This is useful when you need to clone a
structure such as plist or alist."
  (declare (pure t) (side-effect-free t))
  (-tree-map #'identity list))

;;; Combinators

(defalias '-partial #'apply-partially)

(defun -rpartial (fn &rest args)
  "Return a function that is a partial application of FN to ARGS.
ARGS is a list of the last N arguments to pass to FN.  The result
is a new function which does the same as FN, except that the last
N arguments are fixed at the values with which this function was
called.  This is like `-partial', except the arguments are fixed
starting from the right rather than the left."
  (declare (pure t) (side-effect-free error-free))
  (lambda (&rest args-before) (apply fn (append args-before args))))

(defun -juxt (&rest fns)
  "Return a function that is the juxtaposition of FNS.
The returned function takes a variable number of ARGS, applies
each of FNS in turn to ARGS, and returns the list of results."
  (declare (pure t) (side-effect-free error-free))
  (lambda (&rest args) (mapcar (lambda (x) (apply x args)) fns)))

(defun -compose (&rest fns)
  "Compose FNS into a single composite function.
Return a function that takes a variable number of ARGS, applies
the last function in FNS to ARGS, and returns the result of
calling each remaining function on the result of the previous
function, right-to-left.  If no FNS are given, return a variadic
`identity' function."
  (declare (pure t) (side-effect-free error-free))
  (let* ((fns (nreverse fns))
         (head (car fns))
         (tail (cdr fns)))
    (cond (tail
           (lambda (&rest args)
             (--reduce-from (funcall it acc) (apply head args) tail)))
          (fns head)
          ((lambda (&optional arg &rest _) arg)))))

(defun -applify (fn)
  "Return a function that applies FN to a single list of args.
This changes the arity of FN from taking N distinct arguments to
taking 1 argument which is a list of N arguments."
  (declare (pure t) (side-effect-free error-free))
  (lambda (args) (apply fn args)))

(defun -on (op trans)
  "Return a function that calls TRANS on each arg and OP on the results.
The returned function takes a variable number of arguments, calls
the function TRANS on each one in turn, and then passes those
results as the list of arguments to OP, in the same order.

For example, the following pairs of expressions are morally
equivalent:

  (funcall (-on #\\='+ #\\='1+) 1 2 3) = (+ (1+ 1) (1+ 2) (1+ 3))
  (funcall (-on #\\='+ #\\='1+))       = (+)"
  (declare (pure t) (side-effect-free error-free))
  (lambda (&rest args)
    ;; This unrolling seems to be a relatively cheap way to keep the
    ;; overhead of `mapcar' + `apply' in check.
    (cond ((cddr args)
           (apply op (mapcar trans args)))
          ((cdr args)
           (funcall op (funcall trans (car args)) (funcall trans (cadr args))))
          (args
           (funcall op (funcall trans (car args))))
          ((funcall op)))))

(defun -flip (fn)
  "Return a function that calls FN with its arguments reversed.
The returned function takes the same number of arguments as FN.

For example, the following two expressions are morally
equivalent:

  (funcall (-flip #\\='-) 1 2) = (- 2 1)

See also: `-rotate-args'."
  (declare (pure t) (side-effect-free error-free))
  (lambda (&rest args) ;; Open-code for speed.
    (cond ((cddr args) (apply fn (nreverse args)))
          ((cdr args) (funcall fn (cadr args) (car args)))
          (args (funcall fn (car args)))
          ((funcall fn)))))

(defun -rotate-args (n fn)
  "Return a function that calls FN with args rotated N places to the right.
The returned function takes the same number of arguments as FN,
rotates the list of arguments N places to the right (left if N is
negative) just like `-rotate', and applies FN to the result.

See also: `-flip'."
  (declare (pure t) (side-effect-free t))
  (if (zerop n)
      fn
    (let ((even (= (% n 2) 0)))
      (lambda (&rest args)
        (cond ((cddr args) ;; Open-code for speed.
               (apply fn (-rotate n args)))
              ((cdr args)
               (let ((fst (car args))
                     (snd (cadr args)))
                 (funcall fn (if even fst snd) (if even snd fst))))
              (args
               (funcall fn (car args)))
              ((funcall fn)))))))

(defun -const (c)
  "Return a function that returns C ignoring any additional arguments.

In types: a -> b -> a"
  (declare (pure t) (side-effect-free error-free))
  (lambda (&rest _) c))

(defmacro -cut (&rest params)
  "Take n-ary function and n arguments and specialize some of them.
Arguments denoted by <> will be left unspecialized.

See SRFI-26 for detailed description."
  (declare (debug (&optional sexp &rest &or "<>" form)))
  (let* ((i 0)
         (args (--keep (when (eq it '<>)
                         (setq i (1+ i))
                         (make-symbol (format "D%d" i)))
                       params)))
    `(lambda ,args
       ,(let ((body (--map (if (eq it '<>) (pop args) it) params)))
          (if (eq (car params) '<>)
              (cons #'funcall body)
            body)))))

(defun -not (pred)
  "Return a predicate that negates the result of PRED.
The returned predicate passes its arguments to PRED.  If PRED
returns nil, the result is non-nil; otherwise the result is nil.

See also: `-andfn' and `-orfn'."
  (declare (pure t) (side-effect-free error-free))
  (lambda (&rest args) (not (apply pred args))))

(defun -orfn (&rest preds)
  "Return a predicate that returns the first non-nil result of PREDS.
The returned predicate takes a variable number of arguments,
passes them to each predicate in PREDS in turn until one of them
returns non-nil, and returns that non-nil result without calling
the remaining PREDS.  If all PREDS return nil, or if no PREDS are
given, the returned predicate returns nil.

See also: `-andfn' and `-not'."
  (declare (pure t) (side-effect-free error-free))
  ;; Open-code for speed.
  (cond ((cdr preds) (lambda (&rest args) (--some (apply it args) preds)))
        (preds (car preds))
        (#'ignore)))

(defun -andfn (&rest preds)
  "Return a predicate that returns non-nil if all PREDS do so.
The returned predicate P takes a variable number of arguments and
passes them to each predicate in PREDS in turn.  If any one of
PREDS returns nil, P also returns nil without calling the
remaining PREDS.  If all PREDS return non-nil, P returns the last
such value.  If no PREDS are given, P always returns non-nil.

See also: `-orfn' and `-not'."
  (declare (pure t) (side-effect-free error-free))
  ;; Open-code for speed.
  (cond ((cdr preds) (lambda (&rest args) (--every (apply it args) preds)))
        (preds (car preds))
        ;; As a `pure' function, this runtime check may generate
        ;; backward-incompatible bytecode for `(-andfn)' at compile-time,
        ;; but I doubt that's a problem in practice (famous last words).
        ((fboundp 'always) #'always)
        ((lambda (&rest _) t))))

(defun -iteratefn (fn n)
  "Return a function FN composed N times with itself.

FN is a unary function.  If you need to use a function of higher
arity, use `-applify' first to turn it into a unary function.

With n = 0, this acts as identity function.

In types: (a -> a) -> Int -> a -> a.

This function satisfies the following law:

  (funcall (-iteratefn fn n) init) = (-last-item (-iterate fn init (1+ n)))."
  (lambda (x) (--dotimes n (setq x (funcall fn x))) x))

(defun -counter (&optional beg end inc)
  "Return a closure that counts from BEG to END, with increment INC.

The closure will return the next value in the counting sequence
each time it is called, and nil after END is reached. BEG
defaults to 0, INC defaults to 1, and if END is nil, the counter
will increment indefinitely.

The closure accepts any number of arguments, which are discarded."
  (let ((inc (or inc 1))
        (n (or beg 0)))
    (lambda (&rest _)
      (when (or (not end) (< n end))
        (prog1 n
          (setq n (+ n inc)))))))

(defvar -fixfn-max-iterations 1000
  "The default maximum number of iterations performed by `-fixfn'
  unless otherwise specified.")

(defun -fixfn (fn &optional equal-test halt-test)
  "Return a function that computes the (least) fixpoint of FN.

FN must be a unary function. The returned lambda takes a single
argument, X, the initial value for the fixpoint iteration. The
iteration halts when either of the following conditions is satisfied:

 1. Iteration converges to the fixpoint, with equality being
    tested using EQUAL-TEST. If EQUAL-TEST is not specified,
    `equal' is used. For functions over the floating point
    numbers, it may be necessary to provide an appropriate
    approximate comparison test.

 2. HALT-TEST returns a non-nil value. HALT-TEST defaults to a
    simple counter that returns t after `-fixfn-max-iterations',
    to guard against infinite iteration. Otherwise, HALT-TEST
    must be a function that accepts a single argument, the
    current value of X, and returns non-nil as long as iteration
    should continue. In this way, a more sophisticated
    convergence test may be supplied by the caller.

The return value of the lambda is either the fixpoint or, if
iteration halted before converging, a cons with car `halted' and
cdr the final output from HALT-TEST.

In types: (a -> a) -> a -> a."
  (let ((eqfn   (or equal-test 'equal))
        (haltfn (or halt-test
                    (-not
                     (-counter 0 -fixfn-max-iterations)))))
    (lambda (x)
      (let ((re (funcall fn x))
            (halt? (funcall haltfn x)))
        (while (and (not halt?) (not (funcall eqfn x re)))
          (setq x     re
                re    (funcall fn re)
                halt? (funcall haltfn re)))
        (if halt? (cons 'halted halt?)
          re)))))

(defun -prodfn (&rest fns)
  "Return a function that applies each of FNS to each of a list of arguments.

Takes a list of N functions and returns a function that takes a
list of length N, applying Ith function to Ith element of the
input list.  Returns a list of length N.

In types (for N=2): ((a -> b), (c -> d)) -> (a, c) -> (b, d)

This function satisfies the following laws:

    (-compose (-prodfn f g ...)
              (-prodfn f\\=' g\\=' ...))
  = (-prodfn (-compose f f\\=')
             (-compose g g\\=')
             ...)

    (-prodfn f g ...)
  = (-juxt (-compose f (-partial #\\='nth 0))
           (-compose g (-partial #\\='nth 1))
           ...)

    (-compose (-prodfn f g ...)
              (-juxt f\\=' g\\=' ...))
  = (-juxt (-compose f f\\=')
           (-compose g g\\=')
           ...)

    (-compose (-partial #\\='nth n)
              (-prod f1 f2 ...))
  = (-compose fn (-partial #\\='nth n))"
  (lambda (x) (-zip-with 'funcall fns x)))

;;; Font lock

(defvar dash--keywords
  `(;; TODO: Do not fontify the following automatic variables
    ;; globally; detect and limit to their local anaphoric scope.
    (,(rx symbol-start (| "acc" "it" "it-index" "other") symbol-end)
     0 font-lock-variable-name-face)
    ;; Macros in dev/examples.el.  Based on `lisp-mode-symbol-regexp'.
    (,(rx ?\( (group (| "defexamples" "def-example-group")) symbol-end
          (+ (in "\t "))
          (group (* (| (syntax word) (syntax symbol) (: ?\\ nonl)))))
     (1 font-lock-keyword-face)
     (2 font-lock-function-name-face))
    ;; Symbols in dev/examples.el.
    ,(rx symbol-start (| "=>" "~>" "!!>") symbol-end)
    ;; Elisp macro fontification was static prior to Emacs 25.
    ,@(when (< emacs-major-version 25)
        (let ((macs '("!cdr"
                      "!cons"
                      "-->"
                      "--all?"
                      "--annotate"
                      "--any?"
                      "--count"
                      "--dotimes"
                      "--doto"
                      "--drop-while"
                      "--each"
                      "--each-r"
                      "--each-r-while"
                      "--each-while"
                      "--filter"
                      "--find-index"
                      "--find-indices"
                      "--find-last-index"
                      "--first"
                      "--fix"
                      "--group-by"
                      "--if-let"
                      "--iterate"
                      "--keep"
                      "--last"
                      "--map"
                      "--map-first"
                      "--map-indexed"
                      "--map-last"
                      "--map-when"
                      "--mapcat"
                      "--max-by"
                      "--min-by"
                      "--none?"
                      "--only-some?"
                      "--partition-by"
                      "--partition-by-header"
                      "--reduce"
                      "--reduce-from"
                      "--reduce-r"
                      "--reduce-r-from"
                      "--reductions"
                      "--reductions-from"
                      "--reductions-r"
                      "--reductions-r-from"
                      "--remove"
                      "--remove-first"
                      "--remove-last"
                      "--separate"
                      "--some"
                      "--sort"
                      "--splice"
                      "--splice-list"
                      "--split-when"
                      "--split-with"
                      "--take-while"
                      "--tree-map"
                      "--tree-map-nodes"
                      "--tree-mapreduce"
                      "--tree-mapreduce-from"
                      "--tree-reduce"
                      "--tree-reduce-from"
                      "--tree-seq"
                      "--unfold"
                      "--update-at"
                      "--when-let"
                      "--zip-with"
                      "->"
                      "->>"
                      "-as->"
                      "-doto"
                      "-if-let"
                      "-if-let*"
                      "-lambda"
                      "-let"
                      "-let*"
                      "-setq"
                      "-some-->"
                      "-some->"
                      "-some->>"
                      "-split-on"
                      "-when-let"
                      "-when-let*")))
          `((,(concat "(" (regexp-opt macs 'symbols)) . 1)))))
  "Font lock keywords for `dash-fontify-mode'.")

(defcustom dash-fontify-mode-lighter nil
  "Mode line lighter for `dash-fontify-mode'.
Either a string to display in the mode line when
`dash-fontify-mode' is on, or nil to display
nothing (the default)."
  :package-version '(dash . "2.18.0")
  :group 'dash
  :type '(choice (string :tag "Lighter" :value " Dash")
                 (const :tag "Nothing" nil)))

;;;###autoload
(define-minor-mode dash-fontify-mode
  "Toggle fontification of Dash special variables.

Dash-Fontify mode is a buffer-local minor mode intended for Emacs
Lisp buffers.  Enabling it causes the special variables bound in
anaphoric Dash macros to be fontified.  These anaphoras include
`it', `it-index', `acc', and `other'.  In older Emacs versions
which do not dynamically detect macros, Dash-Fontify mode
additionally fontifies Dash macro calls.

See also `dash-fontify-mode-lighter' and
`global-dash-fontify-mode'."
  :group 'dash :lighter dash-fontify-mode-lighter
  (if dash-fontify-mode
      (font-lock-add-keywords nil dash--keywords t)
    (font-lock-remove-keywords nil dash--keywords))
  (cond ((fboundp 'font-lock-flush) ;; Added in Emacs 25.
         (font-lock-flush))
        ;; `font-lock-fontify-buffer' unconditionally enables
        ;; `font-lock-mode' and is marked `interactive-only' in later
        ;; Emacs versions which have `font-lock-flush', so we guard
        ;; and pacify as needed, respectively.
        (font-lock-mode
         (with-no-warnings
           (font-lock-fontify-buffer)))))

(defun dash--turn-on-fontify-mode ()
  "Enable `dash-fontify-mode' if in an Emacs Lisp buffer."
  (when (derived-mode-p #'emacs-lisp-mode)
    (dash-fontify-mode)))

;;;###autoload
(define-globalized-minor-mode global-dash-fontify-mode
  dash-fontify-mode dash--turn-on-fontify-mode
  :group 'dash)

(defcustom dash-enable-fontlock nil
  "If non-nil, fontify Dash macro calls and special variables."
  :group 'dash
  :set (lambda (sym val)
         (set-default sym val)
         (global-dash-fontify-mode (if val 1 0)))
  :type 'boolean)

(make-obsolete-variable
 'dash-enable-fontlock #'global-dash-fontify-mode "2.18.0")

(define-obsolete-function-alias
  'dash-enable-font-lock #'global-dash-fontify-mode "2.18.0")

;;; Info

(defvar dash--info-doc-spec '("(dash) Index" nil "^ -+ .*: " "\\( \\|$\\)")
  "The Dash :doc-spec entry for `info-lookup-alist'.
It is based on that for `emacs-lisp-mode'.")

(defun dash--info-elisp-docs ()
  "Return the `emacs-lisp-mode' symbol docs from `info-lookup-alist'.
Specifically, return the cons containing their
`info-lookup->doc-spec' so that we can modify it."
  (defvar info-lookup-alist)
  (nthcdr 3 (assq #'emacs-lisp-mode (cdr (assq 'symbol info-lookup-alist)))))

;;;###autoload
(defun dash-register-info-lookup ()
  "Register the Dash Info manual with `info-lookup-symbol'.
This allows Dash symbols to be looked up with \\[info-lookup-symbol]."
  (interactive)
  (require 'info-look)
  (let ((docs (dash--info-elisp-docs)))
    (setcar docs (append (car docs) (list dash--info-doc-spec)))
    (info-lookup-reset)))

(defun dash-unload-function ()
  "Remove Dash from `info-lookup-alist'.
Used by `unload-feature', which see."
  (let ((docs (and (featurep 'info-look)
                   (dash--info-elisp-docs))))
    (when (member dash--info-doc-spec (car docs))
      (setcar docs (remove dash--info-doc-spec (car docs)))
      (info-lookup-reset)))
  nil)

(provide 'dash)
;;; dash.el ends here
#+end_src

** f.el

Taken from [[https://github.com/rejeep/f.el/blob/master/f.el][here]]:

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; f.el --- Modern API for working with files and directories -*- lexical-binding: t; -*-

;; Copyright (C) 2013 Johan Andersson

;; Author: Johan Andersson <johan.rejeep@gmail.com>
;; Maintainer: Lucien Cartier-Tilet <lucien@phundrak.com>
;; Version: 0.20.0
;; Package-Requires: ((emacs "24.1") (s "1.7.0") (dash "2.2.0"))
;; Keywords: files, directories
;; Homepage: http://github.com/rejeep/f.el

;; This file is NOT part of GNU Emacs.

;;; License:

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.

;;; Code:



(require 's)
(require 'dash)
(when (version<= "28.1" emacs-version)
  (require 'f-shortdoc))

(put 'f-guard-error 'error-conditions '(error f-guard-error))
(put 'f-guard-error 'error-message "Destructive operation outside sandbox")

(defvar f--guard-paths nil
  "List of allowed paths to modify when guarded.

Do not modify this variable.")

(defmacro f--destructive (path &rest body)
  "If PATH is allowed to be modified, yield BODY.

If PATH is not allowed to be modified, throw error."
  (declare (indent 1))
  `(if f--guard-paths
       (if (--any? (or (f-same-p it ,path)
                       (f-ancestor-of-p it ,path)) f--guard-paths)
           (progn ,@body)
         (signal 'f-guard-error (list ,path f--guard-paths)))
     ,@body))


;;;; Paths

(defun f-join (&rest args)
  "Join ARGS to a single path.

Be aware if one of the arguments is an absolute path, `f-join'
will discard all the preceeding arguments and make this absolute
path the new root of the generated path."
  (let (path
        (relative (f-relative-p (car args))))
    (-map
     (lambda (arg)
       (setq path (cond ((not path) arg)
                        ((f-absolute-p arg)
                         (progn
                           (setq relative nil)
                           arg))
                        (t (f-expand arg path)))))
     args)
    (if relative (f-relative path) path)))

(defun f-split (path)
  "Split PATH and return list containing parts."
  (let ((parts (split-string path (f-path-separator) 'omit-nulls)))
    (if (string= (s-left 1 path) (f-path-separator))
        (push (f-path-separator) parts)
      parts)))

(defun f-expand (path &optional dir)
  "Expand PATH relative to DIR (or `default-directory').
PATH and DIR can be either a directory names or directory file
names.  Return a directory name if PATH is a directory name, and
a directory file name otherwise.  File name handlers are
ignored."
  (let (file-name-handler-alist)
    (expand-file-name path dir)))

(defun f-filename (path)
  "Return the name of PATH."
  (file-name-nondirectory (directory-file-name path)))

(defalias 'f-parent 'f-dirname)

(defun f-dirname (path)
  "Return the parent directory to PATH."
  (let ((parent (file-name-directory
                 (directory-file-name (f-expand path default-directory)))))
    (unless (f-same-p path parent)
      (if (f-relative-p path)
          (f-relative parent)
        (directory-file-name parent)))))

(defun f-common-parent (paths)
  "Return the deepest common parent directory of PATHS."
  (cond
   ((not paths) nil)
   ((not (cdr paths)) (f-parent (car paths)))
   (:otherwise
    (let* ((paths (-map 'f-split paths))
           (common (caar paths))
           (re nil))
      (while (and (not (null (car paths))) (--all? (equal (car it) common) paths))
        (setq paths (-map 'cdr paths))
        (push common re)
        (setq common (caar paths)))
      (cond
       ((null re) "")
       ((and (= (length re) 1) (f-root-p (car re)))
        (f-root))
       (:otherwise
        (concat (apply 'f-join (nreverse re)) "/")))))))

(defalias 'f-ext 'file-name-extension)

(defalias 'f-no-ext 'file-name-sans-extension)

(defun f-swap-ext (path ext)
  "Return PATH but with EXT as the new extension.
EXT must not be nil or empty."
  (if (s-blank-p ext)
      (error "Extension cannot be empty or nil")
    (concat (f-no-ext path) "." ext)))

(defun f-base (path)
  "Return the name of PATH, excluding the extension of file."
  (f-no-ext (f-filename path)))

(defalias 'f-relative 'file-relative-name)

(defalias 'f-short 'abbreviate-file-name)
(defalias 'f-abbrev 'abbreviate-file-name)

(defun f-long (path)
  "Return long version of PATH."
  (f-expand path))

(defalias 'f-canonical 'file-truename)

(defun f-slash (path)
  "Append slash to PATH unless one already.

Some functions, such as `call-process' requires there to be an
ending slash."
  (if (f-dir-p path)
      (file-name-as-directory path)
    path))

(defun f-full (path)
  "Return absolute path to PATH, with ending slash."
  (f-slash (f-long path)))

(defun f--uniquify (paths)
  "Helper for `f-uniquify' and `f-uniquify-alist'."
  (let* ((files-length (length paths))
         (uniq-filenames (--map (cons it (f-filename it)) paths))
         (uniq-filenames-next (-group-by 'cdr uniq-filenames)))
    (while (/= files-length (length uniq-filenames-next))
      (setq uniq-filenames-next
            (-group-by 'cdr
                       (--mapcat
                        (let ((conf-files (cdr it)))
                          (if (> (length conf-files) 1)
                              (--map (cons
                                      (car it)
                                      (concat
                                       (f-filename (s-chop-suffix (cdr it)
                                                                  (car it)))
                                       (f-path-separator) (cdr it)))
                                     conf-files)
                            conf-files))
                        uniq-filenames-next))))
    uniq-filenames-next))

(defun f-uniquify (files)
  "Return unique suffixes of FILES.

This function expects no duplicate paths."
  (-map 'car (f--uniquify files)))

(defun f-uniquify-alist (files)
  "Return alist mapping FILES to unique suffixes of FILES.

This function expects no duplicate paths."
  (-map 'cadr (f--uniquify files)))


;;;; I/O

(defun f-read-bytes (path &optional beg end)
  "Read binary data from PATH.

Return the binary data as unibyte string. The optional second and
third arguments BEG and END specify what portion of the file to
read."
  (with-temp-buffer
    (set-buffer-multibyte nil)
    (setq buffer-file-coding-system 'binary)
    (insert-file-contents-literally path nil beg end)
    (buffer-substring-no-properties (point-min) (point-max))))

(defalias 'f-read 'f-read-text)
(defun f-read-text (path &optional coding)
  "Read text with PATH, using CODING.

CODING defaults to `utf-8'.

Return the decoded text as multibyte string."
  (decode-coding-string (f-read-bytes path) (or coding 'utf-8)))

(defalias 'f-write 'f-write-text)
(defun f-write-text (text coding path)
  "Write TEXT with CODING to PATH.

TEXT is a multibyte string.  CODING is a coding system to encode
TEXT with.  PATH is a file name to write to."
  (f-write-bytes (encode-coding-string text coding) path))

(defun f-unibyte-string-p (s)
  "Determine whether S is a unibyte string."
  (not (multibyte-string-p s)))

(defun f-write-bytes (data path)
  "Write binary DATA to PATH.

DATA is a unibyte string.  PATH is a file name to write to."
  (f--write-bytes data path nil))

(defalias 'f-append 'f-append-text)
(defun f-append-text (text coding path)
  "Append TEXT with CODING to PATH.

If PATH does not exist, it is created."
  (f-append-bytes (encode-coding-string text coding) path))

(defun f-append-bytes (data path)
  "Append binary DATA to PATH.

If PATH does not exist, it is created."
  (f--write-bytes data path :append))

(defun f--write-bytes (data filename append)
  "Write binary DATA to FILENAME.
If APPEND is non-nil, append the DATA to the existing contents."
  (f--destructive filename
    (unless (f-unibyte-string-p data)
      (signal 'wrong-type-argument (list 'f-unibyte-string-p data)))
    (let ((coding-system-for-write 'binary)
          (write-region-annotate-functions nil)
          (write-region-post-annotation-function nil))
      (write-region data nil filename append :silent)
      nil)))


;;;; Destructive

(defun f-mkdir (&rest dirs)
  "Create directories DIRS.

DIRS should be a successive list of directories forming together
a full path. The easiest way to call this function with a fully
formed path is using `f-split' alongside it:

    (apply #'f-mkdir (f-split \"path/to/file\"))

Although it works sometimes, it is not recommended to use fully
formed paths in the function. In this case, it is recommended to
use `f-mkdir-full-path' instead."
  (let (path)
    (-each
        dirs
      (lambda (dir)
        (setq path (f-expand dir path))
        (unless (f-directory-p path)
          (f--destructive path (make-directory path)))))))

(defun f-mkdir-full-path (dir)
  "Create DIR from a full path.

This function is similar to `f-mkdir' except it can accept a full
path instead of requiring several successive directory names."
  (apply #'f-mkdir (f-split dir)))

(defun f-delete (path &optional force)
  "Delete PATH, which can be file or directory.

If FORCE is t, a directory will be deleted recursively."
  (f--destructive path
    (if (or (f-file-p path) (f-symlink-p path))
        (delete-file path)
      (delete-directory path force))))

(defun f-symlink (source path)
  "Create a symlink to SOURCE from PATH."
  (f--destructive path (make-symbolic-link source path)))

(defun f-move (from to)
  "Move or rename FROM to TO.
If TO is a directory name, move FROM into TO."
  (f--destructive to (rename-file from to t)))

(defun f-copy (from to)
  "Copy file or directory FROM to TO.
If FROM names a directory and TO is a directory name, copy FROM
into TO as a subdirectory."
  (f--destructive to
    (if (f-file-p from)
        (copy-file from to)
      ;; The behavior of `copy-directory' differs between Emacs 23 and
      ;; 24 in that in Emacs 23, the contents of `from' is copied to
      ;; `to', while in Emacs 24 the directory `from' is copied to
      ;; `to'. We want the Emacs 24 behavior.
      (if (> emacs-major-version 23)
          (copy-directory from to)
        (if (f-dir-p to)
            (progn
              (apply 'f-mkdir (f-split to))
              (let ((new-to (f-expand (f-filename from) to)))
                (copy-directory from new-to)))
          (copy-directory from to))))))

(defun f-copy-contents (from to)
  "Copy contents in directory FROM, to directory TO."
  (unless (f-exists-p to)
    (error "Cannot copy contents to non existing directory %s" to))
  (unless (f-dir-p from)
    (error "Cannot copy contents as %s is a file" from))
  (--each (f-entries from)
    (f-copy it (file-name-as-directory to))))

(defun f-touch (path)
  "Update PATH last modification date or create if it does not exist."
  (f--destructive path
    (if (f-file-p path)
        (set-file-times path)
      (f-write-bytes "" path))))


;;;; Predicates

(defalias 'f-exists-p 'file-exists-p)
(defalias 'f-exists? 'file-exists-p)

(defalias 'f-directory-p 'file-directory-p)
(defalias 'f-directory? 'file-directory-p)
(defalias 'f-dir-p 'file-directory-p)
(defalias 'f-dir? 'file-directory-p)


(defalias 'f-file-p 'file-regular-p)
(defalias 'f-file? 'file-regular-p)

(defun f-symlink-p (path)
  "Return t if PATH is symlink, false otherwise."
  (not (not (file-symlink-p path))))

(defalias 'f-symlink? 'f-symlink-p)

(defalias 'f-readable-p 'file-readable-p)
(defalias 'f-readable? 'file-readable-p)

(defalias 'f-writable-p 'file-writable-p)
(defalias 'f-writable? 'file-writable-p)

(defalias 'f-executable-p 'file-executable-p)
(defalias 'f-executable? 'file-executable-p)

(defalias 'f-absolute-p 'file-name-absolute-p)
(defalias 'f-absolute? 'file-name-absolute-p)

(defun f-relative-p (path)
  "Return t if PATH is relative, false otherwise."
  (not (f-absolute-p path)))

(defalias 'f-relative? 'f-relative-p)

(defun f-root-p (path)
  "Return t if PATH is root directory, false otherwise."
  (not (f-parent path)))

(defalias 'f-root? 'f-root-p)

(defun f-ext-p (path &optional ext)
  "Return t if extension of PATH is EXT, false otherwise.

If EXT is nil or omitted, return t if PATH has any extension,
false otherwise.

The extension, in a file name, is the part that follows the last
'.', excluding version numbers and backup suffixes."
  (if ext
      (string= (f-ext path) ext)
    (not (eq (f-ext path) nil))))

(defalias 'f-ext? 'f-ext-p)

(defalias 'f-equal-p 'f-same-p)
(defalias 'f-equal? 'f-same-p)

(defun f-same-p (path-a path-b)
  "Return t if PATH-A and PATH-B are references to same file."
  (equal
   (f-canonical (directory-file-name (f-expand path-a)))
   (f-canonical (directory-file-name (f-expand path-b)))))

(defalias 'f-same? 'f-same-p)

(defun f-parent-of-p (path-a path-b)
  "Return t if PATH-A is parent of PATH-B."
  (--when-let (f-parent path-b)
    (f-same-p path-a it)))

(defalias 'f-parent-of? 'f-parent-of-p)

(defun f-child-of-p (path-a path-b)
  "Return t if PATH-A is child of PATH-B."
  (--when-let (f-parent path-a)
    (f-same-p it path-b)))

(defalias 'f-child-of? 'f-child-of-p)

(defun f-ancestor-of-p (path-a path-b)
  "Return t if PATH-A is ancestor of PATH-B."
  (unless (f-same-p path-a path-b)
    (string-prefix-p (f-full path-a)
                     (f-full path-b))))

(defalias 'f-ancestor-of? 'f-ancestor-of-p)

(defun f-descendant-of-p (path-a path-b)
  "Return t if PATH-A is desendant of PATH-B."
  (unless (f-same-p path-a path-b)
    (string-prefix-p (f-full path-b)
                     (f-full path-a))))

(defalias 'f-descendant-of? 'f-descendant-of-p)

(defun f-hidden-p (path)
  "Return t if PATH is hidden, nil otherwise."
  (unless (f-exists-p path)
    (error "Path does not exist: %s" path))
  (string= (substring path 0 1) "."))

(defalias 'f-hidden? 'f-hidden-p)

(defun f-empty-p (path)
  "If PATH is a file, return t if the file in PATH is empty, nil otherwise.
If PATH is directory, return t if directory has no files, nil otherwise."
  (if (f-directory-p path)
      (equal (f-files path nil t) nil)
    (= (f-size path) 0)))

(defalias 'f-empty? 'f-empty-p)


;;;; Stats

(defun f-size (path)
  "Return size of PATH.

If PATH is a file, return size of that file.  If PATH is
directory, return sum of all files in PATH."
  (if (f-directory-p path)
      (-sum (-map 'f-size (f-files path nil t)))
    (nth 7 (file-attributes path))))

(defun f-depth (path)
  "Return the depth of PATH.

At first, PATH is expanded with `f-expand'.  Then the full path is used to
detect the depth.
'/' will be zero depth,  '/usr' will be one depth.  And so on."
  (- (length (f-split (f-expand path))) 1))

(defun f-change-time (path)
  "Return the last status change time of PATH.

The status change time (ctime) of PATH in the same format as
`current-time'. See `file-attributes' for technical details."
  (nth 6 (file-attributes path)))

(defun f-modification-time (path)
  "Return the last modification time of PATH.

The modification time (mtime) of PATH in the same format as
`current-time'. See `file-attributes' for technical details."
  (nth 5 (file-attributes path)))

(defun f-access-time (path)
  "Return the last access time of PATH.

The access time (atime) of PATH is in the same format as
`current-time'. See `file-attributes' for technical details."
  (nth 4 (file-attributes path)))


;;;; Misc

(defun f-this-file ()
  "Return path to this file."
  (cond
   (load-in-progress load-file-name)
   ((and (boundp 'byte-compile-current-file) byte-compile-current-file)
    byte-compile-current-file)
   (:else (buffer-file-name))))

(defvar f--path-separator nil
  "A variable to cache result of `f-path-separator'.")

(defun f-path-separator ()
  "Return path separator."
  (or f--path-separator
      (setq f--path-separator (substring (f-join "x" "y") 1 2))))

(defun f-glob (pattern &optional path)
  "Find PATTERN in PATH."
  (file-expand-wildcards
   (f-join (or path default-directory) pattern)))

(defun f--collect-entries (path recursive)
  (let (result
        (entries
         (-reject
          (lambda (file)
            (member (f-filename file) '("." "..")))
          (directory-files path t))))
    (cond (recursive
           (-map
            (lambda (entry)
              (if (f-file-p entry)
                  (setq result (cons entry result))
                (when (f-directory-p entry)
                  (setq result (cons entry result))
                  (if (f-readable-p entry)
                      (setq result (append result (f--collect-entries entry recursive)))
                    result))))
            entries))
          (t (setq result entries)))
    result))

(defmacro f--entries (path body &optional recursive)
  "Anaphoric version of `f-entries'."
  `(f-entries
    ,path
    (lambda (path)
      (let ((it path))
        ,body))
    ,recursive))

(defun f-entries (path &optional fn recursive)
  "Find all files and directories in PATH.

FN - called for each found file and directory.  If FN returns a thruthy
value, file or directory will be included.
RECURSIVE - Search for files and directories recursive."
  (let ((entries (f--collect-entries path recursive)))
    (if fn (-select fn entries) entries)))

(defmacro f--directories (path body &optional recursive)
  "Anaphoric version of `f-directories'."
  `(f-directories
    ,path
    (lambda (path)
      (let ((it path))
        ,body))
    ,recursive))

(defun f-directories (path &optional fn recursive)
  "Find all directories in PATH.  See `f-entries'."
  (let ((directories (-select 'f-directory-p (f--collect-entries path recursive))))
    (if fn (-select fn directories) directories)))

(defmacro f--files (path body &optional recursive)
  "Anaphoric version of `f-files'."
  `(f-files
    ,path
    (lambda (path)
      (let ((it path))
        ,body))
    ,recursive))

(defun f-files (path &optional fn recursive)
  "Find all files in PATH.  See `f-entries'."
  (let ((files (-select 'f-file-p (f--collect-entries path recursive))))
    (if fn (-select fn files) files)))

(defmacro f--traverse-upwards (body &optional path)
  "Anaphoric version of `f-traverse-upwards'."
  `(f-traverse-upwards
    (lambda (dir)
      (let ((it dir))
        ,body))
    ,path))

(defun f-traverse-upwards (fn &optional path)
  "Traverse up as long as FN return nil, starting at PATH.

If FN returns a non-nil value, the path sent as argument to FN is
returned.  If no function callback return a non-nil value, nil is
returned."
  (unless path
    (setq path default-directory))
  (when (f-relative-p path)
    (setq path (f-expand path)))
  (if (funcall fn path)
      path
    (unless (f-root-p path)
      (f-traverse-upwards fn (f-parent path)))))

(defun f-root ()
  "Return absolute root."
  (f-traverse-upwards 'f-root-p))

(defmacro f-with-sandbox (path-or-paths &rest body)
  "Only allow PATH-OR-PATHS and descendants to be modified in BODY."
  (declare (indent 1))
  `(let ((paths (if (listp ,path-or-paths)
                    ,path-or-paths
                  (list ,path-or-paths))))
     (unwind-protect
         (let ((f--guard-paths paths))
           ,@body)
       (setq f--guard-paths nil))))

(provide 'f)

;;; f.el ends here
#+end_src

** f-shortdoc.el

Taken from [[https://github.com/rejeep/f.el/blob/master/f-shortdoc.el][here]]:

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;; -*- no-byte-compile: t; -*-
;;; f-shortdoc.el --- Shortdoc for f.el -*- lexical-binding: t -*-

;; Author: Lucien Cartier-Tilet <lucien@phundrak.com>
;; Maintainer: Lucien Cartier-Tilet <lucien@phundrak.com>
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))
;; Homepage: https://github.com/rejeep/f.el

;; This file is not part of GNU Emacs

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.


;;; Commentary:

;; Shortdoc implementation for f.el

;;; Code:

(when (version<= "28.1" emacs-version)
  (require 'shortdoc)

  (define-short-documentation-group f
    "Paths"
    (f-join
     :eval (f-join "path")
     :eval (f-join "path" "to")
     :eval (f-join "/" "path" "to" "heaven")
     :eval (f-join "path" "/to" "file"))

    (f-split
     :eval (f-split "path")
     :eval (f-split "path/to")
     :eval (f-split "/path/to/heaven")
     :eval (f-split "~/back/to/earth"))

    (f-expand
     :no-eval (f-expand "name")
     :result-string "/default/directory/name"
     :no-eval (f-expand "name" "other/directory")
     :result-string "other/directory/name")

    (f-filename
     :eval (f-filename "path/to/file.ext")
     :eval (f-filename "path/to/directory"))

    (f-dirname
     :eval (f-dirname "path/to/file.ext")
     :eval (f-dirname "path/to/directory")
     :eval (f-dirname "/"))

    (f-common-parent
     :eval (f-common-parent '("foo/bar/baz" "foo/bar/qux" "foo/bar/mux"))
     :eval (f-common-parent '("/foo/bar/baz" "/foo/bar/qux" "/foo/bax/mux"))
     :eval (f-common-parent '("foo/bar/baz" "quack/bar/qux" "lack/bar/mux")))

    (f-ext
     :eval (f-ext "path/to/file")
     :eval (f-ext "path/to/file.txt")
     :eval (f-ext "path/to/file.txt.org"))

    (f-no-ext
     :eval (f-no-ext "path/to/file")
     :eval (f-no-ext "path/to/file.txt")
     :eval (f-no-ext "path/to/file.txt.org"))

    (f-swap-ext
     :eval (f-swap-ext "path/to/file.ext" "org"))

    (f-base
     :eval (f-base "path/to/file.ext")
     :eval (f-base "path/to/directory"))

    (f-relative
     :eval (f-relative "/some/path/relative/to/my/file.txt" "/some/path/")
     :eval (f-relative "/default/directory/my/file.txt"))

    (f-short
     :no-eval (f-short "/Users/foo/Code/on/macOS")
     :result-string "~/Code/on/macOS"
     :no-eval (f-short "/home/foo/Code/on/linux")
     :result-string "~/Code/on/linux"
     :eval (f-short "/path/to/Code/bar"))

    (f-long
     :eval (f-long "~/Code/bar")
     :eval (f-long "/path/to/Code/bar"))

    (f-canonical
     :eval (f-canonical "/path/to/real/file")
     :no-eval (f-canonical "/link/to/file")
     :result-string "/path/to/real/file")

    (f-slash
     :no-eval (f-slash "/path/to/file")
     :result-string "/path/to/file"
     :no-eval (f-slash "/path/to/dir")
     :result-string "/path/to/dir/"
     :no-eval (f-slash "/path/to/dir/")
     :result-string "/path/to/dir/")

    (f-full
     :eval (f-full "~/path/to/file")
     :eval (f-full "~/path/to/dir")
     :eval (f-full "~/path/to/dir/"))

    (f-uniquify
     :eval (f-uniquify '("/foo/bar" "/foo/baz" "/foo/quux"))
     :eval (f-uniquify '("/foo/bar" "/www/bar" "/foo/quux"))
     :eval (f-uniquify '("/foo/bar" "/www/bar" "/www/bar/quux"))
     :eval (f-uniquify '("/foo/bar" "/foo/baz" "/home/www/bar" "/home/www/baz" "/var/foo" "/opt/foo/www/baz")))

    (f-uniquify-alist
     :eval (f-uniquify-alist '("/foo/bar" "/foo/baz" "/foo/quux"))
     :eval (f-uniquify-alist '("/foo/bar" "/www/bar" "/foo/quux"))
     :eval (f-uniquify-alist '("/foo/bar" "/www/bar" "/www/bar/quux"))
     :eval (f-uniquify-alist '("/foo/bar" "/foo/baz" "/home/www/bar" "/home/www/baz" "/var/foo" "/opt/foo/www/baz")))

    "I/O"
    (f-read-bytes
     :no-eval* (f-read-bytes "path/to/binary/data"))

    (f-write-bytes
     :no-eval* (f-write-bytes (unibyte-string 72 101 108 108 111 32 119 111 114 108 100) "path/to/binary/data"))

    (f-append-bytes
     :no-eval* (f-append-bytes "path/to/file" (unibyte-string 72 101 108 108 111 32 119 111 114 108 100)))

    (f-read-text
     :no-eval* (f-read-text "path/to/file.txt" 'utf-8)
     :no-eval* (f-read "path/to/file.txt" 'utf-8))

    (f-write-text
     :no-eval* (f-write-text "Hello world" 'utf-8 "path/to/file.txt")
     :no-eval* (f-write "Hello world" 'utf-8 "path/to/file.txt"))

    (f-append-text
     :no-eval* (f-append-text "Hello world" 'utf-8 "path/to/file.txt")
     :no-eval* (f-append "Hello world" 'utf-8 "path/to/file.txt"))

    "Destructive"
    (f-mkdir
     :no-eval (f-mkdir "dir")
     :result-string "creates /default/directory/dir"
     :no-eval (f-mkdir "other" "dir")
     :result-string "creates /default/directory/other/dir"
     :no-eval (f-mkdir "/" "some" "path")
     :result-string "creates /some/path"
     :no-eval (f-mkdir "~" "yet" "another" "dir")
     :result-string "creates ~/yet/another/dir")

    (f-mkdir-full-path
     :no-eval (f-mkdir-full-path "dir")
     :result-string "creates /default/directory/dir"
     :no-eval (f-mkdir-full-path "other/dir")
     :result-string "creates /default/directory/other/dir"
     :no-eval (f-mkdir-full-path "/some/path")
     :result-string "creates /some/path"
     :no-eval (f-mkdir-full-path "~/yet/another/dir")
     :result-string "creates ~/yet/another/dir")

    (f-delete
     :no-eval* (f-delete "dir")
     :no-eval* (f-delete "other/dir" t)
     :no-eval* (f-delete "path/to/file.txt"))

    (f-symlink
     :no-eval* (f-symlink "path/to/source" "path/to/link"))

    (f-move
     :no-eval* (f-move "path/to/file.txt" "new-file.txt")
     :no-eval* (f-move "path/to/file.txt" "other/path"))

    (f-copy
     :no-eval* (f-copy "path/to/file.txt" "new-file.txt")
     :no-eval* (f-copy "path/to/dir" "other/dir"))

    (f-copy-contents
     :no-eval* (f-copy-contents "path/to/dir" "path/to/other/dir"))

    (f-touch
     :no-eval* (f-touch "path/to/existing/file.txt")
     :no-eval* (f-touch "path/to/non/existing/file.txt"))

    "Predicates"
    (f-exists-p
     :no-eval* (f-exists-p "path/to/file.txt")
     :no-eval* (f-exists-p "path/to/dir"))

    (f-directory-p
     :no-eval* (f-directory-p "path/to/file.txt")
     :no-eval* (f-directory-p "path/to/dir"))

    (f-file-p
     :no-eval* (f-file-p "path/to/file.txt")
     :no-eval* (f-file-p "path/to/dir"))

    (f-symlink-p
     :no-eval* (f-symlink-p "path/to/file.txt")
     :no-eval* (f-symlink-p "path/to/dir")
     :no-eval* (f-symlink-p "path/to/link"))

    (f-readable-p
     :no-eval* (f-readable-p "path/to/file.txt")
     :no-eval* (f-readable-p "path/to/dir"))

    (f-writable-p
     :no-eval* (f-writable-p "path/to/file.txt")
     :no-eval* (f-writable-p "path/to/dir"))

    (f-executable-p
     :no-eval* (f-executable-p "path/to/file.txt")
     :no-eval* (f-executable-p "path/to/dir"))

    (f-absolute-p
     :eval (f-absolute-p "path/to/dir")
     :eval (f-absolute-p "/full/path/to/dir"))

    (f-relative-p
     :eval (f-relative-p "path/to/dir")
     :eval (f-relative-p "/full/path/to/dir"))

    (f-root-p
     :eval (f-root-p "/")
     :eval (f-root-p "/not/root"))

    (f-ext-p
     :eval (f-ext-p "path/to/file.el" "el")
     :eval (f-ext-p "path/to/file.el" "txt")
     :eval (f-ext-p "path/to/file.el")
     :eval (f-ext-p "path/to/file"))

    (f-same-p
     :eval (f-same-p "foo.txt" "foo.txt")
     :eval (f-same-p "foo/bar/../baz" "foo/baz")
     :eval (f-same-p "/path/to/foo.txt" "/path/to/bar.txt"))

    (f-parent-of-p
     :no-eval (f-parent-of-p "/path/to" "/path/to/dir")
     :result t
     :no-eval (f-parent-of-p "/path/to/dir" "/path/to")
     :result nil
     :no-eval (f-parent-of-p "/path/to" "/path/to")
     :result nil)

    (f-child-of-p
     :no-eval (f-child-of-p "/path/to" "/path/to/dir")
     :result nil
     :no-eval (f-child-of-p "/path/to/dir" "/path/to")
     :result t
     :no-eval (f-child-of-p "/path/to" "/path/to")
     :result nil)

    (f-ancestor-of-p
     :no-eval (f-ancestor-of-p "/path/to" "/path/to/dir")
     :result t
     :no-eval (f-ancestor-of-p "/path" "/path/to/dir")
     :result t
     :no-eval (f-ancestor-of-p "/path/to/dir" "/path/to")
     :result nil
     :no-eval (f-ancestor-of-p "/path/to" "/path/to")
     :result nil)

    (f-descendant-of-p
     :no-eval (f-descendant-of-p "/path/to/dir" "/path/to")
     :result t
     :no-eval (f-descendant-of-p "/path/to/dir" "/path")
     :result t
     :no-eval (f-descendant-of-p "/path/to" "/path/to/dir")
     :result nil
     :no-eval (f-descendant-of-p "/path/to" "/path/to")
     :result nil)

    (f-hidden-p
     :no-eval (f-hidden-p "/path/to/foo")
     :result nil
     :no-eval (f-hidden-p "/path/to/.foo")
     :result t)

    (f-empty-p
     :no-eval (f-empty-p "/path/to/empty-file")
     :result t
     :no-eval (f-empty-p "/path/to/file-with-contents")
     :result nil
     :no-eval (f-empty-p "/path/to/empty-dir/")
     :result t
     :no-eval (f-empty-p "/path/to/dir-with-contents/")
     :result nil)

    "Stats"
    (f-size
     :no-eval* (f-size "path/to/file.txt")
     :no-eval* (f-size "path/to/dir"))

    (f-depth
     :eval (f-depth "/")
     :eval (f-depth "/var/")
     :eval (f-depth "/usr/local/bin"))

    (f-change-time
     :no-eval* (f-change-time "path/to/file.txt")
     :no-eval* (f-change-time "path/to/dir"))

    (f-modification-time
     :no-eval* (f-modification-time "path/to/file.txt")
     :no-eval* (f-modification-time "path/to/dir"))

    (f-access-time
     :no-eval* (f-access-time "path/to/file.txt")
     :no-eval* (f-access-time "path/to/dir"))

    "Misc"
    (f-this-file
     :no-eval* (f-this-file))

    (f-path-separator
     :eval (f-path-separator))

    (f-glob
     :noeval* (f-glob "path/to/*.el")
     :noeval* (f-glob "*.el" "path/to"))

    (f-entries
     :no-eval* (f-entries "path/to/dir")
     :no-eval* (f-entries "path/to/dir" (lambda (file) (s-matches? "test" file)))
     :no-eval* (f-entries "path/to/dir" nil t)
     :no-eval* (f--entries "path/to/dir" (s-matches? "test" it)))

    (f-directories
     :no-eval* (f-directories "path/to/dir")
     :no-eval* (f-directories "path/to/dir" (lambda (dir) (equal (f-filename dir) "test")))
     :no-eval* (f-directories "path/to/dir" nil t)
     :no-eval* (f--directories "path/to/dir" (equal (f-filename it) "test")))

    (f-files
     :no-eval* (f-files "path/to/dir")
     :no-eval* (f-files "path/to/dir" (lambda (file) (equal (f-ext file) "el")))
     :no-eval* (f-files "path/to/dir" nil t)
     :no-eval* (f--files "path/to/dir" (equal (f-ext it) "el")))

    (f-root
     :eval (f-root))

    (f-traverse-upwards
     :no-eval* (f-traverse-upwards
                (lambda (path)
                  (f-exists? (f-expand ".git" path)))
                start-path)

     :no-eval* (f--traverse-upwards (f-exists? (f-expand ".git" it)) start-path))

    (f-with-sandbox
     :no-eval (f-with-sandbox foo-path
                (f-touch (f-expand "foo" foo-path)))
     :no-eval (f-with-sandbox (list foo-path bar-path)
                (f-touch (f-expand "foo" foo-path))
                (f-touch (f-expand "bar" bar-path)))
     :no-eval (f-with-sandbox foo-path
                (f-touch (f-expand "bar" bar-path)))))) ;; "Destructive operation outside sandbox"

(eval-when-compile
  (when (version< emacs-version "28.1")
    (warn "Emacs should not be compiling this file")))

(provide 'f-shortdoc)

;;; f-shortdoc.el ends here
#+end_src

** s.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; s.el --- The long lost Emacs string manipulation library.

;; Copyright (C) 2012-2015 Magnar Sveen

;; Author: Magnar Sveen <magnars@gmail.com>
;; Version: 1.12.0
;; Keywords: strings

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; The long lost Emacs string manipulation library.
;;
;; See documentation on https://github.com/magnars/s.el#functions

;;; Code:

;; Silence byte-compiler
(defvar ucs-normalize-combining-chars)  ; Defined in `ucs-normalize'
(autoload 'slot-value "eieio")

(defun s-trim-left (s)
  "Remove whitespace at the beginning of S."
  (declare (pure t) (side-effect-free t))
  (save-match-data
    (if (string-match "\\`[ \t\n\r]+" s)
        (replace-match "" t t s)
      s)))

(defun s-trim-right (s)
  "Remove whitespace at the end of S."
  (save-match-data
    (declare (pure t) (side-effect-free t))
    (if (string-match "[ \t\n\r]+\\'" s)
        (replace-match "" t t s)
      s)))

(defun s-trim (s)
  "Remove whitespace at the beginning and end of S."
  (declare (pure t) (side-effect-free t))
  (s-trim-left (s-trim-right s)))

(defun s-collapse-whitespace (s)
  "Convert all adjacent whitespace characters to a single space."
  (declare (pure t) (side-effect-free t))
  (replace-regexp-in-string "[ \t\n\r]+" " " s))

(defun s-split (separator s &optional omit-nulls)
  "Split S into substrings bounded by matches for regexp SEPARATOR.
If OMIT-NULLS is non-nil, zero-length substrings are omitted.

This is a simple wrapper around the built-in `split-string'."
  (declare (side-effect-free t))
  (save-match-data
    (split-string s separator omit-nulls)))

(defun s-split-up-to (separator s n &optional omit-nulls)
  "Split S up to N times into substrings bounded by matches for regexp SEPARATOR.

If OMIT-NULLS is non-nil, zero-length substrings are omitted.

See also `s-split'."
  (declare (side-effect-free t))
  (save-match-data
    (let ((op 0)
          (r nil))
      (with-temp-buffer
        (insert s)
        (setq op (goto-char (point-min)))
        (while (and (re-search-forward separator nil t)
                    (< 0 n))
          (let ((sub (buffer-substring op (match-beginning 0))))
            (unless (and omit-nulls
                         (equal sub ""))
              (push sub r)))
          (setq op (goto-char (match-end 0)))
          (setq n (1- n)))
        (let ((sub (buffer-substring op (point-max))))
          (unless (and omit-nulls
                       (equal sub ""))
            (push sub r))))
      (nreverse r))))

(defun s-lines (s)
  "Splits S into a list of strings on newline characters."
  (declare (pure t) (side-effect-free t))
  (s-split "\\(\r\n\\|[\n\r]\\)" s))

(defun s-join (separator strings)
  "Join all the strings in STRINGS with SEPARATOR in between."
  (declare (pure t) (side-effect-free t))
  (mapconcat 'identity strings separator))

(defun s-concat (&rest strings)
  "Join all the string arguments into one string."
  (declare (pure t) (side-effect-free t))
  (apply 'concat strings))

(defun s-prepend (prefix s)
  "Concatenate PREFIX and S."
  (declare (pure t) (side-effect-free t))
  (concat prefix s))

(defun s-append (suffix s)
  "Concatenate S and SUFFIX."
  (declare (pure t) (side-effect-free t))
  (concat s suffix))

(defun s-repeat (num s)
  "Make a string of S repeated NUM times."
  (declare (pure t) (side-effect-free t))
  (let (ss)
    (while (> num 0)
      (setq ss (cons s ss))
      (setq num (1- num)))
    (apply 'concat ss)))

(defun s-chop-suffix (suffix s)
  "Remove SUFFIX if it is at end of S."
  (declare (pure t) (side-effect-free t))
  (let ((pos (- (length suffix))))
    (if (and (>= (length s) (length suffix))
             (string= suffix (substring s pos)))
        (substring s 0 pos)
      s)))

(defun s-chop-suffixes (suffixes s)
  "Remove SUFFIXES one by one in order, if they are at the end of S."
  (declare (pure t) (side-effect-free t))
  (while suffixes
    (setq s (s-chop-suffix (car suffixes) s))
    (setq suffixes (cdr suffixes)))
  s)

(defun s-chop-prefix (prefix s)
  "Remove PREFIX if it is at the start of S."
  (declare (pure t) (side-effect-free t))
  (let ((pos (length prefix)))
    (if (and (>= (length s) (length prefix))
             (string= prefix (substring s 0 pos)))
        (substring s pos)
      s)))

(defun s-chop-prefixes (prefixes s)
  "Remove PREFIXES one by one in order, if they are at the start of S."
  (declare (pure t) (side-effect-free t))
  (while prefixes
    (setq s (s-chop-prefix (car prefixes) s))
    (setq prefixes (cdr prefixes)))
  s)

(defun s-shared-start (s1 s2)
  "Returns the longest prefix S1 and S2 have in common."
  (declare (pure t) (side-effect-free t))
  (let ((cmp (compare-strings s1 0 (length s1) s2 0 (length s2))))
    (if (eq cmp t) s1 (substring s1 0 (1- (abs cmp))))))

(defun s-shared-end (s1 s2)
  "Returns the longest suffix S1 and S2 have in common."
  (declare (pure t) (side-effect-free t))
  (let* ((l1 (length s1))
         (l2 (length s2))
         (search-length (min l1 l2))
         (i 0))
    (while (and (< i search-length)
                (= (aref s1 (- l1 i 1)) (aref s2 (- l2 i 1))))
      (setq i (1+ i)))
    ;; If I is 0, then it means that there's no common suffix between
    ;; S1 and S2.
    ;;
    ;; However, since (substring s (- 0)) will return the whole
    ;; string, `s-shared-end' should simply return the empty string
    ;; when I is 0.
    (if (zerop i)
        ""
      (substring s1 (- i)))))

(defun s-chomp (s)
  "Remove one trailing `\\n`, `\\r` or `\\r\\n` from S."
  (declare (pure t) (side-effect-free t))
  (s-chop-suffixes '("\n" "\r") s))

(defun s-truncate (len s &optional ellipsis)
  "If S is longer than LEN, cut it down and add ELLIPSIS to the end.

The resulting string, including ellipsis, will be LEN characters
long.

When not specified, ELLIPSIS defaults to ‘...’."
  (declare (pure t) (side-effect-free t))
  (unless ellipsis
    (setq ellipsis "..."))
  (if (> (length s) len)
      (format "%s%s" (substring s 0 (- len (length ellipsis))) ellipsis)
    s))

(defun s-word-wrap (len s)
  "If S is longer than LEN, wrap the words with newlines."
  (declare (side-effect-free t))
  (save-match-data
    (with-temp-buffer
      (insert s)
      (let ((fill-column len))
        (fill-region (point-min) (point-max)))
      (buffer-substring (point-min) (point-max)))))

(defun s-center (len s)
  "If S is shorter than LEN, pad it with spaces so it is centered."
  (declare (pure t) (side-effect-free t))
  (let ((extra (max 0 (- len (length s)))))
    (concat
     (make-string (ceiling extra 2) ? )
     s
     (make-string (floor extra 2) ? ))))

(defun s-pad-left (len padding s)
  "If S is shorter than LEN, pad it with PADDING on the left."
  (declare (pure t) (side-effect-free t))
  (let ((extra (max 0 (- len (length s)))))
    (concat (make-string extra (string-to-char padding))
            s)))

(defun s-pad-right (len padding s)
  "If S is shorter than LEN, pad it with PADDING on the right."
  (declare (pure t) (side-effect-free t))
  (let ((extra (max 0 (- len (length s)))))
    (concat s
            (make-string extra (string-to-char padding)))))

(defun s-left (len s)
  "Returns up to the LEN first chars of S."
  (declare (pure t) (side-effect-free t))
  (if (> (length s) len)
      (substring s 0 len)
    s))

(defun s-right (len s)
  "Returns up to the LEN last chars of S."
  (declare (pure t) (side-effect-free t))
  (let ((l (length s)))
    (if (> l len)
        (substring s (- l len) l)
      s)))

(defun s-ends-with? (suffix s &optional ignore-case)
  "Does S end with SUFFIX?

If IGNORE-CASE is non-nil, the comparison is done without paying
attention to case differences.

Alias: `s-suffix?'"
  (declare (pure t) (side-effect-free t))
  (let ((start-pos (- (length s) (length suffix))))
    (and (>= start-pos 0)
         (eq t (compare-strings suffix nil nil
                                s start-pos nil ignore-case)))))

(defun s-starts-with? (prefix s &optional ignore-case)
  "Does S start with PREFIX?

If IGNORE-CASE is non-nil, the comparison is done without paying
attention to case differences.

Alias: `s-prefix?'. This is a simple wrapper around the built-in
`string-prefix-p'."
  (declare (pure t) (side-effect-free t))
  (string-prefix-p prefix s ignore-case))

(defun s--truthy? (val)
  (declare (pure t) (side-effect-free t))
  (not (null val)))

(defun s-contains? (needle s &optional ignore-case)
  "Does S contain NEEDLE?

If IGNORE-CASE is non-nil, the comparison is done without paying
attention to case differences."
  (declare (pure t) (side-effect-free t))
  (let ((case-fold-search ignore-case))
    (s--truthy? (string-match-p (regexp-quote needle) s))))

(defun s-equals? (s1 s2)
  "Is S1 equal to S2?

This is a simple wrapper around the built-in `string-equal'."
  (declare (pure t) (side-effect-free t))
  (string-equal s1 s2))

(defun s-less? (s1 s2)
  "Is S1 less than S2?

This is a simple wrapper around the built-in `string-lessp'."
  (declare (pure t) (side-effect-free t))
  (string-lessp s1 s2))

(defun s-matches? (regexp s &optional start)
  "Does REGEXP match S?
If START is non-nil the search starts at that index.

This is a simple wrapper around the built-in `string-match-p'."
  (declare (side-effect-free t))
  (s--truthy? (string-match-p regexp s start)))

(defun s-blank? (s)
  "Is S nil or the empty string?"
  (declare (pure t) (side-effect-free t))
  (or (null s) (string= "" s)))

(defun s-blank-str? (s)
  "Is S nil or the empty string or string only contains whitespace?"
  (declare (pure t) (side-effect-free t))
  (or (s-blank? s) (s-blank? (s-trim s))))

(defun s-present? (s)
  "Is S anything but nil or the empty string?"
  (declare (pure t) (side-effect-free t))
  (not (s-blank? s)))

(defun s-presence (s)
  "Return S if it's `s-present?', otherwise return nil."
  (declare (pure t) (side-effect-free t))
  (and (s-present? s) s))

(defun s-lowercase? (s)
  "Are all the letters in S in lower case?"
  (declare (side-effect-free t))
  (let ((case-fold-search nil))
    (not (string-match-p "[[:upper:]]" s))))

(defun s-uppercase? (s)
  "Are all the letters in S in upper case?"
  (declare (side-effect-free t))
  (let ((case-fold-search nil))
    (not (string-match-p "[[:lower:]]" s))))

(defun s-mixedcase? (s)
  "Are there both lower case and upper case letters in S?"
  (let ((case-fold-search nil))
    (s--truthy?
     (and (string-match-p "[[:lower:]]" s)
          (string-match-p "[[:upper:]]" s)))))

(defun s-capitalized? (s)
  "In S, is the first letter upper case, and all other letters lower case?"
  (declare (side-effect-free t))
  (let ((case-fold-search nil))
    (s--truthy?
     (string-match-p "^[[:upper:]][^[:upper:]]*$" s))))

(defun s-numeric? (s)
  "Is S a number?"
  (declare (pure t) (side-effect-free t))
  (s--truthy?
   (string-match-p "^[0-9]+$" s)))

(defun s-replace (old new s)
  "Replaces OLD with NEW in S."
  (declare (pure t) (side-effect-free t))
  (replace-regexp-in-string (regexp-quote old) new s t t))

(defalias 's-replace-regexp 'replace-regexp-in-string)

(defun s--aget (alist key)
  (declare (pure t) (side-effect-free t))
  (cdr (assoc-string key alist)))

(defun s-replace-all (replacements s)
  "REPLACEMENTS is a list of cons-cells. Each `car` is replaced with `cdr` in S."
  (declare (pure t) (side-effect-free t))
  (replace-regexp-in-string (regexp-opt (mapcar 'car replacements))
                            (lambda (it) (s--aget replacements it))
                            s t t))

(defun s-downcase (s)
  "Convert S to lower case.

This is a simple wrapper around the built-in `downcase'."
  (declare (side-effect-free t))
  (downcase s))

(defun s-upcase (s)
  "Convert S to upper case.

This is a simple wrapper around the built-in `upcase'."
  (declare (side-effect-free t))
  (upcase s))

(defun s-capitalize (s)
  "Convert the first word's first character to upper case and the rest to lower case in S."
  (declare (side-effect-free t))
  (concat (upcase (substring s 0 1)) (downcase (substring s 1))))

(defun s-titleize (s)
  "Convert each word's first character to upper case and the rest to lower case in S.

This is a simple wrapper around the built-in `capitalize'."
  (declare (side-effect-free t))
  (capitalize s))

(defmacro s-with (s form &rest more)
  "Threads S through the forms. Inserts S as the last item
in the first form, making a list of it if it is not a list
already. If there are more forms, inserts the first form as the
last item in second form, etc."
  (declare (debug (form &rest [&or (function &rest form) fboundp])))
  (if (null more)
      (if (listp form)
          `(,(car form) ,@(cdr form) ,s)
        (list form s))
    `(s-with (s-with ,s ,form) ,@more)))

(put 's-with 'lisp-indent-function 1)

(defun s-index-of (needle s &optional ignore-case)
  "Returns first index of NEEDLE in S, or nil.

If IGNORE-CASE is non-nil, the comparison is done without paying
attention to case differences."
  (declare (pure t) (side-effect-free t))
  (let ((case-fold-search ignore-case))
    (string-match-p (regexp-quote needle) s)))

(defun s-reverse (s)
  "Return the reverse of S."
  (declare (pure t) (side-effect-free t))
  (save-match-data
    (if (multibyte-string-p s)
        (let ((input (string-to-list s))
              output)
          (require 'ucs-normalize)
          (while input
            ;; Handle entire grapheme cluster as a single unit
            (let ((grapheme (list (pop input))))
              (while (memql (car input) ucs-normalize-combining-chars)
                (push (pop input) grapheme))
              (setq output (nconc (nreverse grapheme) output))))
          (concat output))
      (concat (nreverse (string-to-list s))))))

(defun s-match-strings-all (regex string)
  "Return a list of matches for REGEX in STRING.

Each element itself is a list of matches, as per
`match-string'. Multiple matches at the same position will be
ignored after the first."
  (declare (side-effect-free t))
  (save-match-data
    (let ((all-strings ())
          (i 0))
      (while (and (< i (length string))
                  (string-match regex string i))
        (setq i (1+ (match-beginning 0)))
        (let (strings
              (num-matches (/ (length (match-data)) 2))
              (match 0))
          (while (/= match num-matches)
            (push (match-string match string) strings)
            (setq match (1+ match)))
          (push (nreverse strings) all-strings)))
      (nreverse all-strings))))

(defun s-matched-positions-all (regexp string &optional subexp-depth)
  "Return a list of matched positions for REGEXP in STRING.
SUBEXP-DEPTH is 0 by default."
  (declare (side-effect-free t))
  (if (null subexp-depth)
      (setq subexp-depth 0))
  (save-match-data
    (let ((pos 0) result)
      (while (and (string-match regexp string pos)
                  (< pos (length string)))
        (let ((m (match-end subexp-depth)))
          (push (cons (match-beginning subexp-depth) (match-end subexp-depth)) result)
          (setq pos (match-end 0))))
      (nreverse result))))

(defun s-match (regexp s &optional start)
  "When the given expression matches the string, this function returns a list
of the whole matching string and a string for each matched subexpressions.
If it did not match the returned value is an empty list (nil).

When START is non-nil the search will start at that index."
  (declare (side-effect-free t))
  (save-match-data
    (if (string-match regexp s start)
        (let ((match-data-list (match-data))
              result)
          (while match-data-list
            (let* ((beg (car match-data-list))
                   (end (cadr match-data-list))
                   (subs (if (and beg end) (substring s beg end) nil)))
              (setq result (cons subs result))
              (setq match-data-list
                    (cddr match-data-list))))
          (nreverse result)))))

(defun s-slice-at (regexp s)
  "Slices S up at every index matching REGEXP."
  (declare (side-effect-free t))
  (if (= 0 (length s)) (list "")
    (save-match-data
      (let (i)
        (setq i (string-match regexp s 1))
        (if i
            (cons (substring s 0 i)
                  (s-slice-at regexp (substring s i)))
          (list s))))))

(defun s-split-words (s)
  "Split S into list of words."
  (declare (side-effect-free t))
  (s-split
   "[^[:word:]0-9]+"
   (let ((case-fold-search nil))
     (replace-regexp-in-string
      "\\([[:lower:]]\\)\\([[:upper:]]\\)" "\\1 \\2"
      (replace-regexp-in-string "\\([[:upper:]]\\)\\([[:upper:]][0-9[:lower:]]\\)" "\\1 \\2" s)))
   t))

(defun s--mapcar-head (fn-head fn-rest list)
  "Like MAPCAR, but applies a different function to the first element."
  (if list
      (cons (funcall fn-head (car list)) (mapcar fn-rest (cdr list)))))

(defun s-lower-camel-case (s)
  "Convert S to lowerCamelCase."
  (declare (side-effect-free t))
  (s-join "" (s--mapcar-head 'downcase 'capitalize (s-split-words s))))

(defun s-upper-camel-case (s)
  "Convert S to UpperCamelCase."
  (declare (side-effect-free t))
  (s-join "" (mapcar 'capitalize (s-split-words s))))

(defun s-snake-case (s)
  "Convert S to snake_case."
  (declare (side-effect-free t))
  (s-join "_" (mapcar 'downcase (s-split-words s))))

(defun s-dashed-words (s)
  "Convert S to dashed-words."
  (declare (side-effect-free t))
  (s-join "-" (mapcar 'downcase (s-split-words s))))

(defun s-capitalized-words (s)
  "Convert S to Capitalized words."
  (declare (side-effect-free t))
  (let ((words (s-split-words s)))
    (s-join " " (cons (capitalize (car words)) (mapcar 'downcase (cdr words))))))

(defun s-titleized-words (s)
  "Convert S to Titleized Words."
  (declare (side-effect-free t))
  (s-join " " (mapcar 's-titleize (s-split-words s))))

(defun s-word-initials (s)
  "Convert S to its initials."
  (declare (side-effect-free t))
  (s-join "" (mapcar (lambda (ss) (substring ss 0 1))
                     (s-split-words s))))

;; Errors for s-format
(progn
  (put 's-format-resolve
       'error-conditions
       '(error s-format s-format-resolve))
  (put 's-format-resolve
       'error-message
       "Cannot resolve a template to values"))

(defun s-format (template replacer &optional extra)
  "Format TEMPLATE with the function REPLACER.

REPLACER takes an argument of the format variable and optionally
an extra argument which is the EXTRA value from the call to
`s-format'.

Several standard `s-format' helper functions are recognized and
adapted for this:

    (s-format \"${name}\" 'gethash hash-table)
    (s-format \"${name}\" 'aget alist)
    (s-format \"$0\" 'elt sequence)

The REPLACER function may be used to do any other kind of
transformation."
  (let ((saved-match-data (match-data)))
    (unwind-protect
        (replace-regexp-in-string
         "\\$\\({\\([^}]+\\)}\\|[0-9]+\\)"
         (lambda (md)
           (let ((var
                  (let ((m (match-string 2 md)))
                    (if m m
                      (string-to-number (match-string 1 md)))))
                 (replacer-match-data (match-data)))
             (unwind-protect
                 (let ((v
                        (cond
                         ((eq replacer 'gethash)
                          (funcall replacer var extra))
                         ((eq replacer 'aget)
                          (funcall 's--aget extra var))
                         ((eq replacer 'elt)
                          (funcall replacer extra var))
                         ((eq replacer 'oref)
                          (funcall #'slot-value extra (intern var)))
                         (t
                          (set-match-data saved-match-data)
                          (if extra
                              (funcall replacer var extra)
                            (funcall replacer var))))))
                   (if v (format "%s" v) (signal 's-format-resolve md)))
               (set-match-data replacer-match-data))))
         template
         ;; Need literal to make sure it works
         t t)
      (set-match-data saved-match-data))))

(defvar s-lex-value-as-lisp nil
  "If `t' interpolate lisp values as lisp.

`s-lex-format' inserts values with (format \"%S\").")

(defun s-lex-fmt|expand (fmt)
  "Expand FMT into lisp."
  (declare (side-effect-free t))
  (list 's-format fmt (quote 'aget)
        (append '(list)
                (mapcar
                 (lambda (matches)
                   (list
                    'cons
                    (cadr matches)
                    `(format
                      (if s-lex-value-as-lisp "%S" "%s")
                      ,(intern (cadr matches)))))
                 (s-match-strings-all "${\\([^}]+\\)}" fmt)))))

(defmacro s-lex-format (format-str)
  "`s-format` with the current environment.

FORMAT-STR may use the `s-format' variable reference to refer to
any variable:

 (let ((x 1))
   (s-lex-format \"x is: ${x}\"))

The values of the variables are interpolated with \"%s\" unless
the variable `s-lex-value-as-lisp' is `t' and then they are
interpolated with \"%S\"."
  (declare (debug (form)))
  (s-lex-fmt|expand format-str))

(defun s-count-matches (regexp s &optional start end)
  "Count occurrences of `regexp' in `s'.

`start', inclusive, and `end', exclusive, delimit the part of `s' to
match.  `start' and `end' are both indexed starting at 1; the initial
character in `s' is index 1.

This function starts looking for the next match from the end of the
previous match.  Hence, it ignores matches that overlap a previously
found match.  To count overlapping matches, use
`s-count-matches-all'."
  (declare (side-effect-free t))
  (save-match-data
    (with-temp-buffer
      (insert s)
      (goto-char (point-min))
      (count-matches regexp (or start 1) (or end (point-max))))))

(defun s-count-matches-all (regexp s &optional start end)
  "Count occurrences of `regexp' in `s'.

`start', inclusive, and `end', exclusive, delimit the part of `s' to
match.  `start' and `end' are both indexed starting at 1; the initial
character in `s' is index 1.

This function starts looking for the next match from the second
character of the previous match.  Hence, it counts matches that
overlap a previously found match.  To ignore matches that overlap a
previously found match, use `s-count-matches'."
  (declare (side-effect-free t))
  (let* ((anchored-regexp (format "^%s" regexp))
         (match-count 0)
         (i 0)
         (narrowed-s (substring s
                                (when start (1- start))
                                (when end (1- end)))))
    (save-match-data
      (while (< i (length narrowed-s))
        (when (s-matches? anchored-regexp (substring narrowed-s i))
          (setq match-count (1+ match-count)))
        (setq i (1+ i))))
    match-count))

(defun s-wrap (s prefix &optional suffix)
  "Wrap string S with PREFIX and optionally SUFFIX.

Return string S with PREFIX prepended.  If SUFFIX is present, it
is appended, otherwise PREFIX is used as both prefix and
suffix."
  (declare (pure t) (side-effect-free t))
  (concat prefix s (or suffix prefix)))


;;; Aliases

(defalias 's-blank-p 's-blank?)
(defalias 's-blank-str-p 's-blank-str?)
(defalias 's-capitalized-p 's-capitalized?)
(defalias 's-contains-p 's-contains?)
(defalias 's-ends-with-p 's-ends-with?)
(defalias 's-equals-p 's-equals?)
(defalias 's-less-p 's-less?)
(defalias 's-lowercase-p 's-lowercase?)
(defalias 's-matches-p 's-matches?)
(defalias 's-mixedcase-p 's-mixedcase?)
(defalias 's-numeric-p 's-numeric?)
(defalias 's-prefix-p 's-starts-with?)
(defalias 's-prefix? 's-starts-with?)
(defalias 's-present-p 's-present?)
(defalias 's-starts-with-p 's-starts-with?)
(defalias 's-suffix-p 's-ends-with?)
(defalias 's-suffix? 's-ends-with?)
(defalias 's-uppercase-p 's-uppercase?)


(provide 's)
;;; s.el ends here
#+end_src

** org-tangle

Adapted from [[https://github.com/doomemacs/doomemacs/blob/master/bin/org-tangle][here]]:

#+begin_src shell :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
;;; bin/org-tangle

;; Tangles source blocks from org files. Also expands #+INCLUDE directives,
;; unlike vanilla `ob-tangle'. Debug/info messages are directed to stderr and
;; can be ignored.
;;
;;   -l/--lang LANG
;;     Only include blocks in the specified language (e.g. emacs-lisp).
;;   -a/--all
;;     Tangle all blocks by default (unless it has :tangle nil set or a
;;     :notangle: tag)
;;   -t/--tag TAG
;;      --and TAG
;;      --or TAG
;;     Only include blocks in trees that have these tags. Combine multiple --and
;;     and --or's, or just use --tag (implicit --and).
;;   -p/--print
;;     Prints tangled code to stdout instead of to files
;;
;; Usage: org-tangle [[-l|--lang] LANG] some-file.org another.org
;; Examples:
;;   org-tangle -l sh modules/some/module/README.org > install_module.sh
;;   org-tangle -l sh modules/lang/go/README.org | sh
;;   org-tangle --and tagA --and tagB my/literate/config.org

(require 'cl-lib)
(require 'ox)
(require 'ob-tangle)
(load-file (concat (file-name-directory (or load-file-name buffer-file-name)) "org-tangle-functions.el"))

(defun usage ()
  (with-temp-buffer
    (insert (format "%s %s [OPTIONS] [TARGETS...]\n"
                    "[1mUsage:[0m"
                    (file-name-nondirectory load-file-name))
            "\n"
            "A command line interface for tangling org-mode files. TARGETS can be\n"
            "files or folders (which are searched for org files recursively).\n"
            "\n"
            "This is useful for literate configs that rely on command line\n"
            "workflows to build it.\n"
            "\n"
            "[1mExample:[0m\n"
            "  org-tangle some-file.org\n"
            "  org-tangle literate/config/\n"
            "  org-tangle -p -l sh scripts.org > do_something.sh\n"
            "  org-tangle -p -l python -t tagA -t tagB file.org | python\n"
            "\n"
            "[1mOptions:[0m\n"
            "  -a --all\t\tTangle all blocks by default\n"
            "  -l --lang LANG\tOnly tangle blocks written in LANG\n"
            "  -p --print\t\tPrint tangled output to stdout than to files\n"
            "  -t --tag TAG\n"
            "     --and TAG\n"
            "     --or TAG\n"
            "    Lets you tangle org blocks by tag. You may have more than one\n"
            "    of these options.\n")
    (princ (buffer-string))))

(defun *org-babel-tangle (fn &rest args)
  "Don't write tangled blocks to files, print them to stdout."
  (cl-letf (((symbol-function 'write-region)
             (lambda (start end filename &optional append visit lockname mustbenew)
               (princ (buffer-string)))))
    (apply fn args)))

(defun *org-babel-tangle-collect-blocks (&optional language tangle-file)
  "Like `org-babel-tangle-collect-blocks', but will ignore blocks that are in
trees with the :notangle: tag."
  (let ((counter 0) last-heading-pos blocks)
    (org-babel-map-src-blocks (buffer-file-name)
      (let ((current-heading-pos
             (org-with-wide-buffer
              (org-with-limited-levels (outline-previous-heading)))))
        (if (eq last-heading-pos current-heading-pos) (cl-incf counter)
          (setq counter 1)
          (setq last-heading-pos current-heading-pos)))
      (unless (org-in-commented-heading-p)
        (require 'org)
        (let* ((tags (org-get-tags-at))
               (info (org-babel-get-src-block-info 'light))
               (src-lang (nth 0 info))
               (src-tfile (cdr (assq :tangle (nth 2 info)))))
          (cond ((member "notangle" tags))

                ((and (or or-tags and-tags)
                      (or (not and-tags)
                          (let ((a (cl-intersection and-tags tags :test #'string=))
                                (b and-tags))
                            (not (or (cl-set-difference a b :test #'equal)
                                     (cl-set-difference b a :test #'equal)))))
                      (or (not or-tags)
                          (cl-intersection or-tags tags :test #'string=))
                      t))

                ((or (not (or all-blocks src-tfile))
                     (string= src-tfile "no")  ; tangle blocks by default
                     (and tangle-file (not (equal tangle-file src-tfile)))
                     (and language (not (string= language src-lang)))))

                ;; Add the spec for this block to blocks under its language.
                ((let ((by-lang (assoc src-lang blocks))
                       (block (org-babel-tangle-single-block counter)))
                   (if by-lang
                       (setcdr by-lang (cons block (cdr by-lang)))
                     (push (cons src-lang (list block)) blocks))))))))
    ;; Ensure blocks are in the correct order.
    (mapcar (lambda (b) (cons (car b) (nreverse (cdr b)))) blocks)))
;; (advice-add #'org-babel-tangle-collect-blocks
;;             :override #'*org-babel-tangle-collect-blocks)

(defvar all-blocks nil)
(defvar and-tags nil)
(defvar or-tags nil)
(defvar initial-args argv)
(defvar expanded-args (mapcar #'f-expand argv))
(defvar debug (or (member "-d" initial-args) (member "--debug" initial-args)))
(let (lang srcs and-tags or-tags)
  (pop argv)
  (while argv
    (let ((arg (pop argv)))
      (pcase arg
        ((or "-h" "--help")
         (usage)
         (error ""))
        ((or "-f" "--force")
         nil)
        ((or "-d" "--debug")
         nil)
        ((or "-a" "--all")
         (setq all-blocks t))
        ((or "-l" "--lang")
         (setq lang (pop argv)))
        ((or "-p" "--print")
         (advice-add #'org-babel-tangle :around #'*org-babel-tangle))
        ((or "-t" "--tag" "--and")
         (push (pop argv) and-tags))
        ("--or"
         (push (pop argv) or-tags))
        ((guard (string-match-p "^--lang=" arg))
         (setq lang (cadr (split-string arg "=" t t))))
        ((guard (file-directory-p arg))
         (setq srcs
               (append (directory-files-recursively arg "\\.org$")
                       srcs)))
        ((guard (file-exists-p arg))
         (push arg srcs))
        (_ (if (or (member "-f" initial-args) (member "--force" initial-args))
              (message "Skipping unknown option or file: %s" arg)
              (error "Unknown option or file: %s" arg))))))

  (dolist (file srcs)
		(message (format "\n\nNow tangling %s:\n" file))
    (let ((backup (make-temp-file (file-name-base file) nil ".backup.org")))
      (unwind-protect
          ;; Prevent slow hooks from interfering
          (let (org-mode-hook org-confirm-babel-evaluate make-backup-files)
            ;; We do the ol' switcheroo because `org-babel-tangle' writes
            ;; changes to the current file, which would be imposing on the user.
            (copy-file file backup t)
            (with-current-buffer (find-file-noselect file)
              ;; Tangling doesn't expand #+INCLUDE directives, so we do it
              ;; ourselves, since includes are so useful for literate configs!
              ;; (org-export-expand-include-keyword)
              (org-babel-tangle nil nil lang)))
        (ignore-errors (copy-file backup file t))
        (ignore-errors (delete-file backup)))))
  (kill-emacs 0))
#+end_src

** org-tangle-functions.el
:PROPERTIES:
:header-args:emacs-lisp+: :noweb-ref c2b376ba-f828-4ab9-8379-234a382c279e
:END:

#+begin_src text :tangle (meq/tangle-path) :exports none
<<c2b376ba-f828-4ab9-8379-234a382c279e>>
#+end_src

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]], written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]]:

#+begin_src emacs-lisp
<<777bbfd5-1d72-49ff-89d6-b3e7e8fc7609>>
(mapc (lambda (file) (load-file (meq/oefd (concat file ".el")))) '(
    "uuidgen"
    "a"
    "dash"
    "s"
#+end_src

Must be last; [[https://github.com/rejeep/f.el][f.el]] requires [[https://github.com/magnars/dash.el][dash.el]] and [[https://github.com/magnars/s.el][s.el]]

#+begin_src emacs-lisp
    "f-shortdoc"
    "f"
#+end_src

#+begin_src emacs-lisp
))
#+end_src

Note: the source code for several dependent functions are linked below:
- ~org-babel-noweb-p:~ https://github.com/emacs-mirror/emacs/blob/master/lisp/org/ob-core.el#L2775
- ~org-babel-expand-noweb-references:~ https://github.com/emacs-mirror/emacs/blob/master/lisp/org/ob-core.el#L2785
- ~org-babel-get-src-block-info:~ https://github.com/emacs-mirror/emacs/blob/master/lisp/org/ob-core.el#L623
- ~org-babel-params-from-properties:~ https://github.com/emacs-mirror/emacs/blob/master/lisp/org/ob-core.el#L1476
- ~org-babel-parse-header-arguments:~ https://github.com/emacs-mirror/emacs/blob/master/lisp/org/ob-core.el#L1584
- ~org-babel-read:~ https://github.com/emacs-mirror/emacs/blob/master/lisp/org/ob-core.el#L3014

And just in case, [[https://github.com/emacs-mirror/emacs/blob/master/lisp/org/ob-tangle.el#L198][org-babel-tangle]].

Adapted from [[https://github.com/emacs-mirror/emacs/blob/master/lisp/org/ob-core.el#L823][org-babel-expand-src-block]] and
[[https://lists.gnu.org/archive/html/emacs-orgmode/2018-12/msg00048.html#:~:text=You%20can%20avoid%20the%20error%20if%20you%20additionally%20let%2Dbind%20%0Aorg%2Dbabel%2Dcurrent%2Dsrc%2Dblock%2Dlocation%20to%20the%20location%20of%20datum%3A][here]];
[[https://emacs.stackexchange.com/users/468/david-ongaro][David Ongaro's]] answer [[https://emacs.stackexchange.com/a/29132/31428][here]] is also useful, but doesn't expand ~noweb~ coderefs:

#+begin_src emacs-lisp
(defun meq/org-babel-expand-src-block (&optional light datum info params)
  "Expand the current source code block. Expand according to the source code block's header arguments."
  (let* ((info (or info (org-babel-get-src-block-info t datum)))
         (lang (nth 0 info))
         (params (setf (nth 2 info)
                    (sort (org-babel-merge-params (nth 2 info) params) (lambda (el1 el2) (string< (symbol-name (car el1)) (symbol-name (car el2)))))))
         (params (setf (nth 2 info)
                    (if light params (mapcar (lambda (param) (cons (car param) (org-babel-read (cdr param))))
                                        (-remove (lambda (param) (member (car param) '(:tangle))) params)))))
         (body (setf (nth 1 info) (if (org-babel-noweb-p params :eval) (org-babel-expand-noweb-references info) (nth 1 info))))
         (expand-cmd (intern (concat "org-babel-expand-body:" lang)))
         (assignments-cmd (intern (concat "org-babel-variable-assignments:" lang)))
         (expanded (if (fboundp expand-cmd)
                    (funcall expand-cmd body params)
                    (org-babel-expand-body:generic body params (and (fboundp assignments-cmd) (funcall assignments-cmd params)))))
         (expanded (if (a-has-key? params :shebang)
                    (concat (a-get params :shebang) "\n" expanded)
                    expanded)))
    expanded))
#+end_src

#+begin_src emacs-lisp
(defun meq/org-babel-expand (path &optional return-path light no-check body info parent-buffer datum params)
    (let* ((exists (and path (f-exists? path)))
            (body (if exists (s-trim (f-read path)) body))
            (args (list light datum info params))
            (path-or-body (if return-path path (apply #'meq/org-babel-expand-src-block args))))
        (if (and (not no-check) body)
            (if exists
#+end_src

DO NOT CHANGE THIS TO ~path-or-body~! The expanded source block must always be returned here:

#+begin_src emacs-lisp
                (if (string= body (if return-path (apply #'meq/org-babel-expand-src-block args) path-or-body))
#+end_src

#+begin_src emacs-lisp
                    (if return-path "no")
                    path-or-body)
                path-or-body)
            path-or-body)))
#+end_src

Adapted from [[https://emacs.stackexchange.com/users/5385/mutbuerger][mutbuerger's]] comment
[[https://emacs.stackexchange.com/questions/29131/get-contents-of-a-named-source-block#comment44697_29131][here]] and
[[https://emacs.stackexchange.com/users/12504/alex-stragies][Alex Stragies's]] answer [[https://emacs.stackexchange.com/a/68298/31428][here]];
the code for ~org-babel-lob--src-info~ is [[https://github.com/emacs-mirror/emacs/blob/master/lisp/org/ob-lob.el#L82][here]]:

#+begin_src emacs-lisp
(defun meq/get-block (name &optional light parent-buffer datum params)
    (let* (path return-path no-check body)
        (meq/org-babel-expand path return-path light no-check body (org-babel-lob--src-info name) parent-buffer datum params)))
#+end_src

#+begin_src emacs-lisp
(defun meq/get-header nil (nth 4 (org-heading-components)))
(defun meq/get-theme-from-header nil (s-chop-suffix "-theme.el" (meq/get-header)))

(defun meq/tangle-multi (light dont-check-car &rest paths)
    (mapc (lambda (path) (let* ((body (meq/org-babel-expand (f-expand (substitute-in-file-name path)) nil light)))
                            (if body (f-write body 'utf-8 path)))) (cdr paths))
    (meq/org-babel-expand (f-expand (substitute-in-file-name (car paths))) t light dont-check-car))

(defun meq/tangle-path (&optional light)
    (meq/org-babel-expand (s-chop-prefix "/" (f-join (org-format-outline-path (org-get-outline-path)) (meq/get-header))) t light))
(defun meq/tangle-multipath (&rest paths) (apply #'meq/tangle-multi nil 'dont-check-car (add-to-list 'paths (meq/tangle-path))))
(defun meq/tangle-multipath-light (&rest paths) (apply #'meq/tangle-multi 'light 'dont-check-car (add-to-list 'paths (meq/tangle-path t))))
#+end_src

#+begin_src emacs-lisp
(defun get-README (&optional return-link setupfile lobfile) (interactive)
    (let* ((README (f-join "settings" "README.org"))
        (settings-README (f-expand (s-chop-prefix "/" (f-join (org-format-outline-path (org-get-outline-path)) "README.org"))))
        (flake-settings (s-trim (shell-command-to-string "<<get-settings-path(elisp='t)>>")))
        (flake-README (unless (s-blank? flake-settings) (f-expand (f-join flake-settings "README.org"))))
        (repo-README (f-expand README))
        (home-README (f-expand (f-join "~" README)))
        (user-README (f-expand (f-join "/home/shadowrylander/aiern" README)))
        (root-README (f-expand (f-join "/" README)))
        (env (getenv "SETTINGS_README"))
        (env-README (unless (s-blank? env) (f-expand (substitute-in-file-name env))))
        (file (or (when setupfile (f-expand setupfile))
                  (when lobfile (f-expand lobfile))
                  (cond
                    ((f-exists? README) (concat "./" README))
                    ((and (f-exists? settings-README) (equal (last (f-split settings-README) 2) '("settings" "README.org"))) settings-README)
                    ((f-exists? flake-README) flake-README)
                    ((f-exists? repo-README) repo-README)
                    ((f-exists? home-README) home-README)
                    ((f-exists? user-README) user-README)
                    ((f-exists? root-README) root-README)
                    ((unless (s-blank? env) (f-exists? env-README)) env-README)
                    (t (if return-link
                        "https://raw.githubusercontent.com/sylvorg/settings/main/README.org"
                        (let* ((curl-README (shell-command-to-string "curl -fsSL https://raw.githubusercontent.com/sylvorg/settings/main/README.org 2> /dev/null")))
                            (unless (s-blank? curl-README)
                                (let* ((temp (make-temp-file (uuidgen-5 (uuidgen-4) (uuidgen-4)))))
                                    (f-write curl-README 'utf-8 temp)
                                    temp)))))))))
    file))

(defvar current-lob-file nil)
(defvar current-setup-file nil)

(defun org-babel-pre-tangle-hooks nil (interactive)
    (setq org-elements (let* (
#+end_src

Adapted from [[https://stackoverflow.com/users/109169/netawater][netawater's]] answer [[https://stackoverflow.com/a/17310307/10827766][here]]:

#+begin_src emacs-lisp
            (headlines (org-element-map
                        (org-element-parse-buffer 'headline)
                        'headline
                        (lambda (headline) (downcase (org-element-property :title headline)))))
#+end_src

Adapted from [[https://kitchingroup.cheme.cmu.edu/blog/2013/05/05/Getting-keyword-options-in-org-files/][here]]:

#+begin_src emacs-lisp
            (keywords (org-element-map
                        (org-element-parse-buffer 'element)
                        'keyword
                        (lambda (keyword) (cons (downcase (org-element-property :key keyword)) (org-element-property :value keyword))))))
#+end_src

#+begin_src emacs-lisp
        (unless (or (a-has-key? keywords "nosetupfile") (a-has-key? keywords "nosetuplobfile") (member "no setupfile" headlines))
              (setq current-setup-file (get-README 'return-link (when (a-has-key? keywords "setuplobfile") (a-get keywords "setuplobfile"))))
              (when debug (let* ((m (format "Current Setup File: %s" current-setup-file))
                                  (l (length m))
                                  (b (make-string l ?=)))
                            (message "\n\n%s\n%s\n%s\n\n" b m b)))
#+end_src

Adapted from [[https://stackoverflow.com/users/6148/trey-jackson][Trey Jackson's]] answer [[https://stackoverflow.com/a/2284921/10827766][here]]:

#+begin_src emacs-lisp
              (when (member current-setup-file expanded-args) (global-auto-revert-mode 1))
#+end_src

#+begin_src emacs-lisp
              (goto-char 0)
              (insert (format "#+setupfile: %s\n\n" current-setup-file))
              (goto-char 0)
              (org-ctrl-c-ctrl-c))
        (a-list :keywords keywords :headlines headlines)))
#+end_src

Adapted from [[https://stackoverflow.com/users/3258545/amd][amd's]] answer [[https://stackoverflow.com/a/27158715/10827766][here]] (no longer used):

#+begin_src emacs-lisp :noweb-ref no
    (require 'org-id)
    (setq org-id-locations-file (meq/oefd ".org-id-locations")
          org-id-files (list load-file-name
                             buffer-file-name
                             (meq/oefd "README.org"))
          org-id-link-to-org-use-id t)
    (org-id-update-id-locations)
#+end_src

#+begin_src emacs-lisp
    (setq org-src-preserve-indentation t)
    (let* ((headlines (a-get org-elements :headlines))
            (keywords (a-get org-elements :keywords)))
        (unless (or (a-has-key? keywords "nolobfile") (a-has-key? keywords "nosetuplobfile") (member "no lobfile" headlines))
          (let* ((file (get-README nil nil (cond ((a-has-key? keywords "setuplobfile") (a-get keywords "setuplobfile"))
                                            ((a-has-key? keywords "lobfile") (a-get keywords "lobfile"))))))
            (when file
              (setq current-lob-file file)
              (when debug (let* ((m (format "Current LOB File: %s" current-lob-file))
                                  (l (length m))
                                  (b (make-string l ?=)))
                            (message "\n\n%s\n%s\n%s\n\n" b m b)))
#+end_src

Adapted from [[https://stackoverflow.com/users/6148/trey-jackson][Trey Jackson's]] answer [[https://stackoverflow.com/a/2284921/10827766][here]]:

#+begin_src emacs-lisp
              (when (member current-lob-file expanded-args) (global-auto-revert-mode 1))
#+end_src

#+begin_src emacs-lisp
              (org-babel-lob-ingest current-lob-file)))))
    (org-export-expand-include-keyword))

(defun org-babel-post-tangle-hooks nil (interactive)
#+end_src

Adapted from [[https://stackoverflow.com/users/6148/trey-jackson][Trey Jackson's]] answer [[https://stackoverflow.com/a/2284921/10827766][here]]:

#+begin_src emacs-lisp
  (when (or (member current-setup-file expanded-args) (member current-lob-file expanded-args)) (global-auto-revert-mode -1))
#+end_src

#+begin_src emacs-lisp
)

(mapc (lambda (hook) (interactive) (add-hook hook 'org-babel-pre-tangle-hooks)) '(org-babel-pre-tangle-hook org-export-before-processing-hook))
(mapc (lambda (hook) (interactive) (add-hook hook 'org-babel-post-tangle-hooks)) '(org-babel-post-tangle-hook org-export-after-processing-hook))
#+end_src

** org-interpreter
:PROPERTIES:
:header-args:emacs-lisp+: :noweb-ref 101ff611-520c-4c0b-ad0c-01937a1250e5
:END:

#+begin_src text :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh" :exports none
<<101ff611-520c-4c0b-ad0c-01937a1250e5>>
#+end_src

Inspired by [[https://www.reddit.com/r/emacs/comments/t0yy91/comment/hycx6o2/?utm_source=share&utm_medium=web2x&context=3][this comment on reddit]].

~Note:~ For ~hy / hylang~ blocks, for print statements to work, you need to use ~:results silent output~,
as noted [[https://www.reddit.com/r/emacs/comments/t0yy91/comment/hyfkfhi/?utm_source=share&utm_medium=web2x&context=3][here]].
The two print statements you need to know are:

#+begin_src hy
(print "Hello, world!")
#+end_src

And:

#+begin_src hy
(import sys)
(.write sys.stdout "Hello, world!")
#+end_src

The former prints the output with a visible newline / carriage return, while the latter does not.

#+begin_src emacs-lisp
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
(pop argv)

(require 'org-element)

(defun require-lang (lang)
    (defvar bootstrap-version)
    (let ((bootstrap-file
        (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
            "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
            'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
    (straight-use-package 'use-package)
    (setq straight-use-package-by-default t)
    (pcase (downcase lang)
        ((or "hy" "hylang") (use-package ob-hy :demand t :straight '(ob-hy :type git :host github :repo "allison-casey/ob-hy") :init (setq org-babel-hy-command "/usr/bin/env hy")))))

(defun message-advice (func &rest args) (interactive)
    (let* ((*message (apply #'format args)))
        (unless (or (string-prefix-p "executing" *message)
                    (string-prefix-p "Code block" *message))
            (apply func args))))
(advice-add #'message :around #'message-advice)

(defun org-babel-eval-error-notify-advice (exit-code stderr)
  "Open a buffer to display STDERR and a message with the value of EXIT-CODE."
  (let ((buf (get-buffer-create org-babel-error-buffer-name)))
    (with-current-buffer buf
      (goto-char (point-max))
      (save-excursion (insert stderr))
      (message (buffer-string)))
    (display-buffer buf))
  (message "Babel evaluation exited with code %S" exit-code))
(advice-add #'org-babel-eval-error-notify :override #'org-babel-eval-error-notify-advice)

(let ((org-confirm-babel-evaluate)
        (lang-list '()))
    (with-temp-buffer
        (while argv
            (let ((arg (pop argv)))
                (pcase arg
                    ((or "-l" "--languages")
                        (while (and (> (length argv) 1) (not (string-prefix-p "-" (car argv))))
                            (add-to-list 'lang-list (pop argv) t)))
                    (_ (setq file arg)))))
        (insert-file-contents file)
        (mapc 'require-lang lang-list)
#+end_src

Source [[https://github.com/bzg/org-mode/blob/main/lisp/ob-core.el#L1258][here]]:

#+begin_src emacs-lisp
        (org-babel-execute-buffer)))
#+end_src

* Addendum

These are just a few blocks I use regularly in my ~org~ files, whether in ~noweb~, naming, or otherwise:

#+name: username
#+begin_src text
shadowrylander
#+end_src

#+name: userhome
#+begin_src text
/home/<<username>>
#+end_src

#+name: reponame
#+begin_src text
aiern
#+end_src

#+name: userrepo
#+begin_src text
<<userhome>>/<<reponame>>
#+end_src

#+name: email
#+begin_src text
titaniumfiles@outlook.com
#+end_src

#+name: hostname
#+begin_src emacs-lisp
(system-name)
#+end_src

#+name: users
#+begin_src json
{
    "primary": "<<username>>",
    "secondary": "frost",
    "nightingale": "curtis"
}
#+end_src

#+name: homes
#+begin_src json
{
    "primary": "<<userhome>>",
    "secondary": "/home/frost",
    "nightingale": "/home/curtis"
}
#+end_src

Adapted from [[https://unix.stackexchange.com/users/37512/timo-tijhof][Timo Tijhof's]] answer [[https://unix.stackexchange.com/a/81699/270053][here]]:

#+begin_src shell
dig @ns1.google.com TXT o-o.myaddr.l.google.com +short -4 | tr -d '"' 2> /dev/null || \
dig @resolver3.opendns.com myip.opendns.com +short -4 2> /dev/null || \
dig @resolver4.opendns.com myip.opendns.com +short -4 2> /dev/null || \
dig @ns1-1.akamaitech.net ANY whoami.akamai.net +short -4 2> /dev/null
#+end_src

#+name: extip
#+begin_src emacs-lisp
(shell-command-to-string (concat "dig @ns1.google.com TXT o-o.myaddr.l.google.com +short -4 | tr -d '\"' 2> /dev/null || "
                                 "dig @resolver3.opendns.com myip.opendns.com +short -4 2> /dev/null || "
                                 "dig @resolver4.opendns.com myip.opendns.com +short -4 2> /dev/null || "
                                 "dig @ns1-1.akamaitech.net ANY whoami.akamai.net +short -4 2> /dev/null"))
#+end_src

#+name: current-file
#+begin_src emacs-lisp
(file-name-nondirectory buffer-file-name)
#+end_src

#+name: ssh-pubkey-id-rsa-bak
#+begin_src text
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDlwBJ7E2qeqw9kMW19indbeLdnEKs/Yrhn9HE0c/gZDzvXYBPQYyf5xr9I9kYxWcHlqp7XEI0LVT4DCA/mgemQtM8ulc1mxwekKtk64uWRi5wLi1E17NWKJfXWRn8XZejwi0iJa0twwVE8m8G2AuFOCSa86sYD3x5X5W+7spAuNET7kl0DLueUHu1u31c7HE1ciV2tIn/f60/bbgEJm9MPcRVZkRxkp+bouaZ1cjWRYDhvyJS30DRhBYtIIort2XVAshQs2Y58oKeCDnjt0gxotfqqWlt4nTQzKtbSN2M6/M+clFQBdT1oUJqpTUJbVxK8+xSEOJcBubupTj0USpmftDf/3WMoMwq+hNEc9C0EN1BYtKk68QWhAz8NROvnx7h6y3UKejhQOg0ueNZggmeNJLbebEs46QmA92khO8zc2pfBRsEa5yP0IgdvWpruTZ1QwjqhGQqGnCw3Oli1PK+5zgT2vXy5yHl3f3duPq8h+LOc+lSBbi2jjkC0gwTQDDDNyzFZ+U9xF7fCmL3V8DCEeO/4HqVxmLJir2TVEDo/3Ug/Q22Yp7P2EZrI2pikZIyBJc5aZJO3d7nGoDB/1BJp9Qm82wvyEpjiOnxHsL4osUqrf401XbiwNqpFkVUoRZkwGraJnrlsYkdHS2Mrrny9sr+PtgZhTjqIuW8z6iVIfQ== titaniumfiles@outlook.com
#+end_src

#+name: ssh-pubkey-id-ed25519-bak
#+begin_src text
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIO8NzKV52dRBAir8ARoFJX/xQDVCNup6xe1ddX1YVXSO sylvorg@syvl.org
#+end_src

#+name: ssh-pubkey-jeet-ray-ecdsa
#+begin_src text
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBGsRy6rLDzmLNISdWahFLGDo+ZZLbndj6k8Q8MUQum/mPAzy8lsAQz/0XiicJz7LlM74tWGDYSJG1Ay2Iyc/ew4= jeet.ray@syvl.org
#+end_src

#+name: ssh-pubkey-jeet-ray-ed25519
#+begin_src text
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICor+WXoAypnk5rkgTljAN6kk8olvKWqtnmGWVuQu8z9 jeet.ray@syvl.org
#+end_src

#+name: ssh-pubkey-jeet-ray-rsa
#+begin_src text
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCs4zqEt/Fkjw0LVQTwJXlovmnqqGWC4UOVPvoLDvo0JD6WeVBDi4cFPX2mpNJYmYJsBLDXeUq5XrQ1ST3BkfVdspsragnD7O92tTEf3/VHfIC1L165pnB08FXQrtIjyLL7Ry4dloUGBYKLnHOtnXlpefKMQzRYUacc7Tr1o2wv+XRoDW9h+qDqJz1O61N68JFLgJWD3/nUkm8siTg1OLvqO9ATp+UgP/Lb08E6HfqYOiD8H+1ZJjz78mo5oZatknvgy8uJJPqEX7/aRM61YA9TG+tw/sf6wlrDtUQUik8Y4k1DLmkhE15wcgq/HF2Rqka/acA9GxA5smNGyjs6CS+H jeet.ray@syvl.org
#+end_src

#+name: ssh-pubkey-shadowrylander-ecdsa
#+begin_src text
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBNlVuY9reRuMloYvecJHHsOYkAPDyQwELOI3kfibslIKI5hY+o1jx5yVyAUomHynP6wulm5aziNc5kWdsRE9BE8= shadowrylander@syvl.org
#+end_src

#+name: ssh-pubkey-shadowrylander-ed25519
#+begin_src text
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAINZ2FCMbnetAnDZ63Wzct+O3MYhtO9+BedATbtiHI9BT shadowrylander@syvl.org
#+end_src

#+name: ssh-pubkey-shadowrylander-rsa
#+begin_src text
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDP8ifT/3d6L2MzZPoTh0bUjQUXuPKfPP8Tp03E5En2x+iKhv+J/U0z0xk7IdPZ4qEO+ZWI5xWbwVkDdnRnJ/5HgA0/ZwmO5Zpj3llSr4dJMUVSSyO23fFIL2WqOpHyQDeexJWMxbU5SmIi+c855VwewCbGDcPnmDo0XgR/u4LRF2pwYGNGFtJ2/GICEIob/2w0ICwi7TMUEkDbUFcP5web81OzsNu80M60VaNl870uT1rwBeKuW7CXFtImYytZ0mOc5LC6d7ugkFS1zAbLOWjt3PJ8Op2MH9ncBj5jCsIlA/OqI72jKwEPOl8evYqWeEOzlVxA7/AkRj7haQqFE8r/ shadowrylander@syvl.org
#+end_src

#+name: primary-distro
#+begin_src text
nixos
#+end_src

#+name: channel
#+begin_src emacs-lisp :var dotted='nil
(format "nixos-22%s05" (if dotted "." "-"))
#+end_src

Adapted from [[https://github.com/divnix/digga/blob/main/examples/devos/flake.nix#L4][here]]:

#+name: generate-nix-conf
#+begin_src emacs-lisp :var delim="" comment="" quoted='nil flake='nil
(format-spec "# extra-substituters = %qhttps://cache.nixos.org/ https://nix-community.cachix.org/%q%d
trusted-substituters = %qhttps://cache.nixos.org/%q%d
# extra-trusted-public-keys = %qcache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=%q%d
trusted-public-keys = %qcache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=%q%d
%ckeep-derivations = true%d
%ckeep-outputs = true%d
extra-experimental-features = %qnix-command flakes%q%d
%caccept-flake-config = true%d
%cshow-trace = true%d
%cfallback = true%d
%cauto-optimise-store = true%d
%cbuilders-use-substitutes = true%d
%ccores = 0%d
%cflake-registry = https://raw.githubusercontent.com/sylvorg/settings/main/flake-registry.json%d
%callow-unsafe-native-code-during-evaluation = true%d
%cmin-free = 262144000%d
%cmax-free = 1073741824%d" `((?d . ,(if flake ";" delim)) (?c . ,(if flake "# " comment)) (?q . ,(if (or flake quoted) "\"" ""))))
#+end_src

#+name: get-settings-path
#+begin_src emacs-lisp :var elisp='nil
(format-spec "nix eval --impure --expr %q((builtins.getFlake or import) (toString ./.)).inputs.settings.outPath%q | tr -d '%q' 2> /dev/null"
  `((?q . ,(if elisp "\\\"" "\""))))
#+end_src

# Adapted From: https://www.reddit.com/r/emacs/comments/4o9f0e/anyone_have_disabled_parts_of_their_config_being/d4apjey?utm_source=share&utm_medium=web2x&context=3

#+name: hash-deprecated
#+begin_src emacs-lisp :var name=""
(md5 (concat (replace-regexp-in-string "/" "" (
    org-format-outline-path (org-get-outline-path))) (
        nth 4 (org-heading-components)) name))
#+end_src

#+name: hash
#+begin_src emacs-lisp
(format-time-string "%Y%m%d%H%M%S%N")
#+end_src